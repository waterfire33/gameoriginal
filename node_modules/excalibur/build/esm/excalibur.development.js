/*! excalibur - 0.31.0 - 2025-9-26
https://github.com/excaliburjs/Excalibur
Copyright (c) 2025 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>
Licensed BSD-2-Clause
@preserve */
function polyfill() {
  if (typeof window === "undefined") {
    window = {
      audioContext: function() {
        return;
      }
    };
  }
  if (typeof window !== "undefined" && !window.requestAnimationFrame) {
    window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
      window.setInterval(callback, 1e3 / 60);
    };
  }
  if (typeof window !== "undefined" && !window.cancelAnimationFrame) {
    window.cancelAnimationFrame = window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function() {
      return;
    };
  }
  if (typeof window !== "undefined" && !window.AudioContext) {
    if (window.webkitAudioContext) {
      const ctx = window.webkitAudioContext;
      const replaceMe = ctx.prototype.decodeAudioData;
      window.webkitAudioContext.prototype.decodeAudioData = function(arrayBuffer) {
        return new Promise((resolve, reject) => {
          replaceMe.call(this, arrayBuffer, resolve, reject);
        });
      };
    }
    window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext || window.oAudioContext;
  }
  if (typeof window !== "undefined" && !window.devicePixelRatio) {
    window.devicePixelRatio = window.devicePixelRatio || 1;
  }
  if (typeof window !== "undefined" && !window.requestIdleCallback) {
    window.requestIdleCallback = window.requestIdleCallback || function(cb) {
      const start = Date.now();
      return setTimeout(function() {
        cb({
          didTimeout: false,
          timeRemaining: function() {
            return Math.max(0, 50 - (Date.now() - start));
          }
        });
      }, 1);
    };
    window.cancelIdleCallback = window.cancelIdleCallback || function(id) {
      clearTimeout(id);
    };
  }
}
const _Flags = class _Flags2 {
  /**
   * Force excalibur to load the Canvas 2D graphics context fallback
   * @warning not all features of excalibur are supported in the Canvas 2D fallback
   */
  static useCanvasGraphicsContext() {
    _Flags2.enable("use-canvas-context");
  }
  /**
   * Force excalibur to use the less optimized image renderer
   */
  static useLegacyImageRenderer() {
    _Flags2.enable("use-legacy-image-renderer");
  }
  /**
   * Freeze all flag modifications making them readonly
   */
  static freeze() {
    _Flags2._FROZEN = true;
  }
  /**
   * Resets internal flag state, not meant to be called by users. Only used for testing.
   *
   * Calling this in your game is UNSUPPORTED
   * @internal
   */
  static _reset() {
    _Flags2._FROZEN = false;
    _Flags2._FLAGS = {};
  }
  /**
   * Enable a specific feature flag by name. **Note: can only be set before {@apilink Engine} constructor time**
   * @param flagName
   */
  static enable(flagName) {
    if (this._FROZEN) {
      throw Error("Feature flags can only be enabled before Engine constructor time");
    }
    _Flags2._FLAGS[flagName] = true;
  }
  /**
   * Disable a specific feature flag by name. **Note: can only be set before {@apilink Engine} constructor time**
   * @param flagName
   */
  static disable(flagName) {
    if (this._FROZEN) {
      throw Error("Feature flags can only be disabled before Engine constructor time");
    }
    _Flags2._FLAGS[flagName] = false;
  }
  /**
   * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned
   * @param flagName
   */
  static isEnabled(flagName) {
    return !!_Flags2._FLAGS[flagName];
  }
  /**
   * Show a list of currently known flags
   */
  static show() {
    return Object.keys(_Flags2._FLAGS);
  }
};
_Flags._FROZEN = false;
_Flags._FLAGS = {};
let Flags = _Flags;
function createId(type, value) {
  return { type, value };
}
class Future {
  constructor() {
    this._isCompleted = false;
    this.promise = new Promise((resolve, reject) => {
      this._resolver = resolve;
      this._rejecter = reject;
    });
  }
  get isCompleted() {
    return this._isCompleted;
  }
  resolve(value) {
    if (this._isCompleted) {
      return;
    }
    this._isCompleted = true;
    this._resolver(value);
  }
  reject(error) {
    if (this._isCompleted) {
      return;
    }
    this._isCompleted = true;
    this._rejecter(error);
  }
}
class EventEmitter {
  constructor() {
    this._paused = false;
    this._empty = true;
    this._listeners = {};
    this._listenersOnce = {};
    this._pipes = [];
  }
  /**
   * Removes all listeners and pipes
   */
  clear() {
    this._listeners = {};
    this._listenersOnce = {};
    this._pipes.length = 0;
    this._empty = true;
  }
  on(eventName, handler) {
    var _a;
    this._empty = false;
    this._listeners[eventName] = (_a = this._listeners[eventName]) != null ? _a : [];
    this._listeners[eventName].push(handler);
    return {
      close: () => this.off(eventName, handler)
    };
  }
  once(eventName, handler) {
    var _a;
    this._empty = false;
    this._listenersOnce[eventName] = (_a = this._listenersOnce[eventName]) != null ? _a : [];
    this._listenersOnce[eventName].push(handler);
    return {
      close: () => this.off(eventName, handler)
    };
  }
  off(eventName, handler) {
    var _a, _b;
    if (handler) {
      const newListeners = (_a = this._listeners[eventName]) == null ? void 0 : _a.filter((h) => h !== handler);
      this._listeners[eventName] = newListeners;
      const newOnceListeners = (_b = this._listenersOnce[eventName]) == null ? void 0 : _b.filter((h) => h !== handler);
      this._listenersOnce[eventName] = newOnceListeners;
    } else {
      delete this._listeners[eventName];
    }
  }
  emit(eventName, event) {
    if (this._empty) {
      return;
    }
    if (this._paused) {
      return;
    }
    const listeners = this._listeners[eventName];
    if (listeners) {
      for (let i = 0; i < listeners.length; i++) {
        listeners[i](event);
      }
    }
    const onces = this._listenersOnce[eventName];
    this._listenersOnce[eventName] = [];
    if (onces) {
      for (let i = 0; i < onces.length; i++) {
        onces[i](event);
      }
    }
    for (let i = 0; i < this._pipes.length; i++) {
      this._pipes[i].emit(eventName, event);
    }
  }
  /**
   * Replay events from this emitter to another
   * @param emitter
   */
  pipe(emitter) {
    if (this === emitter) {
      throw Error("Cannot pipe to self");
    }
    this._empty = false;
    this._pipes.push(emitter);
    return {
      close: () => {
        const i = this._pipes.indexOf(emitter);
        if (i > -1) {
          this._pipes.splice(i, 1);
        }
      }
    };
  }
  /**
   * Remove any piped emitters
   * @param emitter
   */
  unpipe(emitter) {
    const i = this._pipes.indexOf(emitter);
    if (i > -1) {
      this._pipes.splice(i, 1);
    }
  }
  /**
   * Paused event emitters do not emit events
   */
  pause() {
    this._paused = true;
  }
  /**
   * Unpaused event emitter do emit events
   */
  unpause() {
    this._paused = false;
  }
}
var PointerScope = /* @__PURE__ */ ((PointerScope2) => {
  PointerScope2["Canvas"] = "Canvas";
  PointerScope2["Document"] = "Document";
  return PointerScope2;
})(PointerScope || {});
var RotationType = /* @__PURE__ */ ((RotationType2) => {
  RotationType2["ShortestPath"] = "shortest-path";
  RotationType2["LongestPath"] = "longest-path";
  RotationType2["Clockwise"] = "clockwise";
  RotationType2["CounterClockwise"] = "counter-clockwise";
  return RotationType2;
})(RotationType || {});
const BITMASK32 = 4294967295;
const initialSeed = Date.now();
let seedOffset = 0;
class Random {
  /**
   * If no seed is specified, the Date.now() is used
   */
  constructor(seed) {
    this._lowerMask = 2147483647;
    this._upperMask = 2147483648;
    this._w = 32;
    this._n = 624;
    this._m = 397;
    this._a = 2567483615;
    this._u = 11;
    this._s = 7;
    this._b = 2636928640;
    this._t = 15;
    this._c = 4022730752;
    this._l = 18;
    this._f = 1812433253;
    this._mt = new Array(this._n);
    this._mt[0] = (seed || initialSeed + seedOffset++) >>> 0;
    this._seed = this._mt[0];
    for (let i = 1; i < this._n; i++) {
      const s = this._mt[i - 1] ^ this._mt[i - 1] >>> this._w - 2;
      this._mt[i] = (this._f * ((s & 4294901760) >>> 16) << 16) + this._f * (s & 65535) + i >>> 0;
    }
    this._index = this._n;
  }
  /**
   * Apply the twist
   */
  _twist() {
    const mag01 = [0, this._a];
    let y = 0, i = 0;
    for (; i < this._n - this._m; i++) {
      y = this._mt[i] & this._upperMask | this._mt[i + 1] & this._lowerMask;
      this._mt[i] = this._mt[i + this._m] ^ y >>> 1 ^ mag01[y & 1] & BITMASK32;
    }
    for (; i < this._n - 1; i++) {
      y = this._mt[i] & this._upperMask | this._mt[i + 1] & this._lowerMask;
      this._mt[i] = this._mt[i + (this._m - this._n)] ^ y >>> 1 ^ mag01[y & 1] & BITMASK32;
    }
    y = this._mt[this._n - 1] & this._upperMask | this._mt[0] & this._lowerMask;
    this._mt[this._n - 1] = this._mt[this._m - 1] ^ y >>> 1 ^ mag01[y & 1] & BITMASK32;
    this._index = 0;
  }
  /**
   * Return next 32 bit integer number in sequence
   */
  nextInt() {
    if (this._index >= this._n) {
      this._twist();
    }
    let y = this._mt[this._index++];
    y ^= y >>> this._u;
    y ^= y << this._s & this._b;
    y ^= y << this._t & this._c;
    y ^= y >>> this._l;
    return y >>> 0;
  }
  /**
   * Return a random floating point number between [0, 1)
   */
  next() {
    return this.nextInt() * (1 / 4294967296);
  }
  /**
   * Return a random floating point in range [min, max) min is included, max is not included
   */
  floating(min, max) {
    return (max - min) * this.next() + min;
  }
  /**
   * Return a random integer in range [min, max] min is included, max is included.
   * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a
   */
  integer(min, max) {
    return Math.floor((max - min + 1) * this.next() + min);
  }
  /**
   * Returns true or false randomly with 50/50 odds by default.
   * By default the likelihood of returning a true is .5 (50%).
   * @param likelihood takes values between [0, 1]
   */
  bool(likelihood = 0.5) {
    return this.next() <= likelihood;
  }
  /**
   * Returns one element from an array at random
   */
  pickOne(array) {
    return array[this.integer(0, array.length - 1)];
  }
  /**
   * Returns a new array random picking elements from the original
   * @param array Original array to pick from
   * @param numPicks can be any positive number
   * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates
   * just that it is possible)
   */
  pickSet(array, numPicks, allowDuplicates = false) {
    if (allowDuplicates) {
      return this._pickSetWithDuplicates(array, numPicks);
    } else {
      return this._pickSetWithoutDuplicates(array, numPicks);
    }
  }
  /**
   * Returns a new array randomly picking elements in the original (not reused)
   * @param array Array to pick elements out of
   * @param numPicks must be less than or equal to the number of elements in the array.
   */
  _pickSetWithoutDuplicates(array, numPicks) {
    if (numPicks > array.length || numPicks < 0) {
      throw new Error("Invalid number of elements to pick, must pick a value 0 < n <= length");
    }
    if (numPicks === array.length) {
      return array;
    }
    const result = new Array(numPicks);
    let currentPick = 0;
    const tempArray = array.slice(0);
    while (currentPick < numPicks) {
      const index = this.integer(0, tempArray.length - 1);
      result[currentPick++] = tempArray[index];
      tempArray.splice(index, 1);
    }
    return result;
  }
  /**
   * Returns a new array random picking elements from the original allowing duplicates
   * @param array Array to pick elements out of
   * @param numPicks can be any positive number
   */
  _pickSetWithDuplicates(array, numPicks) {
    if (numPicks < 0) {
      throw new Error("Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT");
    }
    const result = new Array(numPicks);
    for (let i = 0; i < numPicks; i++) {
      result[i] = this.pickOne(array);
    }
    return result;
  }
  /**
   * Returns a new array that has its elements shuffled. Using the Fisher/Yates method
   * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
   */
  shuffle(array) {
    const tempArray = array.slice(0);
    let swap;
    for (let i = 0; i < tempArray.length - 2; i++) {
      const randomIndex = this.integer(i, tempArray.length - 1);
      swap = tempArray[i];
      tempArray[i] = tempArray[randomIndex];
      tempArray[randomIndex] = swap;
    }
    return tempArray;
  }
  /**
   * Generate a list of random integer numbers
   * @param length the length of the final array
   * @param min the minimum integer number to generate inclusive
   * @param max the maximum integer number to generate inclusive
   */
  range(length, min, max) {
    const result = new Array(length);
    for (let i = 0; i < length; i++) {
      result[i] = this.integer(min, max);
    }
    return result;
  }
  /**
   * Returns the result of a d4 dice roll
   */
  d4() {
    return this.integer(1, 4);
  }
  /**
   * Returns the result of a d6 dice roll
   */
  d6() {
    return this.integer(1, 6);
  }
  /**
   * Returns the result of a d8 dice roll
   */
  d8() {
    return this.integer(1, 8);
  }
  /**
   * Returns the result of a d10 dice roll
   */
  d10() {
    return this.integer(1, 10);
  }
  /**
   * Returns the result of a d12 dice roll
   */
  d12() {
    return this.integer(1, 12);
  }
  /**
   * Returns the result of a d20 dice roll
   */
  d20() {
    return this.integer(1, 20);
  }
  get seed() {
    return this._seed;
  }
}
const TwoPI = Math.PI * 2;
function frac(x) {
  if (x >= 0) {
    return x - Math.floor(x);
  } else {
    return x - Math.ceil(x);
  }
}
function sign(val) {
  if (val === 0) {
    return 0;
  }
  return val < 0 ? -1 : 1;
}
function clamp(val, min, max) {
  return Math.min(Math.max(min, val), max);
}
function approximatelyEqual(val1, val2, tolerance) {
  return Math.abs(val1 - val2) < tolerance;
}
function canonicalizeAngle(angle) {
  let tmpAngle = angle;
  if (angle >= TwoPI) {
    while (tmpAngle >= TwoPI) {
      tmpAngle -= TwoPI;
    }
  }
  if (angle < 0) {
    while (tmpAngle < 0) {
      tmpAngle += TwoPI;
    }
  }
  return tmpAngle;
}
function toDegrees(radians) {
  return 180 / Math.PI * radians;
}
function toRadians(degrees) {
  return degrees / 180 * Math.PI;
}
const range = (from, to) => Array.from(new Array(to - from + 1), (_x, i) => i + from);
function randomInRange(min, max, random = new Random()) {
  return random ? random.floating(min, max) : min + Math.random() * (max - min);
}
function randomIntInRange(min, max, random = new Random()) {
  return random ? random.integer(min, max) : Math.round(randomInRange(min, max));
}
const _Vector = class _Vector2 {
  /**
   * @param x  X component of the Vector
   * @param y  Y component of the Vector
   */
  constructor(x, y) {
    this._x = 0;
    this._y = 0;
    this._x = x;
    this._y = y;
  }
  /**
   * A (0, 0) vector
   */
  static get Zero() {
    return new _Vector2(0, 0);
  }
  /**
   * A (1, 1) vector
   */
  static get One() {
    return new _Vector2(1, 1);
  }
  /**
   * A (0.5, 0.5) vector
   */
  static get Half() {
    return new _Vector2(0.5, 0.5);
  }
  /**
   * A unit vector pointing up (0, -1)
   */
  static get Up() {
    return new _Vector2(0, -1);
  }
  /**
   * A unit vector pointing down (0, 1)
   */
  static get Down() {
    return new _Vector2(0, 1);
  }
  /**
   * A unit vector pointing left (-1, 0)
   */
  static get Left() {
    return new _Vector2(-1, 0);
  }
  /**
   * A unit vector pointing right (1, 0)
   */
  static get Right() {
    return new _Vector2(1, 0);
  }
  /**
   * Returns a vector of unit length in the direction of the specified angle in Radians.
   * @param angle The angle to generate the vector
   */
  static fromAngle(angle) {
    return new _Vector2(Math.cos(angle), Math.sin(angle));
  }
  /**
   * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.
   */
  static isValid(vec2) {
    if (vec2 === null || vec2 === void 0) {
      return false;
    }
    if (isNaN(vec2.x) || isNaN(vec2.y)) {
      return false;
    }
    if (vec2.x === Infinity || vec2.y === Infinity || vec2.x === -Infinity || vec2.y === -Infinity) {
      return false;
    }
    return true;
  }
  /**
   * Calculates distance between two Vectors
   * @param vec1
   * @param vec2
   */
  static distance(vec1, vec2) {
    return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));
  }
  static min(vec1, vec2) {
    return new _Vector2(Math.min(vec1.x, vec2.x), Math.min(vec1.y, vec2.y));
  }
  static max(vec1, vec2) {
    return new _Vector2(Math.max(vec1.x, vec2.x), Math.max(vec1.y, vec2.y));
  }
  /**
   * Get the x component of the vector
   */
  get x() {
    return this._x;
  }
  /**
   * Set the x component, THIS MUTATES the current vector. It is usually better to create a new vector.
   * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
   */
  set x(val) {
    this._x = val;
  }
  /**
   * Get the y component of the vector
   */
  get y() {
    return this._y;
  }
  /**
   * Set the y component, THIS MUTATES the current vector. It is usually better to create a new vector.
   * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
   */
  set y(val) {
    this._y = val;
  }
  /**
   * Sets the x and y components at once, THIS MUTATES the current vector. It is usually better to create a new vector.
   * @warning **Be very careful using this, mutating vectors can cause hard to find bugs**
   */
  setTo(x, y) {
    this.x = x;
    this.y = y;
  }
  /**
   * Compares this point against another and tests for equality
   * @param vector The other point to compare to
   * @param tolerance Amount of euclidean distance off we are willing to tolerate
   */
  equals(vector2, tolerance = _Vector2.EQUALS_EPSILON) {
    return Math.abs(this.x - vector2.x) <= tolerance && Math.abs(this.y - vector2.y) <= tolerance;
  }
  /**
   * The distance to another vector. If no other Vector is specified, this will return the {@apilink magnitude}.
   * @param v  The other vector. Leave blank to use origin vector.
   */
  distance(v) {
    if (!v) {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    const deltaX = this.x - v.x;
    const deltaY = this.y - v.y;
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  }
  squareDistance(v) {
    if (!v) {
      v = _Vector2.Zero;
    }
    const deltaX = this.x - v.x;
    const deltaY = this.y - v.y;
    return deltaX * deltaX + deltaY * deltaY;
  }
  /**
   * Clamps the current vector's magnitude mutating it
   * @param magnitude
   */
  clampMagnitude(magnitude) {
    const size = this.magnitude;
    const newSize = clamp(size, 0, magnitude);
    this.magnitude = newSize;
    return this;
  }
  /**
   * The size (magnitude) of the Vector
   * @deprecated Will be removed in v1, use Vector.magnitude
   */
  get size() {
    return this.distance();
  }
  /**
   * Setting the size mutates the current vector
   * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**
   * @deprecated Will be removed in v1, use Vector.magnitude
   */
  set size(newLength) {
    const v = this.normalize().scale(newLength);
    this.setTo(v.x, v.y);
  }
  /**
   * The magnitude (length) of the Vector
   */
  get magnitude() {
    return this.distance();
  }
  /**
   * Setting the size mutates the current vector
   * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**
   */
  set magnitude(newMagnitude) {
    this.normalize().scale(newMagnitude, this);
  }
  /**
   * Normalizes a non-zero vector to have a magnitude of 1. Zero vectors return a new zero vector.
   */
  normalize() {
    const distance = this.distance();
    if (distance === 0) {
      return _Vector2.Zero;
    }
    return new _Vector2(this.x / distance, this.y / distance);
  }
  /**
   * Returns the average (midpoint) between the current point and the specified
   */
  average(vec2) {
    return this.add(vec2).scale(0.5);
  }
  scale(sizeOrScale, dest) {
    const result = dest || new _Vector2(0, 0);
    if (sizeOrScale instanceof _Vector2) {
      result.x = this.x * sizeOrScale.x;
      result.y = this.y * sizeOrScale.y;
    } else {
      result.x = this.x * sizeOrScale;
      result.y = this.y * sizeOrScale;
    }
    return result;
  }
  /**
   * Adds one vector to another
   * @param v The vector to add
   * @param dest Optionally copy the result into a provided vector
   */
  add(v, dest) {
    if (dest) {
      dest.x = this.x + v.x;
      dest.y = this.y + v.y;
      return dest;
    }
    return new _Vector2(this.x + v.x, this.y + v.y);
  }
  /**
   * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B
   * @param v The vector to subtract
   */
  sub(v, dest) {
    const result = dest || new _Vector2(0, 0);
    const x = this.x - v.x;
    const y = this.y - v.y;
    result.x = x;
    result.y = y;
    return result;
  }
  /**
   * Adds one vector to this one modifying the original
   * @param v The vector to add
   * @warning Be very careful using this, mutating vectors can cause hard to find bugs
   */
  addEqual(v) {
    this.setTo(this.x + v.x, this.y + v.y);
    return this;
  }
  /**
   * Subtracts a vector from this one modifying the original
   * @param v The vector to subtract
   * @warning Be very careful using this, mutating vectors can cause hard to find bugs
   */
  subEqual(v) {
    this.setTo(this.x - v.x, this.y - v.y);
    return this;
  }
  /**
   * Scales this vector by a factor of size and modifies the original
   * @warning Be very careful using this, mutating vectors can cause hard to find bugs
   */
  scaleEqual(size) {
    this.setTo(this.x * size, this.y * size);
    return this;
  }
  /**
   * Performs a dot product with another vector
   * @param v  The vector to dot
   */
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    if (v instanceof _Vector2) {
      return this.x * v.y - this.y * v.x;
    } else if (typeof v === "number") {
      return new _Vector2(v * this.y, -v * this.x);
    }
  }
  static cross(num, vec2) {
    return new _Vector2(-num * vec2.y, num * vec2.x);
  }
  /**
   * Returns the perpendicular vector to this one
   */
  perpendicular() {
    return new _Vector2(this.y, -this.x);
  }
  /**
   * Returns the normal vector to this one, same as the perpendicular of length 1
   */
  normal() {
    return this.perpendicular().normalize();
  }
  /**
   * Negate the current vector
   */
  negate() {
    return this.scale(-1);
  }
  /**
   * Returns the angle of this vector, in range [0, 2*PI)
   */
  toAngle() {
    return canonicalizeAngle(Math.atan2(this.y, this.x));
  }
  /**
   * Returns the difference in radians between the angle of this vector and given angle,
   * using the given rotation type.
   * @param angle in radians to which the vector has to be rotated, using {@apilink rotate}
   * @param rotationType what {@apilink RotationType} to use for the rotation
   * @returns the angle by which the vector needs to be rotated to match the given angle
   */
  angleBetween(angle, rotationType) {
    const startAngleRadians = this.toAngle();
    const endAngleRadians = canonicalizeAngle(angle);
    let rotationClockwise = 0;
    let rotationAntiClockwise = 0;
    if (endAngleRadians > startAngleRadians) {
      rotationClockwise = endAngleRadians - startAngleRadians;
    } else {
      rotationClockwise = (TwoPI - startAngleRadians + endAngleRadians) % TwoPI;
    }
    rotationAntiClockwise = (rotationClockwise - TwoPI) % TwoPI;
    switch (rotationType) {
      case RotationType.ShortestPath:
        if (Math.abs(rotationClockwise) < Math.abs(rotationAntiClockwise)) {
          return rotationClockwise;
        } else {
          return rotationAntiClockwise;
        }
      case RotationType.LongestPath:
        if (Math.abs(rotationClockwise) > Math.abs(rotationAntiClockwise)) {
          return rotationClockwise;
        } else {
          return rotationAntiClockwise;
        }
      case RotationType.Clockwise:
        return rotationClockwise;
      case RotationType.CounterClockwise:
        return rotationAntiClockwise;
    }
  }
  /**
   * Rotates the current vector around a point by a certain angle in radians.
   * Positive angle means rotation clockwise.
   */
  rotate(angle, anchor, dest) {
    const result = dest || new _Vector2(0, 0);
    if (!anchor) {
      anchor = new _Vector2(0, 0);
    }
    const sinAngle = Math.sin(angle);
    const cosAngle = Math.cos(angle);
    const x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
    const y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
    result.x = x;
    result.y = y;
    return result;
  }
  /**
   * Creates new vector that has the same values as the previous.
   */
  clone(dest) {
    const v = dest != null ? dest : new _Vector2(0, 0);
    v.x = this.x;
    v.y = this.y;
    return v;
  }
  /**
   * Returns a string representation of the vector.
   */
  toString(fixed) {
    if (fixed) {
      return `(${this.x.toFixed(fixed)}, ${this.y.toFixed(fixed)})`;
    }
    return `(${this.x}, ${this.y})`;
  }
  /**
   * Linearly interpolates between the current vector and the target vector.
   * At `t = 0`, the result is the current vector, and at `t = 1`, the result is the target vector.
   * Values of `t` outside the range [0, 1] will be clamped to that range.
   *
   * @param target The target vector to interpolate towards.
   * @param t The interpolation factor, clamped between 0 and 1.
   * @returns A new vector that is the result of the linear interpolation.
   */
  lerp(target, t) {
    t = clamp(t, 0, 1);
    const newVector = new _Vector2(0, 0);
    newVector.x = this.x + (target.x - this.x) * t;
    newVector.y = this.y + (target.y - this.y) * t;
    return newVector;
  }
};
_Vector.EQUALS_EPSILON = 1e-3;
let Vector = _Vector;
function vec(x, y) {
  return new Vector(x, y);
}
class Color {
  /**
   * Creates a new instance of Color from an r, g, b, a
   * @param r  The red component of color (0-255)
   * @param g  The green component of color (0-255)
   * @param b  The blue component of color (0-255)
   * @param a  The alpha component of color (0-1.0)
   */
  constructor(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a != null ? a : 1;
  }
  /**
   * Creates a new instance of Color from an r, g, b, a
   * @param r  The red component of color (0-255)
   * @param g  The green component of color (0-255)
   * @param b  The blue component of color (0-255)
   * @param a  The alpha component of color (0-1.0)
   */
  static fromRGB(r, g, b, a) {
    return new Color(r, g, b, a);
  }
  /**
   * Creates a new instance of Color from a rgb string
   * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)
   */
  static fromRGBString(string) {
    const rgbaRegEx = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)/i;
    let match = null;
    if (match = string.match(rgbaRegEx)) {
      const r = parseInt(match[1], 10);
      const g = parseInt(match[2], 10);
      const b = parseInt(match[3], 10);
      let a = 1;
      if (match[4]) {
        a = parseFloat(match[4]);
      }
      return new Color(r, g, b, a);
    } else {
      throw new Error("Invalid rgb/a string: " + string);
    }
  }
  /**
   * Creates a new instance of Color from a hex string
   * @param hex  CSS color string of the form #ffffff, the alpha component is optional
   */
  static fromHex(hex) {
    const hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
    let match = null;
    if (match = hex.match(hexRegEx)) {
      const r = parseInt(match[1], 16);
      const g = parseInt(match[2], 16);
      const b = parseInt(match[3], 16);
      let a = 1;
      if (match[4]) {
        a = parseInt(match[4], 16) / 255;
      }
      return new Color(r, g, b, a);
    } else {
      throw new Error("Invalid hex string: " + hex);
    }
  }
  /**
   * Creates a new instance of Color from hsla values
   * @param h  Hue is represented [0-1]
   * @param s  Saturation is represented [0-1]
   * @param l  Luminance is represented [0-1]
   * @param a  Alpha is represented [0-1]
   */
  static fromHSL(h, s, l, a = 1) {
    const temp = new HSLColor(h, s, l, a);
    return temp.toRGBA();
  }
  /**
   * Lightens the current color by a specified amount
   * @param factor  The amount to lighten by [0-1]
   */
  lighten(factor = 0.1) {
    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
    temp.l += (1 - temp.l) * factor;
    return temp.toRGBA();
  }
  /**
   * Darkens the current color by a specified amount
   * @param factor  The amount to darken by [0-1]
   */
  darken(factor = 0.1) {
    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
    temp.l -= temp.l * factor;
    return temp.toRGBA();
  }
  /**
   * Saturates the current color by a specified amount
   * @param factor  The amount to saturate by [0-1]
   */
  saturate(factor = 0.1) {
    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
    temp.s += temp.s * factor;
    return temp.toRGBA();
  }
  /**
   * Desaturates the current color by a specified amount
   * @param factor  The amount to desaturate by [0-1]
   */
  desaturate(factor = 0.1) {
    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
    temp.s -= temp.s * factor;
    return temp.toRGBA();
  }
  /**
   * Multiplies a color by another, results in a darker color
   * @param color  The other color
   */
  multiply(color) {
    const newR = color.r / 255 * this.r / 255 * 255;
    const newG = color.g / 255 * this.g / 255 * 255;
    const newB = color.b / 255 * this.b / 255 * 255;
    const newA = color.a * this.a;
    return new Color(newR, newG, newB, newA);
  }
  /**
   * Screens a color by another, results in a lighter color
   * @param color  The other color
   */
  screen(color) {
    const color1 = color.invert();
    const color2 = color.invert();
    return color1.multiply(color2).invert();
  }
  /**
   * Inverts the current color
   */
  invert() {
    return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1 - this.a);
  }
  /**
   * Averages the current color with another
   * @param color  The other color
   */
  average(color) {
    const newR = (color.r + this.r) / 2;
    const newG = (color.g + this.g) / 2;
    const newB = (color.b + this.b) / 2;
    const newA = (color.a + this.a) / 2;
    return new Color(newR, newG, newB, newA);
  }
  equal(color) {
    return this.toString() === color.toString();
  }
  /**
   * Returns a CSS string representation of a color.
   * @param format Color representation, accepts: rgb, hsl, or hex
   */
  toString(format = "rgb") {
    switch (format) {
      case "rgb":
        return this.toRGBA();
      case "hsl":
        return this.toHSLA();
      case "hex":
        return this.toHex();
      default:
        throw new Error("Invalid Color format");
    }
  }
  /**
   * Returns Hex Value of a color component
   * @param c color component
   * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
   */
  _componentToHex(c) {
    const hex = Math.max(Math.round(c), 0).toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }
  /**
   * Return Hex representation of a color.
   */
  toHex() {
    let hexRepresentation = "#" + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);
    if (this.a !== 1) {
      hexRepresentation += this._componentToHex(this.a * 255);
    }
    return hexRepresentation;
  }
  /**
   * Return RGBA representation of a color.
   */
  toRGBA() {
    const result = String(this.r.toFixed(0)) + ", " + String(this.g.toFixed(0)) + ", " + String(this.b.toFixed(0));
    if (this.a !== void 0 || this.a !== null) {
      return "rgba(" + result + ", " + String(this.a) + ")";
    }
    return "rgb(" + result + ")";
  }
  /**
   * Return HSLA representation of a color.
   */
  toHSLA() {
    return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();
  }
  /**
   * Returns a CSS string representation of a color.
   */
  fillStyle() {
    return this.toString();
  }
  /**
   * Returns a clone of the current color.
   */
  clone(dest) {
    const result = dest || new Color(this.r, this.g, this.b, this.a);
    result.r = this.r;
    result.g = this.g;
    result.b = this.b;
    result.a = this.a;
    return result;
  }
  /**
   * Black (#000000)
   */
  static get Black() {
    return Color.fromHex("#000000");
  }
  /**
   * White (#FFFFFF)
   */
  static get White() {
    return Color.fromHex("#FFFFFF");
  }
  /**
   * Gray (#808080)
   */
  static get Gray() {
    return Color.fromHex("#808080");
  }
  /**
   * Light gray (#D3D3D3)
   */
  static get LightGray() {
    return Color.fromHex("#D3D3D3");
  }
  /**
   * Dark gray (#A9A9A9)
   */
  static get DarkGray() {
    return Color.fromHex("#A9A9A9");
  }
  /**
   * Yellow (#FFFF00)
   */
  static get Yellow() {
    return Color.fromHex("#FFFF00");
  }
  /**
   * Orange (#FFA500)
   */
  static get Orange() {
    return Color.fromHex("#FFA500");
  }
  /**
   * Red (#FF0000)
   */
  static get Red() {
    return Color.fromHex("#FF0000");
  }
  /**
   * Vermilion (#FF5B31)
   */
  static get Vermilion() {
    return Color.fromHex("#FF5B31");
  }
  /**
   * Rose (#FF007F)
   */
  static get Rose() {
    return Color.fromHex("#FF007F");
  }
  /**
   * Pink (#FFC0CB)
   */
  static get Pink() {
    return Color.fromHex("#FFC0CB");
  }
  /**
   * Magenta (#FF00FF)
   */
  static get Magenta() {
    return Color.fromHex("#FF00FF");
  }
  /**
   * Violet (#7F00FF)
   */
  static get Violet() {
    return Color.fromHex("#7F00FF");
  }
  /**
   * Purple (#800080)
   */
  static get Purple() {
    return Color.fromHex("#800080");
  }
  /**
   * Blue (#0000FF)
   */
  static get Blue() {
    return Color.fromHex("#0000FF");
  }
  /**
   * Azure (#007FFF)
   */
  static get Azure() {
    return Color.fromHex("#007FFF");
  }
  /**
   * Cyan (#00FFFF)
   */
  static get Cyan() {
    return Color.fromHex("#00FFFF");
  }
  /**
   * Viridian (#59978F)
   */
  static get Viridian() {
    return Color.fromHex("#59978F");
  }
  /**
   * Teal (#008080)
   */
  static get Teal() {
    return Color.fromHex("#008080");
  }
  /**
   * Green (#00FF00)
   */
  static get Green() {
    return Color.fromHex("#00FF00");
  }
  /**
   * Chartreuse (#7FFF00)
   */
  static get Chartreuse() {
    return Color.fromHex("#7FFF00");
  }
  /**
   * Transparent (#FFFFFF00)
   */
  static get Transparent() {
    return Color.fromHex("#FFFFFF00");
  }
  /**
   * ExcaliburBlue (#176BAA)
   */
  static get ExcaliburBlue() {
    return Color.fromHex("#176BAA");
  }
  /**
   * Brown (#964B00)
   */
  static get Brown() {
    return Color.fromHex("#964B00");
  }
}
class HSLColor {
  constructor(h, s, l, a) {
    this.h = h;
    this.s = s;
    this.l = l;
    this.a = a;
  }
  static hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  }
  static fromRGBA(r, g, b, a) {
    r /= 255;
    g /= 255;
    b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s;
    const l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
      }
      h /= 6;
    }
    return new HSLColor(h, s, l, a);
  }
  toRGBA() {
    let r, g, b;
    if (this.s === 0) {
      r = g = b = this.l;
    } else {
      const q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;
      const p = 2 * this.l - q;
      r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);
      g = HSLColor.hue2rgb(p, q, this.h);
      b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);
    }
    return new Color(r * 255, g * 255, b * 255, this.a);
  }
  toString() {
    const h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);
    return `hsla(${h}, ${s}, ${l}, ${a})`;
  }
}
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["Debug"] = 0] = "Debug";
  LogLevel2[LogLevel2["Info"] = 1] = "Info";
  LogLevel2[LogLevel2["Warn"] = 2] = "Warn";
  LogLevel2[LogLevel2["Error"] = 3] = "Error";
  LogLevel2[LogLevel2["Fatal"] = 4] = "Fatal";
  return LogLevel2;
})(LogLevel || {});
const _Logger = class _Logger2 {
  constructor() {
    this._appenders = [];
    this.defaultLevel = 1;
    this._logOnceSet = /* @__PURE__ */ new Set();
    if (_Logger2._INSTANCE) {
      throw new Error("Logger is a singleton");
    }
    _Logger2._INSTANCE = this;
    _Logger2._INSTANCE.addAppender(new ConsoleAppender());
    return _Logger2._INSTANCE;
  }
  /**
   * Gets the current static instance of Logger
   */
  static getInstance() {
    if (_Logger2._INSTANCE == null) {
      _Logger2._INSTANCE = new _Logger2();
    }
    return _Logger2._INSTANCE;
  }
  /**
   * Adds a new {@apilink Appender} to the list of appenders to write to
   */
  addAppender(appender) {
    this._appenders.push(appender);
  }
  /**
   * Clears all appenders from the logger
   */
  clearAppenders() {
    this._appenders.length = 0;
  }
  /**
   * Logs a message at a given LogLevel
   * @param level  The LogLevel`to log the message at
   * @param args   An array of arguments to write to an appender
   */
  _log(level, args) {
    if (level == null) {
      level = this.defaultLevel;
    }
    const len = this._appenders.length;
    for (let i = 0; i < len; i++) {
      if (level >= this.defaultLevel) {
        this._appenders[i].log(level, args);
      }
    }
  }
  _logOnce(level, args) {
    const serialized = level + args.join("+");
    if (this._logOnceSet.has(serialized)) {
      return;
    } else {
      this._logOnceSet.add(serialized);
      this._log(level, args);
    }
  }
  /**
   * Writes a log message at the {@apilink LogLevel.Debug} level
   * @param args  Accepts any number of arguments
   */
  debug(...args) {
    this._log(0, args);
  }
  /**
   * Writes a log message once at the {@apilink LogLevel.Fatal} level, if it sees the same args again it wont log
   * @param args  Accepts any number of arguments
   */
  debugOnce(...args) {
    this._logOnce(0, args);
  }
  /**
   * Writes a log message at the {@apilink LogLevel.Info} level
   * @param args  Accepts any number of arguments
   */
  info(...args) {
    this._log(1, args);
  }
  /**
   * Writes a log message once at the {@apilink LogLevel.Info} level, if it sees the same args again it wont log
   * @param args  Accepts any number of arguments
   */
  infoOnce(...args) {
    this._logOnce(1, args);
  }
  /**
   * Writes a log message at the {@apilink LogLevel.Warn} level
   * @param args  Accepts any number of arguments
   */
  warn(...args) {
    this._log(2, args);
  }
  /**
   * Writes a log message once at the {@apilink LogLevel.Warn} level, if it sees the same args again it won't log
   * @param args  Accepts any number of arguments
   */
  warnOnce(...args) {
    this._logOnce(2, args);
  }
  /**
   * Writes a log message at the {@apilink LogLevel.Error} level
   * @param args  Accepts any number of arguments
   */
  error(...args) {
    this._log(3, args);
  }
  /**
   * Writes a log message once at the {@apilink LogLevel.Error} level, if it sees the same args again it won't log
   * @param args  Accepts any number of arguments
   */
  errorOnce(...args) {
    this._logOnce(3, args);
  }
  /**
   * Writes a log message at the {@apilink LogLevel.Fatal} level
   * @param args  Accepts any number of arguments
   */
  fatal(...args) {
    this._log(4, args);
  }
  /**
   * Writes a log message once at the {@apilink LogLevel.Fatal} level, if it sees the same args again it won't log
   * @param args  Accepts any number of arguments
   */
  fatalOnce(...args) {
    this._logOnce(4, args);
  }
};
_Logger._INSTANCE = null;
let Logger = _Logger;
class ConsoleAppender {
  /**
   * Logs a message at the given {@apilink LogLevel}
   * @param level  Level to log at
   * @param args   Arguments to log
   */
  log(level, args) {
    if (!console && !console.log && console.warn && console.error) {
      return;
    }
    const consoleArgs = [];
    consoleArgs.unshift.apply(consoleArgs, args);
    consoleArgs.unshift("[" + LogLevel[level] + "] : ");
    if (level < 2) {
      if (console.log.apply) {
        console.log.apply(console, consoleArgs);
      } else {
        console.log(consoleArgs.join(" "));
      }
    } else if (level < 3) {
      if (console.warn.apply) {
        console.warn.apply(console, consoleArgs);
      } else {
        console.warn(consoleArgs.join(" "));
      }
    } else {
      if (console.error.apply) {
        console.error.apply(console, consoleArgs);
      } else {
        console.error(consoleArgs.join(" "));
      }
    }
  }
}
class ScreenAppender {
  constructor(options) {
    this._messages = [];
    this._pos = 10;
    this._color = Color.Black;
    var _a, _b;
    this._options = options;
    this.canvas = document.createElement("canvas");
    this._ctx = this.canvas.getContext("2d");
    this.canvas.style.position = "absolute";
    this.canvas.style.zIndex = (_b = (_a = options.zIndex) == null ? void 0 : _a.toString()) != null ? _b : "99";
    this.canvas.style.pointerEvents = "none";
    this.canvas.style.userSelect = "none";
    document.body.appendChild(this.canvas);
    this._positionScreenAppenderCanvas();
    options.engine.screen.events.on("resize", () => {
      this._positionScreenAppenderCanvas();
    });
  }
  _positionScreenAppenderCanvas() {
    var _a, _b, _c, _d;
    const options = this._options;
    this.canvas.width = (_a = options.width) != null ? _a : options.engine.screen.resolution.width;
    this.canvas.height = (_b = options.height) != null ? _b : options.engine.screen.resolution.height;
    this.canvas.style.position = "absolute";
    const pagePos = options.engine.screen.screenToPageCoordinates(vec(0, 0));
    this.canvas.style.left = pagePos.x + "px";
    this.canvas.style.top = pagePos.y + "px";
    this._pos = (_c = options.xPos) != null ? _c : this._pos;
    this._color = (_d = options.color) != null ? _d : this._color;
  }
  /**
   * Logs a message at the given {@apilink LogLevel}
   * @param level  Level to log at
   * @param args   Arguments to log
   */
  log(level, args) {
    const message = args.join(",");
    this._ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this._messages.unshift("[" + LogLevel[level] + "] : " + message);
    let pos = 10;
    this._messages = this._messages.slice(0, 1e3);
    for (let i = 0; i < this._messages.length; i++) {
      this._ctx.fillStyle = this._color.toRGBA();
      this._ctx.fillText(this._messages[i], this._pos, pos);
      pos += 10;
    }
  }
}
var CollisionType = /* @__PURE__ */ ((CollisionType2) => {
  CollisionType2["PreventCollision"] = "PreventCollision";
  CollisionType2["Passive"] = "Passive";
  CollisionType2["Active"] = "Active";
  CollisionType2["Fixed"] = "Fixed";
  return CollisionType2;
})(CollisionType || {});
var CoordPlane = /* @__PURE__ */ ((CoordPlane2) => {
  CoordPlane2["World"] = "world";
  CoordPlane2["Screen"] = "screen";
  return CoordPlane2;
})(CoordPlane || {});
var MatrixLocations = /* @__PURE__ */ ((MatrixLocations2) => {
  MatrixLocations2[MatrixLocations2["X"] = 12] = "X";
  MatrixLocations2[MatrixLocations2["Y"] = 13] = "Y";
  return MatrixLocations2;
})(MatrixLocations || {});
class Matrix {
  constructor() {
    this.data = new Float32Array(16);
    this._scaleX = 1;
    this._scaleSignX = 1;
    this._scaleY = 1;
    this._scaleSignY = 1;
  }
  /**
   * Creates an orthographic (flat non-perspective) projection
   * https://en.wikipedia.org/wiki/Orthographic_projection
   * @param left
   * @param right
   * @param bottom
   * @param top
   * @param near
   * @param far
   */
  static ortho(left, right, bottom, top, near, far) {
    const mat = new Matrix();
    mat.data[0] = 2 / (right - left);
    mat.data[1] = 0;
    mat.data[2] = 0;
    mat.data[3] = 0;
    mat.data[4] = 0;
    mat.data[5] = 2 / (top - bottom);
    mat.data[6] = 0;
    mat.data[7] = 0;
    mat.data[8] = 0;
    mat.data[9] = 0;
    mat.data[10] = -2 / (far - near);
    mat.data[11] = 0;
    mat.data[12] = -(right + left) / (right - left);
    mat.data[13] = -(top + bottom) / (top - bottom);
    mat.data[14] = -(far + near) / (far - near);
    mat.data[15] = 1;
    return mat;
  }
  /**
   * Creates a new Matrix with the same data as the current 4x4
   */
  clone(dest) {
    const mat = dest || new Matrix();
    mat.data[0] = this.data[0];
    mat.data[1] = this.data[1];
    mat.data[2] = this.data[2];
    mat.data[3] = this.data[3];
    mat.data[4] = this.data[4];
    mat.data[5] = this.data[5];
    mat.data[6] = this.data[6];
    mat.data[7] = this.data[7];
    mat.data[8] = this.data[8];
    mat.data[9] = this.data[9];
    mat.data[10] = this.data[10];
    mat.data[11] = this.data[11];
    mat.data[12] = this.data[12];
    mat.data[13] = this.data[13];
    mat.data[14] = this.data[14];
    mat.data[15] = this.data[15];
    return mat;
  }
  /**
   * Converts the current matrix into a DOMMatrix
   *
   * This is useful when working with the browser Canvas context
   * @returns {DOMMatrix} DOMMatrix
   */
  toDOMMatrix() {
    return new DOMMatrix([...this.data]);
  }
  static fromFloat32Array(data) {
    const matrix = new Matrix();
    matrix.data = data;
    return matrix;
  }
  /**
   * Creates a new identity matrix (a matrix that when applied does nothing)
   */
  static identity() {
    const mat = new Matrix();
    mat.data[0] = 1;
    mat.data[1] = 0;
    mat.data[2] = 0;
    mat.data[3] = 0;
    mat.data[4] = 0;
    mat.data[5] = 1;
    mat.data[6] = 0;
    mat.data[7] = 0;
    mat.data[8] = 0;
    mat.data[9] = 0;
    mat.data[10] = 1;
    mat.data[11] = 0;
    mat.data[12] = 0;
    mat.data[13] = 0;
    mat.data[14] = 0;
    mat.data[15] = 1;
    return mat;
  }
  /**
   * Resets the current matrix to the identity matrix, mutating it
   * @returns {Matrix} Current matrix as identity
   */
  reset() {
    const mat = this;
    mat.data[0] = 1;
    mat.data[1] = 0;
    mat.data[2] = 0;
    mat.data[3] = 0;
    mat.data[4] = 0;
    mat.data[5] = 1;
    mat.data[6] = 0;
    mat.data[7] = 0;
    mat.data[8] = 0;
    mat.data[9] = 0;
    mat.data[10] = 1;
    mat.data[11] = 0;
    mat.data[12] = 0;
    mat.data[13] = 0;
    mat.data[14] = 0;
    mat.data[15] = 1;
    return mat;
  }
  /**
   * Creates a brand new translation matrix at the specified 3d point
   * @param x
   * @param y
   */
  static translation(x, y) {
    const mat = Matrix.identity();
    mat.data[12] = x;
    mat.data[13] = y;
    return mat;
  }
  /**
   * Creates a brand new scaling matrix with the specified scaling factor
   * @param sx
   * @param sy
   */
  static scale(sx, sy) {
    const mat = Matrix.identity();
    mat.data[0] = sx;
    mat.data[5] = sy;
    mat.data[10] = 1;
    mat.data[15] = 1;
    return mat;
  }
  /**
   * Creates a brand new rotation matrix with the specified angle in radians
   * @param angle
   */
  static rotation(angle) {
    const mat = Matrix.identity();
    mat.data[0] = Math.cos(angle);
    mat.data[4] = -Math.sin(angle);
    mat.data[1] = Math.sin(angle);
    mat.data[5] = Math.cos(angle);
    return mat;
  }
  multiply(vectorOrMatrix, dest) {
    if (vectorOrMatrix instanceof Vector) {
      const result = dest || new Vector(0, 0);
      const vector2 = vectorOrMatrix;
      const resultX = vector2.x * this.data[0] + vector2.y * this.data[4] + this.data[12];
      const resultY = vector2.x * this.data[1] + vector2.y * this.data[5] + this.data[13];
      result.x = resultX;
      result.y = resultY;
      return result;
    } else {
      const result = dest || new Matrix();
      const other = vectorOrMatrix;
      const a11 = this.data[0];
      const a21 = this.data[1];
      const a31 = this.data[2];
      const a41 = this.data[3];
      const a12 = this.data[4];
      const a22 = this.data[5];
      const a32 = this.data[6];
      const a42 = this.data[7];
      const a13 = this.data[8];
      const a23 = this.data[9];
      const a33 = this.data[10];
      const a43 = this.data[11];
      const a14 = this.data[12];
      const a24 = this.data[13];
      const a34 = this.data[14];
      const a44 = this.data[15];
      const b11 = other.data[0];
      const b21 = other.data[1];
      const b31 = other.data[2];
      const b41 = other.data[3];
      const b12 = other.data[4];
      const b22 = other.data[5];
      const b32 = other.data[6];
      const b42 = other.data[7];
      const b13 = other.data[8];
      const b23 = other.data[9];
      const b33 = other.data[10];
      const b43 = other.data[11];
      const b14 = other.data[12];
      const b24 = other.data[13];
      const b34 = other.data[14];
      const b44 = other.data[15];
      result.data[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      result.data[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      result.data[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      result.data[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      result.data[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      result.data[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      result.data[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      result.data[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      result.data[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      result.data[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      result.data[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      result.data[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      result.data[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      result.data[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      result.data[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      result.data[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      const s = this.getScale();
      result._scaleSignX = sign(s.x) * sign(result._scaleSignX);
      result._scaleSignY = sign(s.y) * sign(result._scaleSignY);
      return result;
    }
  }
  /**
   * Applies translation to the current matrix mutating it
   * @param x
   * @param y
   */
  translate(x, y) {
    const a11 = this.data[0];
    const a21 = this.data[1];
    const a31 = this.data[2];
    const a41 = this.data[3];
    const a12 = this.data[4];
    const a22 = this.data[5];
    const a32 = this.data[6];
    const a42 = this.data[7];
    const a13 = this.data[8];
    const a23 = this.data[9];
    const a33 = this.data[10];
    const a43 = this.data[11];
    const a14 = this.data[12];
    const a24 = this.data[13];
    const a34 = this.data[14];
    const a44 = this.data[15];
    const z = 0;
    const w = 1;
    this.data[12] = a11 * x + a12 * y + a13 * z + a14 * w;
    this.data[13] = a21 * x + a22 * y + a23 * z + a24 * w;
    this.data[14] = a31 * x + a32 * y + a33 * z + a34 * w;
    this.data[15] = a41 * x + a42 * y + a43 * z + a44 * w;
    return this;
  }
  setPosition(x, y) {
    this.data[12] = x;
    this.data[13] = y;
  }
  getPosition() {
    return vec(this.data[12], this.data[13]);
  }
  /**
   * Applies rotation to the current matrix mutating it
   * @param angle in Radians
   */
  rotate(angle) {
    const a11 = this.data[0];
    const a21 = this.data[1];
    const a31 = this.data[2];
    const a41 = this.data[3];
    const a12 = this.data[4];
    const a22 = this.data[5];
    const a32 = this.data[6];
    const a42 = this.data[7];
    const sine = Math.sin(angle);
    const cosine = Math.cos(angle);
    this.data[0] = cosine * a11 + sine * a12;
    this.data[1] = cosine * a21 + sine * a22;
    this.data[2] = cosine * a31 + sine * a32;
    this.data[3] = cosine * a41 + sine * a42;
    this.data[4] = cosine * a12 - sine * a11;
    this.data[5] = cosine * a22 - sine * a21;
    this.data[6] = cosine * a32 - sine * a31;
    this.data[7] = cosine * a42 - sine * a41;
    return this;
  }
  /**
   * Applies scaling to the current matrix mutating it
   * @param x
   * @param y
   */
  scale(x, y) {
    const a11 = this.data[0];
    const a21 = this.data[1];
    const a31 = this.data[2];
    const a41 = this.data[3];
    const a12 = this.data[4];
    const a22 = this.data[5];
    const a32 = this.data[6];
    const a42 = this.data[7];
    this.data[0] = a11 * x;
    this.data[1] = a21 * x;
    this.data[2] = a31 * x;
    this.data[3] = a41 * x;
    this.data[4] = a12 * y;
    this.data[5] = a22 * y;
    this.data[6] = a32 * y;
    this.data[7] = a42 * y;
    return this;
  }
  setRotation(angle) {
    const currentScale = this.getScale();
    const sine = Math.sin(angle);
    const cosine = Math.cos(angle);
    this.data[0] = cosine * currentScale.x;
    this.data[1] = sine * currentScale.y;
    this.data[4] = -sine * currentScale.x;
    this.data[5] = cosine * currentScale.y;
  }
  getRotation() {
    const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());
    return canonicalizeAngle(angle);
  }
  getScaleX() {
    const xscale = vec(this.data[0], this.data[4]).magnitude;
    return this._scaleSignX * xscale;
  }
  getScaleY() {
    const yscale = vec(this.data[1], this.data[5]).magnitude;
    return this._scaleSignY * yscale;
  }
  /**
   * Get the scale of the matrix
   */
  getScale() {
    return vec(this.getScaleX(), this.getScaleY());
  }
  setScaleX(val) {
    if (this._scaleX === val) {
      return;
    }
    this._scaleSignX = sign(val);
    const xscale = vec(this.data[0] * this._scaleSignX, this.data[4] * this._scaleSignX).normalize();
    this.data[0] = xscale.x * val;
    this.data[4] = xscale.y * val;
    this._scaleX = val;
  }
  setScaleY(val) {
    if (this._scaleY === val) {
      return;
    }
    this._scaleSignY = sign(val);
    const yscale = vec(this.data[1] * this._scaleSignY, this.data[5] * this._scaleSignY).normalize();
    this.data[1] = yscale.x * val;
    this.data[5] = yscale.y * val;
    this._scaleY = val;
  }
  setScale(scale) {
    this.setScaleX(scale.x);
    this.setScaleY(scale.y);
  }
  /**
   * Determinant of the upper left 2x2 matrix
   */
  getBasisDeterminant() {
    return this.data[0] * this.data[5] - this.data[1] * this.data[4];
  }
  /**
   * Return the affine inverse, optionally store it in a target matrix.
   *
   * It's recommended you call .reset() the target unless you know what you're doing
   * @param target
   */
  getAffineInverse(target) {
    const det = this.getBasisDeterminant();
    const inverseDet = 1 / det;
    const a = this.data[0];
    const b = this.data[4];
    const c = this.data[1];
    const d = this.data[5];
    const m = target || Matrix.identity();
    m.data[0] = d * inverseDet;
    m.data[1] = -c * inverseDet;
    m.data[4] = -b * inverseDet;
    m.data[5] = a * inverseDet;
    const tx = this.data[12];
    const ty = this.data[13];
    m.data[12] = -(tx * m.data[0] + ty * m.data[4]);
    m.data[13] = -(tx * m.data[1] + ty * m.data[5]);
    return m;
  }
  isIdentity() {
    return this.data[0] === 1 && this.data[1] === 0 && this.data[2] === 0 && this.data[3] === 0 && this.data[4] === 0 && this.data[5] === 1 && this.data[6] === 0 && this.data[7] === 0 && this.data[8] === 0 && this.data[9] === 0 && this.data[10] === 1 && this.data[11] === 0 && this.data[12] === 0 && this.data[13] === 0 && this.data[14] === 0 && this.data[15] === 1;
  }
  toString() {
    return `
[${this.data[0]} ${this.data[4]} ${this.data[8]} ${this.data[12]}]
[${this.data[1]} ${this.data[5]} ${this.data[9]} ${this.data[13]}]
[${this.data[2]} ${this.data[6]} ${this.data[10]} ${this.data[14]}]
[${this.data[3]} ${this.data[7]} ${this.data[11]} ${this.data[15]}]
`;
  }
}
class AffineMatrix {
  constructor() {
    this.data = new Float64Array(6);
    this._scale = new Float64Array([1, 1]);
    this._scaleSignX = 1;
    this._scaleSignY = 1;
  }
  /**
   * Converts the current matrix into a DOMMatrix
   *
   * This is useful when working with the browser Canvas context
   * @returns {DOMMatrix} DOMMatrix
   */
  toDOMMatrix() {
    return new DOMMatrix([...this.data]);
  }
  static identity() {
    const mat = new AffineMatrix();
    mat.data[0] = 1;
    mat.data[1] = 0;
    mat.data[2] = 0;
    mat.data[3] = 1;
    mat.data[4] = 0;
    mat.data[5] = 0;
    return mat;
  }
  /**
   * Creates a brand new translation matrix at the specified 3d point
   * @param x
   * @param y
   */
  static translation(x, y) {
    const mat = AffineMatrix.identity();
    mat.data[4] = x;
    mat.data[5] = y;
    return mat;
  }
  /**
   * Creates a brand new scaling matrix with the specified scaling factor
   * @param sx
   * @param sy
   */
  static scale(sx, sy) {
    const mat = AffineMatrix.identity();
    mat.data[0] = sx;
    mat.data[3] = sy;
    mat._scale[0] = sx;
    mat._scale[1] = sy;
    return mat;
  }
  /**
   * Creates a brand new rotation matrix with the specified angle in radians
   * @param angle
   */
  static rotation(angle) {
    const mat = AffineMatrix.identity();
    mat.data[0] = Math.cos(angle);
    mat.data[1] = Math.sin(angle);
    mat.data[2] = -Math.sin(angle);
    mat.data[3] = Math.cos(angle);
    return mat;
  }
  setPosition(x, y) {
    this.data[4] = x;
    this.data[5] = y;
  }
  getPosition() {
    return vec(this.data[4], this.data[5]);
  }
  /**
   * Applies rotation to the current matrix mutating it
   * @param angle in Radians
   */
  rotate(angle) {
    const a11 = this.data[0];
    const a21 = this.data[1];
    const a12 = this.data[2];
    const a22 = this.data[3];
    const sine = Math.sin(angle);
    const cosine = Math.cos(angle);
    this.data[0] = cosine * a11 + sine * a12;
    this.data[1] = cosine * a21 + sine * a22;
    this.data[2] = cosine * a12 - sine * a11;
    this.data[3] = cosine * a22 - sine * a21;
    return this;
  }
  /**
   * Applies translation to the current matrix mutating it
   * @param x
   * @param y
   */
  translate(x, y) {
    const a11 = this.data[0];
    const a21 = this.data[1];
    const a12 = this.data[2];
    const a22 = this.data[3];
    const a13 = this.data[4];
    const a23 = this.data[5];
    this.data[4] = a11 * x + a12 * y + a13;
    this.data[5] = a21 * x + a22 * y + a23;
    return this;
  }
  /**
   * Applies scaling to the current matrix mutating it
   * @param x
   * @param y
   */
  scale(x, y) {
    const a11 = this.data[0];
    const a21 = this.data[1];
    const a12 = this.data[2];
    const a22 = this.data[3];
    this.data[0] = a11 * x;
    this.data[1] = a21 * x;
    this.data[2] = a12 * y;
    this.data[3] = a22 * y;
    this._scale[0] = x;
    this._scale[1] = y;
    this._scaleSignX = sign(x);
    this._scaleSignY = sign(y);
    return this;
  }
  determinant() {
    return this.data[0] * this.data[3] - this.data[1] * this.data[2];
  }
  /**
   * Return the affine inverse, optionally store it in a target matrix.
   *
   * It's recommended you call .reset() the target unless you know what you're doing
   * @param target
   */
  inverse(target) {
    const det = this.determinant();
    let inverseDet = det;
    if (det !== 0) {
      inverseDet = 1 / det;
    }
    const a = this.data[0];
    const b = this.data[2];
    const c = this.data[1];
    const d = this.data[3];
    const m = target || AffineMatrix.identity();
    m.data[0] = d * inverseDet;
    m.data[1] = -c * inverseDet;
    m.data[2] = -b * inverseDet;
    m.data[3] = a * inverseDet;
    const tx = this.data[4];
    const ty = this.data[5];
    m.data[4] = -(tx * m.data[0] + ty * m.data[2]);
    m.data[5] = -(tx * m.data[1] + ty * m.data[3]);
    return m;
  }
  multiply(vectorOrMatrix, dest) {
    if (vectorOrMatrix instanceof Vector) {
      const result = dest || new Vector(0, 0);
      const vector2 = vectorOrMatrix;
      const resultX = vector2.x * this.data[0] + vector2.y * this.data[2] + this.data[4];
      const resultY = vector2.x * this.data[1] + vector2.y * this.data[3] + this.data[5];
      result.x = resultX;
      result.y = resultY;
      return result;
    } else {
      const result = dest || new AffineMatrix();
      const other = vectorOrMatrix;
      const a11 = this.data[0];
      const a21 = this.data[1];
      const a12 = this.data[2];
      const a22 = this.data[3];
      const a13 = this.data[4];
      const a23 = this.data[5];
      const b11 = other.data[0];
      const b21 = other.data[1];
      const b12 = other.data[2];
      const b22 = other.data[3];
      const b13 = other.data[4];
      const b23 = other.data[5];
      result.data[0] = a11 * b11 + a12 * b21;
      result.data[1] = a21 * b11 + a22 * b21;
      result.data[2] = a11 * b12 + a12 * b22;
      result.data[3] = a21 * b12 + a22 * b22;
      result.data[4] = a11 * b13 + a12 * b23 + a13;
      result.data[5] = a21 * b13 + a22 * b23 + a23;
      const signX = this._scaleSignX;
      const signY = this._scaleSignY;
      result._scaleSignX = signX * sign(result._scaleSignX);
      result._scaleSignY = signY * sign(result._scaleSignY);
      return result;
    }
  }
  /**
   * Packed array of length 8, that contains 4 vertices, with 2 components each
   * So: [x0, y0, x1, y1, x2, y2, x3, y3]
   * @param quad
   */
  multiplyQuadInPlace(quad) {
    const resultTopLeftX = quad[0] * this.data[0] + quad[1] * this.data[2] + this.data[4];
    const resultTopLeftY = quad[0] * this.data[1] + quad[1] * this.data[3] + this.data[5];
    quad[0] = resultTopLeftX;
    quad[1] = resultTopLeftY;
    const resultTopRightX = quad[2] * this.data[0] + quad[3] * this.data[2] + this.data[4];
    const resultTopRightY = quad[2] * this.data[1] + quad[3] * this.data[3] + this.data[5];
    quad[2] = resultTopRightX;
    quad[3] = resultTopRightY;
    const resultBottomLeftX = quad[4] * this.data[0] + quad[5] * this.data[2] + this.data[4];
    const resultBottomLeftY = quad[4] * this.data[1] + quad[5] * this.data[3] + this.data[5];
    quad[4] = resultBottomLeftX;
    quad[5] = resultBottomLeftY;
    const resultBottomRightX = quad[6] * this.data[0] + quad[7] * this.data[2] + this.data[4];
    const resultBottomRightY = quad[6] * this.data[1] + quad[7] * this.data[3] + this.data[5];
    quad[6] = resultBottomRightX;
    quad[7] = resultBottomRightY;
  }
  to4x4() {
    const mat = new Matrix();
    mat.data[0] = this.data[0];
    mat.data[1] = this.data[1];
    mat.data[2] = 0;
    mat.data[3] = 0;
    mat.data[4] = this.data[2];
    mat.data[5] = this.data[3];
    mat.data[6] = 0;
    mat.data[7] = 0;
    mat.data[8] = 0;
    mat.data[9] = 0;
    mat.data[10] = 1;
    mat.data[11] = 0;
    mat.data[12] = this.data[4];
    mat.data[13] = this.data[5];
    mat.data[14] = 0;
    mat.data[15] = 1;
    return mat;
  }
  setRotation(angle) {
    const currentScale = this.getScale();
    const sine = Math.sin(angle);
    const cosine = Math.cos(angle);
    this.data[0] = cosine * currentScale.x;
    this.data[1] = sine * currentScale.y;
    this.data[2] = -sine * currentScale.x;
    this.data[3] = cosine * currentScale.y;
  }
  getRotation() {
    const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());
    return canonicalizeAngle(angle);
  }
  getScaleX() {
    const xScaleSq = this.data[0] * this.data[0] + this.data[2] * this.data[2];
    if (xScaleSq === 1) {
      return this._scaleSignX;
    }
    return this._scaleSignX * Math.sqrt(xScaleSq);
  }
  getScaleY() {
    const yScaleSq = this.data[1] * this.data[1] + this.data[3] * this.data[3];
    if (yScaleSq === 1) {
      return this._scaleSignY;
    }
    return this._scaleSignY * Math.sqrt(yScaleSq);
  }
  /**
   * Get the scale of the matrix
   */
  getScale() {
    return vec(this.getScaleX(), this.getScaleY());
  }
  setScaleX(val) {
    if (val === this._scale[0]) {
      return;
    }
    this._scaleSignX = sign(val);
    const xscale = vec(this.data[0] * this._scaleSignX, this.data[2] * this._scaleSignX).normalize();
    this.data[0] = xscale.x * val;
    this.data[2] = xscale.y * val;
    this._scale[0] = val;
  }
  setScaleY(val) {
    if (val === this._scale[1]) {
      return;
    }
    this._scaleSignY = sign(val);
    const yscale = vec(this.data[1] * this._scaleSignY, this.data[3] * this._scaleSignY).normalize();
    this.data[1] = yscale.x * val;
    this.data[3] = yscale.y * val;
    this._scale[1] = val;
  }
  setScale(scale) {
    this.setScaleX(scale.x);
    this.setScaleY(scale.y);
  }
  isIdentity() {
    return this.data[0] === 1 && this.data[1] === 0 && this.data[2] === 0 && this.data[3] === 1 && this.data[4] === 0 && this.data[5] === 0;
  }
  /**
   * Resets the current matrix to the identity matrix, mutating it
   * @returns {AffineMatrix} Current matrix as identity
   */
  reset() {
    const mat = this;
    mat.data[0] = 1;
    mat.data[1] = 0;
    mat.data[2] = 0;
    mat.data[3] = 1;
    mat.data[4] = 0;
    mat.data[5] = 0;
    return mat;
  }
  /**
   * Creates a new Matrix with the same data as the current {@apilink AffineMatrix}
   */
  clone(dest) {
    const mat = dest || new AffineMatrix();
    mat.data[0] = this.data[0];
    mat.data[1] = this.data[1];
    mat.data[2] = this.data[2];
    mat.data[3] = this.data[3];
    mat.data[4] = this.data[4];
    mat.data[5] = this.data[5];
    mat._scaleSignX = this._scaleSignX;
    mat._scaleSignY = this._scaleSignY;
    return mat;
  }
  toString() {
    return `
[${this.data[0]} ${this.data[2]} ${this.data[4]}]
[${this.data[1]} ${this.data[3]} ${this.data[5]}]
[0 0 1]
`;
  }
}
class VectorView extends Vector {
  constructor(options) {
    super(0, 0);
    this._getX = options.getX;
    this._getY = options.getY;
    this._setX = options.setX;
    this._setY = options.setY;
  }
  get x() {
    return this._x = this._getX();
  }
  set x(val) {
    this._setX(val);
    this._x = val;
  }
  get y() {
    return this._y = this._getY();
  }
  set y(val) {
    this._setY(val);
    this._y = val;
  }
}
class WatchVector extends Vector {
  constructor(original, change) {
    super(original.x, original.y);
    this.original = original;
    this.change = change;
  }
  get x() {
    return this._x = this.original.x;
  }
  set x(newX) {
    if (newX !== this._x) {
      this.change(newX, this._y);
      this._x = this.original.x = newX;
    }
  }
  get y() {
    return this._y = this.original.y;
  }
  set y(newY) {
    if (newY !== this._y) {
      this.change(this._x, newY);
      this._y = this.original.y = newY;
    }
  }
  setTo(x, y) {
    this.x = x;
    this.y = y;
  }
}
class Transform {
  constructor() {
    this._parent = null;
    this._children = [];
    this._pos = new WatchVector(vec(0, 0), () => {
      this.flagDirty();
    });
    this._globalPos = new VectorView({
      getX: () => this.matrix.data[4],
      getY: () => this.matrix.data[5],
      setX: (x) => {
        if (this.parent) {
          const { x: newX } = this.parent.inverse.multiply(vec(x, this.pos.y));
          this.pos.x = newX;
        } else {
          this.pos.x = x;
        }
        if (x !== this.matrix.data[4]) {
          this.flagDirty();
        }
      },
      setY: (y) => {
        if (this.parent) {
          const { y: newY } = this.parent.inverse.multiply(vec(this.pos.x, y));
          this.pos.y = newY;
        } else {
          this.pos.y = y;
        }
        if (y !== this.matrix.data[5]) {
          this.flagDirty();
        }
      }
    });
    this._rotation = 0;
    this._scale = new WatchVector(vec(1, 1), () => {
      this.flagDirty();
    });
    this._globalScale = new VectorView({
      getX: () => this.parent ? this.matrix.getScaleX() : this.scale.x,
      getY: () => this.parent ? this.matrix.getScaleY() : this.scale.y,
      setX: (x) => {
        if (this.parent) {
          const globalScaleX = this.parent.globalScale.x;
          this.scale.x = x / globalScaleX;
        } else {
          this.scale.x = x;
        }
      },
      setY: (y) => {
        if (this.parent) {
          const globalScaleY = this.parent.globalScale.y;
          this.scale.y = y / globalScaleY;
        } else {
          this.scale.y = y;
        }
      }
    });
    this._z = 0;
    this._isDirty = false;
    this._isInverseDirty = false;
    this._matrix = AffineMatrix.identity();
    this._inverse = AffineMatrix.identity();
    this._scratch = AffineMatrix.identity();
  }
  get parent() {
    return this._parent;
  }
  set parent(transform) {
    if (this._parent) {
      const index = this._parent._children.indexOf(this);
      if (index > -1) {
        this._parent._children.splice(index, 1);
      }
    }
    this._parent = transform;
    if (this._parent) {
      this._parent._children.push(this);
    }
    this.flagDirty();
  }
  get children() {
    return this._children;
  }
  set pos(v) {
    this._pos.x = v.x;
    this._pos.y = v.y;
  }
  get pos() {
    return this._pos;
  }
  set globalPos(v) {
    let localPos = v.clone();
    if (this.parent) {
      localPos = this.parent.inverse.multiply(v);
    }
    if (!localPos.equals(this._pos)) {
      this._pos = localPos;
      this.flagDirty();
    }
  }
  get globalPos() {
    return this._globalPos;
  }
  set rotation(rotation) {
    const canonRotation = canonicalizeAngle(rotation);
    if (canonRotation !== this._rotation) {
      this.flagDirty();
    }
    this._rotation = canonRotation;
  }
  get rotation() {
    return this._rotation;
  }
  set globalRotation(rotation) {
    let inverseRotation = 0;
    if (this.parent) {
      inverseRotation = this.parent.globalRotation;
    }
    const canonRotation = canonicalizeAngle(rotation + inverseRotation);
    if (canonRotation !== this._rotation) {
      this.flagDirty();
    }
    this._rotation = canonRotation;
  }
  get globalRotation() {
    if (this.parent) {
      return this.matrix.getRotation();
    }
    return this.rotation;
  }
  set scale(v) {
    this._scale.x = v.x;
    this._scale.y = v.y;
  }
  get scale() {
    return this._scale;
  }
  set globalScale(v) {
    let inverseScale = vec(1, 1);
    if (this.parent) {
      inverseScale = this.parent.globalScale;
    }
    this.scale = v.scale(vec(1 / inverseScale.x, 1 / inverseScale.y));
  }
  get globalScale() {
    return this._globalScale;
  }
  set z(z) {
    this._z = z;
    this.flagDirty();
  }
  get z() {
    return this._z;
  }
  set globalZ(z) {
    if (this.parent) {
      this.z = z - this.parent.globalZ;
    } else {
      this.z = z;
    }
  }
  get globalZ() {
    if (this.parent) {
      return this.z + this.parent.globalZ;
    }
    return this.z;
  }
  /**
   * Calculates and returns the matrix representation of this transform
   *
   * Avoid mutating the matrix to update the transform, it is not the source of truth.
   * Update the transform pos, rotation, scale.
   */
  get matrix() {
    if (this._isDirty) {
      if (this.parent === null) {
        this._calculateMatrix().clone(this._matrix);
      } else {
        this.parent.matrix.multiply(this._calculateMatrix()).clone(this._matrix);
      }
      this._isDirty = false;
    }
    return this._matrix;
  }
  /**
   * Calculates and returns the inverse matrix representation of this transform
   */
  get inverse() {
    if (this._isInverseDirty) {
      this.matrix.inverse(this._inverse);
      this._isInverseDirty = false;
    }
    return this._inverse;
  }
  _calculateMatrix() {
    this._scratch.data[0] = Math.cos(this._rotation);
    this._scratch.data[1] = Math.sin(this._rotation);
    this._scratch.data[2] = -Math.sin(this._rotation);
    this._scratch.data[3] = Math.cos(this.rotation);
    this._scratch.data[4] = this._pos.x;
    this._scratch.data[5] = this._pos.y;
    this._scratch.scale(this._scale.x, this._scale.y);
    return this._scratch;
  }
  flagDirty() {
    this._isDirty = true;
    this._isInverseDirty = true;
    for (let i = 0; i < this._children.length; i++) {
      this._children[i].flagDirty();
    }
  }
  apply(point2) {
    return this.matrix.multiply(point2);
  }
  applyInverse(point2) {
    return this.inverse.multiply(point2);
  }
  setTransform(pos, rotation, scale) {
    this._pos.x = pos.x;
    this._pos.y = pos.y;
    this._rotation = canonicalizeAngle(rotation);
    this._scale.x = scale.x;
    this._scale.y = scale.y;
    this.flagDirty();
  }
  /**
   * Returns true if the transform has a negative x scale or y scale, but not both
   */
  isMirrored() {
    const signBitX = sign(this.scale.x) >>> 31;
    const signBitY = sign(this.scale.y) >>> 31;
    const mirrored = signBitX ^ signBitY;
    return !!mirrored;
  }
  /**
   * Clones the current transform
   * **Warning does not clone the parent**
   * @param dest
   */
  clone(dest) {
    const target = dest != null ? dest : new Transform();
    this._pos.clone(target._pos);
    target._z = this._z;
    target._rotation = this._rotation;
    this._scale.clone(target._scale);
    target.flagDirty();
    return target;
  }
  /**
   * Clones but keeps the same parent reference
   */
  cloneWithParent(dest) {
    const target = dest != null ? dest : new Transform();
    this._pos.clone(target._pos);
    target._z = this._z;
    target._rotation = this._rotation;
    this._scale.clone(target._scale);
    target.parent = this.parent;
    target.flagDirty();
    return target;
  }
  toString() {
    return this.matrix.toString();
  }
}
function isComponentCtor(value) {
  return !!value && !!value.prototype && !!value.prototype.constructor;
}
function hasClone(x) {
  return !!(x == null ? void 0 : x.clone);
}
class Component {
  constructor() {
    this.owner = void 0;
  }
  /**
   * Clones any properties on this component, if that property value has a `clone()` method it will be called
   */
  clone() {
    const newComponent = new this.constructor();
    for (const prop in this) {
      if (this.hasOwnProperty(prop)) {
        const val = this[prop];
        if (hasClone(val) && prop !== "owner" && prop !== "clone") {
          newComponent[prop] = val.clone();
        } else {
          newComponent[prop] = val;
        }
      }
    }
    return newComponent;
  }
}
class Observable {
  constructor() {
    this.observers = [];
    this.subscriptions = [];
  }
  /**
   * Register an observer to listen to this observable
   * @param observer
   */
  register(observer) {
    this.observers.push(observer);
  }
  /**
   * Register a callback to listen to this observable
   * @param func
   */
  subscribe(func) {
    this.subscriptions.push(func);
  }
  /**
   * Remove an observer from the observable
   * @param observer
   */
  unregister(observer) {
    const i = this.observers.indexOf(observer);
    if (i !== -1) {
      this.observers.splice(i, 1);
    }
  }
  /**
   * Remove a callback that is listening to this observable
   * @param func
   */
  unsubscribe(func) {
    const i = this.subscriptions.indexOf(func);
    if (i !== -1) {
      this.subscriptions.splice(i, 1);
    }
  }
  /**
   * Broadcasts a message to all observers and callbacks
   * @param message
   */
  notifyAll(message) {
    const observersLength = this.observers.length;
    for (let i = 0; i < observersLength; i++) {
      this.observers[i].notify(message);
    }
    const subscriptionsLength = this.subscriptions.length;
    for (let i = 0; i < subscriptionsLength; i++) {
      this.subscriptions[i](message);
    }
  }
  /**
   * Removes all observers and callbacks
   */
  clear() {
    this.observers.length = 0;
    this.subscriptions.length = 0;
  }
}
class TransformComponent extends Component {
  constructor() {
    super(...arguments);
    this._logger = Logger.getInstance();
    this._parentComponent = null;
    this._transform = new Transform();
    this._addChildTransform = (child) => {
      const childTxComponent = child.get(TransformComponent);
      if (childTxComponent) {
        childTxComponent._transform.parent = this._transform;
        childTxComponent._parentComponent = this;
      }
    };
    this.zIndexChanged$ = new Observable();
    this._coordPlane = CoordPlane.World;
  }
  get() {
    return this._transform;
  }
  onAdd(owner) {
    for (const child of owner.children) {
      this._addChildTransform(child);
    }
    owner.childrenAdded$.subscribe((child) => this._addChildTransform(child));
    owner.childrenRemoved$.subscribe((child) => {
      const childTxComponent = child.get(TransformComponent);
      if (childTxComponent) {
        childTxComponent._transform.parent = null;
        childTxComponent._parentComponent = null;
      }
    });
  }
  onRemove(_previousOwner) {
    this._transform.parent = null;
    this._parentComponent = null;
  }
  /**
   * The z-index ordering of the entity, a higher values are drawn on top of lower values.
   * For example z=99 would be drawn on top of z=0.
   */
  get z() {
    return this._transform.z;
  }
  set z(val) {
    const oldz = this._transform.z;
    this._transform.z = val;
    if (oldz !== val) {
      this.zIndexChanged$.notifyAll(val);
    }
  }
  get globalZ() {
    return this._transform.globalZ;
  }
  set globalZ(z) {
    this._transform.globalZ = z;
  }
  /**
   * The {@apilink CoordPlane | `coordinate plane`} for this transform for the entity.
   */
  get coordPlane() {
    if (this._parentComponent) {
      return this._parentComponent.coordPlane;
    }
    return this._coordPlane;
  }
  set coordPlane(value) {
    var _a;
    if (!this._parentComponent) {
      this._coordPlane = value;
    } else {
      this._logger.warn(
        `Cannot set coordinate plane on child entity ${(_a = this.owner) == null ? void 0 : _a.name}, children inherit their coordinate plane from their parents.`
      );
    }
  }
  get pos() {
    return this._transform.pos;
  }
  set pos(v) {
    this._transform.pos = v;
  }
  get globalPos() {
    return this._transform.globalPos;
  }
  set globalPos(v) {
    this._transform.globalPos = v;
  }
  get rotation() {
    return this._transform.rotation;
  }
  set rotation(rotation) {
    this._transform.rotation = rotation;
  }
  get globalRotation() {
    return this._transform.globalRotation;
  }
  set globalRotation(rotation) {
    this._transform.globalRotation = rotation;
  }
  get scale() {
    return this._transform.scale;
  }
  set scale(v) {
    this._transform.scale = v;
  }
  get globalScale() {
    return this._transform.globalScale;
  }
  set globalScale(v) {
    this._transform.globalScale = v;
  }
  applyInverse(v) {
    return this._transform.applyInverse(v);
  }
  apply(v) {
    return this._transform.apply(v);
  }
  clone() {
    const component = new TransformComponent();
    component._transform = this._transform.clone();
    return component;
  }
}
class MotionComponent extends Component {
  constructor() {
    super(...arguments);
    this.vel = Vector.Zero;
    this.maxVel = Vector.One.scaleEqual(Infinity);
    this.acc = Vector.Zero;
    this.scaleFactor = Vector.Zero;
    this.angularVelocity = 0;
    this.torque = 0;
    this.inertia = 1;
  }
}
const _CollisionGroupManager = class _CollisionGroupManager2 {
  /**
   * Create a new named collision group up to a max of 32.
   * @param name Name for the collision group
   * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one
   */
  static create(name, mask) {
    if (this._CURRENT_GROUP > this._MAX_GROUPS) {
      throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);
    }
    if (this._GROUPS.get(name)) {
      const existingGroup = this._GROUPS.get(name);
      if (existingGroup.mask === mask) {
        return existingGroup;
      }
      throw new Error(`Collision group ${name} already exists with a different mask!`);
    }
    const group = new CollisionGroup(name, this._CURRENT_BIT, mask !== void 0 ? mask : ~this._CURRENT_BIT);
    this._CURRENT_BIT = this._CURRENT_BIT << 1 | 0;
    this._CURRENT_GROUP++;
    this._GROUPS.set(name, group);
    return group;
  }
  /**
   * Get all collision groups currently tracked by excalibur
   */
  static get groups() {
    return Array.from(this._GROUPS.values());
  }
  /**
   * Get a collision group by it's name
   * @param name
   */
  static groupByName(name) {
    return this._GROUPS.get(name);
  }
  /**
   * Resets the managers internal group management state
   */
  static reset() {
    this._GROUPS = /* @__PURE__ */ new Map();
    this._CURRENT_BIT = this._STARTING_BIT;
    this._CURRENT_GROUP = 1;
  }
};
_CollisionGroupManager._STARTING_BIT = 1 | 0;
_CollisionGroupManager._MAX_GROUPS = 32;
_CollisionGroupManager._CURRENT_GROUP = 1;
_CollisionGroupManager._CURRENT_BIT = _CollisionGroupManager._STARTING_BIT;
_CollisionGroupManager._GROUPS = /* @__PURE__ */ new Map();
let CollisionGroupManager = _CollisionGroupManager;
const _CollisionGroup = class _CollisionGroup2 {
  /**
   * STOP!!** It is preferred that {@apilink CollisionGroupManager.create} is used to create collision groups
   *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.
   * @param name Name of the collision group
   * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`
   * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`
   */
  constructor(name, category, mask) {
    this._name = name;
    this._category = category;
    this._mask = mask;
  }
  /**
   * Get the name of the collision group
   */
  get name() {
    return this._name;
  }
  /**
   * Get the category of the collision group, a 32 bit number which should be a unique power of 2
   */
  get category() {
    return this._category;
  }
  /**
   * Get the mask for this collision group
   */
  get mask() {
    return this._mask;
  }
  /**
   * Evaluates whether 2 collision groups can collide
   *
   * This means the mask has the same bit set the other category and vice versa
   * @param other  CollisionGroup
   */
  canCollide(other) {
    const overlap1 = this.category & other.mask;
    const overlap2 = this.mask & other.category;
    return overlap1 !== 0 && overlap2 !== 0;
  }
  /**
   * Inverts the collision group. For example, if before the group specified "players",
   * inverting would specify all groups except players
   * @returns CollisionGroup
   */
  invert() {
    const group = CollisionGroupManager.create("~(" + this.name + ")", ~this.mask | 0);
    group._category = ~this.category;
    return group;
  }
  /**
   * Combine collision groups with each other. The new group includes all of the previous groups.
   * @param collisionGroups
   */
  static combine(collisionGroups) {
    const combinedName = collisionGroups.map((c) => c.name).join("+");
    const combinedCategory = collisionGroups.reduce((current, g) => g.category | current, 0);
    const combinedMask = ~combinedCategory;
    return CollisionGroupManager.create(combinedName, combinedMask);
  }
  /**
   * Creates a collision group that collides with the listed groups
   * @param collisionGroups
   */
  static collidesWith(collisionGroups) {
    const combinedName = `collidesWith(${collisionGroups.map((c) => c.name).join("+")})`;
    const combinedMask = collisionGroups.reduce((current, g) => g.category | current, 0);
    return CollisionGroupManager.create(combinedName, combinedMask);
  }
  toString() {
    return `
category: ${this.category.toString(2).padStart(32, "0")}
mask:     ${(this.mask >>> 0).toString(2).padStart(32, "0")}
    `;
  }
};
_CollisionGroup.All = new _CollisionGroup("Collide with all groups", -1, -1);
let CollisionGroup = _CollisionGroup;
var EventTypes = /* @__PURE__ */ ((EventTypes2) => {
  EventTypes2["Kill"] = "kill";
  EventTypes2["PreKill"] = "prekill";
  EventTypes2["PostKill"] = "postkill";
  EventTypes2["PreDraw"] = "predraw";
  EventTypes2["PostDraw"] = "postdraw";
  EventTypes2["PreDebugDraw"] = "predebugdraw";
  EventTypes2["PostDebugDraw"] = "postdebugdraw";
  EventTypes2["PreUpdate"] = "preupdate";
  EventTypes2["PostUpdate"] = "postupdate";
  EventTypes2["PreFrame"] = "preframe";
  EventTypes2["PostFrame"] = "postframe";
  EventTypes2["PreCollision"] = "precollision";
  EventTypes2["CollisionStart"] = "collisionstart";
  EventTypes2["CollisionEnd"] = "collisionend";
  EventTypes2["PostCollision"] = "postcollision";
  EventTypes2["Initialize"] = "initialize";
  EventTypes2["Activate"] = "activate";
  EventTypes2["Deactivate"] = "deactivate";
  EventTypes2["ExitViewport"] = "exitviewport";
  EventTypes2["EnterViewport"] = "enterviewport";
  EventTypes2["ExitTrigger"] = "exit";
  EventTypes2["EnterTrigger"] = "enter";
  EventTypes2["Connect"] = "connect";
  EventTypes2["Disconnect"] = "disconnect";
  EventTypes2["Button"] = "button";
  EventTypes2["Axis"] = "axis";
  EventTypes2["Visible"] = "visible";
  EventTypes2["Hidden"] = "hidden";
  EventTypes2["Start"] = "start";
  EventTypes2["Stop"] = "stop";
  EventTypes2["PointerUp"] = "pointerup";
  EventTypes2["PointerDown"] = "pointerdown";
  EventTypes2["PointerMove"] = "pointermove";
  EventTypes2["PointerEnter"] = "pointerenter";
  EventTypes2["PointerLeave"] = "pointerleave";
  EventTypes2["PointerCancel"] = "pointercancel";
  EventTypes2["PointerWheel"] = "pointerwheel";
  EventTypes2["Up"] = "up";
  EventTypes2["Down"] = "down";
  EventTypes2["Move"] = "move";
  EventTypes2["Enter"] = "enter";
  EventTypes2["Leave"] = "leave";
  EventTypes2["Cancel"] = "cancel";
  EventTypes2["Wheel"] = "wheel";
  EventTypes2["Press"] = "press";
  EventTypes2["Release"] = "release";
  EventTypes2["Hold"] = "hold";
  EventTypes2["PointerDragStart"] = "pointerdragstart";
  EventTypes2["PointerDragEnd"] = "pointerdragend";
  EventTypes2["PointerDragEnter"] = "pointerdragenter";
  EventTypes2["PointerDragLeave"] = "pointerdragleave";
  EventTypes2["PointerDragMove"] = "pointerdragmove";
  EventTypes2["ActionStart"] = "actionstart";
  EventTypes2["ActionComplete"] = "actioncomplete";
  EventTypes2["Add"] = "add";
  EventTypes2["Remove"] = "remove";
  return EventTypes2;
})(EventTypes || {});
class GameEvent {
  constructor() {
    this.other = null;
    this._bubbles = true;
  }
  /**
   * If set to false, prevents event from propagating to other actors. If true it will be propagated
   * to all actors that apply.
   */
  get bubbles() {
    return this._bubbles;
  }
  set bubbles(value) {
    this._bubbles = value;
  }
  /**
   * Prevents event from bubbling
   */
  stopPropagation() {
    this.bubbles = false;
  }
}
class KillEvent extends GameEvent {
  constructor(self) {
    super();
    this.self = self;
    this.target = self;
  }
}
class PreKillEvent extends GameEvent {
  constructor(self) {
    super();
    this.self = self;
    this.target = self;
  }
}
class PostKillEvent extends GameEvent {
  constructor(self) {
    super();
    this.self = self;
    this.target = self;
  }
}
class GameStartEvent extends GameEvent {
  constructor(self) {
    super();
    this.self = self;
    this.target = self;
  }
}
class GameStopEvent extends GameEvent {
  constructor(self) {
    super();
    this.self = self;
    this.target = self;
  }
}
class PreDrawEvent extends GameEvent {
  constructor(ctx, elapsed, self) {
    super();
    this.ctx = ctx;
    this.elapsed = elapsed;
    this.self = self;
    this.target = self;
  }
}
class PostDrawEvent extends GameEvent {
  constructor(ctx, elapsed, self) {
    super();
    this.ctx = ctx;
    this.elapsed = elapsed;
    this.self = self;
    this.target = self;
  }
}
class PreTransformDrawEvent extends GameEvent {
  constructor(ctx, elapsed, self) {
    super();
    this.ctx = ctx;
    this.elapsed = elapsed;
    this.self = self;
    this.target = self;
  }
}
class PostTransformDrawEvent extends GameEvent {
  constructor(ctx, elapsed, self) {
    super();
    this.ctx = ctx;
    this.elapsed = elapsed;
    this.self = self;
    this.target = self;
  }
}
class PreDebugDrawEvent extends GameEvent {
  constructor(ctx, self) {
    super();
    this.ctx = ctx;
    this.self = self;
    this.target = self;
  }
}
class PostDebugDrawEvent extends GameEvent {
  constructor(ctx, self) {
    super();
    this.ctx = ctx;
    this.self = self;
    this.target = self;
  }
}
class PreUpdateEvent extends GameEvent {
  constructor(engine, elapsed, self) {
    super();
    this.engine = engine;
    this.elapsed = elapsed;
    this.self = self;
    this.target = self;
  }
}
class PostUpdateEvent extends GameEvent {
  constructor(engine, elapsed, self) {
    super();
    this.engine = engine;
    this.elapsed = elapsed;
    this.self = self;
    this.target = self;
  }
}
class PreFrameEvent extends GameEvent {
  constructor(engine, prevStats) {
    super();
    this.engine = engine;
    this.prevStats = prevStats;
    this.target = engine;
  }
}
class PostFrameEvent extends GameEvent {
  constructor(engine, stats) {
    super();
    this.engine = engine;
    this.stats = stats;
    this.target = engine;
  }
}
class GamepadConnectEvent extends GameEvent {
  constructor(index, gamepad) {
    super();
    this.index = index;
    this.gamepad = gamepad;
    this.target = gamepad;
  }
}
class GamepadDisconnectEvent extends GameEvent {
  constructor(index, gamepad) {
    super();
    this.index = index;
    this.gamepad = gamepad;
    this.target = gamepad;
  }
}
class GamepadButtonEvent extends GameEvent {
  /**
   * @param button  The Gamepad {@apilink Buttons} if not known by excalibur {@apilink Buttons.Unknown} is returned, use index to disambiguate.
   * @param index   The canonical index of the gamepad button from the system
   * @param value   A numeric value between 0 and 1
   * @param self    Reference to the gamepad
   */
  constructor(button, index, value, self) {
    super();
    this.button = button;
    this.index = index;
    this.value = value;
    this.self = self;
    this.target = self;
  }
}
class GamepadAxisEvent extends GameEvent {
  /**
   * @param axis  The Gamepad axis
   * @param value A numeric value between -1 and 1
   * @param self Reference to the gamepad
   */
  constructor(axis, value, self) {
    super();
    this.axis = axis;
    this.value = value;
    this.self = self;
    this.target = self;
  }
}
class VisibleEvent extends GameEvent {
  constructor(self) {
    super();
    this.self = self;
    this.target = self;
  }
}
class HiddenEvent extends GameEvent {
  constructor(self) {
    super();
    this.self = self;
    this.target = self;
  }
}
class PreCollisionEvent extends GameEvent {
  /**
   * @param self          The actor the event was thrown on
   * @param other         The actor that will collided with the current actor
   * @param side          The side that will be collided with the current actor
   * @param intersection  Intersection vector
   */
  constructor(self, other, side, intersection, contact) {
    super();
    this.self = self;
    this.other = other;
    this.side = side;
    this.intersection = intersection;
    this.contact = contact;
    this.target = self;
  }
}
class PostCollisionEvent extends GameEvent {
  /**
   * @param self          The actor the event was thrown on
   * @param other         The actor that did collide with the current actor
   * @param side          The side that did collide with the current actor
   * @param intersection  Intersection vector
   */
  constructor(self, other, side, intersection, contact) {
    super();
    this.self = self;
    this.other = other;
    this.side = side;
    this.intersection = intersection;
    this.contact = contact;
    this.target = self;
  }
}
class ContactStartEvent {
  constructor(self, other, side, contact) {
    this.self = self;
    this.other = other;
    this.side = side;
    this.contact = contact;
  }
}
class ContactEndEvent {
  constructor(self, other, side, lastContact) {
    this.self = self;
    this.other = other;
    this.side = side;
    this.lastContact = lastContact;
  }
}
class CollisionPreSolveEvent {
  constructor(self, other, side, intersection, contact) {
    this.self = self;
    this.other = other;
    this.side = side;
    this.intersection = intersection;
    this.contact = contact;
  }
}
class CollisionPostSolveEvent {
  constructor(self, other, side, intersection, contact) {
    this.self = self;
    this.other = other;
    this.side = side;
    this.intersection = intersection;
    this.contact = contact;
  }
}
class CollisionStartEvent extends GameEvent {
  /**
   *
   * @param self
   * @param other
   * @param side
   * @param contact
   */
  constructor(self, other, side, contact) {
    super();
    this.self = self;
    this.other = other;
    this.side = side;
    this.contact = contact;
    this.target = self;
  }
}
class CollisionEndEvent extends GameEvent {
  /**
   *
   */
  constructor(self, other, side, lastContact) {
    super();
    this.self = self;
    this.other = other;
    this.side = side;
    this.lastContact = lastContact;
    this.target = self;
  }
}
class InitializeEvent extends GameEvent {
  /**
   * @param engine  The reference to the current engine
   */
  constructor(engine, self) {
    super();
    this.engine = engine;
    this.self = self;
    this.target = self;
  }
}
class ActivateEvent extends GameEvent {
  /**
   * @param context  The context for the scene activation
   */
  constructor(context, self) {
    super();
    this.context = context;
    this.self = self;
    this.target = self;
  }
}
class DeactivateEvent extends GameEvent {
  /**
   * @param context  The context for the scene deactivation
   */
  constructor(context, self) {
    super();
    this.context = context;
    this.self = self;
    this.target = self;
  }
}
class ExitViewPortEvent extends GameEvent {
  constructor(self) {
    super();
    this.self = self;
    this.target = self;
  }
}
class EnterViewPortEvent extends GameEvent {
  constructor(self) {
    super();
    this.self = self;
    this.target = self;
  }
}
class EnterTriggerEvent extends GameEvent {
  constructor(self, entity) {
    super();
    this.self = self;
    this.entity = entity;
    this.target = self;
  }
}
class ExitTriggerEvent extends GameEvent {
  constructor(self, entity) {
    super();
    this.self = self;
    this.entity = entity;
    this.target = self;
  }
}
class ActionStartEvent extends GameEvent {
  constructor(action, self) {
    super();
    this.action = action;
    this.self = self;
    this.target = self;
  }
}
class ActionCompleteEvent extends GameEvent {
  constructor(action, self) {
    super();
    this.action = action;
    this.self = self;
    this.target = self;
  }
}
class AddEvent extends GameEvent {
  constructor(engine, self) {
    super();
    this.engine = engine;
    this.self = self;
    this.target = self;
  }
}
class RemoveEvent extends GameEvent {
  constructor(engine, self) {
    super();
    this.engine = engine;
    this.self = self;
    this.target = self;
  }
}
const Events = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ActionCompleteEvent,
  ActionStartEvent,
  ActivateEvent,
  AddEvent,
  CollisionEndEvent,
  CollisionPostSolveEvent,
  CollisionPreSolveEvent,
  CollisionStartEvent,
  ContactEndEvent,
  ContactStartEvent,
  DeactivateEvent,
  EnterTriggerEvent,
  EnterViewPortEvent,
  EventTypes,
  ExitTriggerEvent,
  ExitViewPortEvent,
  GameEvent,
  GameStartEvent,
  GameStopEvent,
  GamepadAxisEvent,
  GamepadButtonEvent,
  GamepadConnectEvent,
  GamepadDisconnectEvent,
  HiddenEvent,
  InitializeEvent,
  KillEvent,
  PostCollisionEvent,
  PostDebugDrawEvent,
  PostDrawEvent,
  PostFrameEvent,
  PostKillEvent,
  PostTransformDrawEvent,
  PostUpdateEvent,
  PreCollisionEvent,
  PreDebugDrawEvent,
  PreDrawEvent,
  PreFrameEvent,
  PreKillEvent,
  PreTransformDrawEvent,
  PreUpdateEvent,
  RemoveEvent,
  VisibleEvent
}, Symbol.toStringTag, { value: "Module" }));
function getMinIndex(array) {
  if (array.length === 0) {
    throw new Error("Cannot find minIndex of array.length == 0");
  }
  let min = array[0];
  let minIndex = 0;
  for (let i = 1; i < array.length; i++) {
    if (array[i] < min) {
      min = array[i];
      minIndex = i;
    }
  }
  return minIndex;
}
function getPosition(el) {
  if (el && el.getBoundingClientRect) {
    const rect = el.getBoundingClientRect();
    return vec(rect.x + window.scrollX, rect.y + window.scrollY);
  }
  return Vector.Zero;
}
function addItemToArray(item, array) {
  if (array.indexOf(item) === -1) {
    array.push(item);
    return true;
  }
  return false;
}
function removeItemFromArray(item, array) {
  let index = -1;
  if ((index = array.indexOf(item)) > -1) {
    array.splice(index, 1);
    return true;
  }
  return false;
}
function contains(array, obj) {
  for (let i = 0; i < array.length; i++) {
    if (array[i] === obj) {
      return true;
    }
  }
  return false;
}
function fail(message) {
  throw new Error(message);
}
function delay(milliseconds, clock) {
  var _a;
  const future = new Future();
  const schedule = (_a = clock == null ? void 0 : clock.schedule.bind(clock)) != null ? _a : setTimeout;
  schedule(() => {
    future.resolve();
  }, milliseconds);
  return future.promise;
}
function omit(object, keys) {
  const newObj = {};
  for (const key in object) {
    if (!keys.includes(key)) {
      newObj[key] = object[key];
    }
  }
  return newObj;
}
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function mergeDeep(target, ...sources) {
  if (!sources.length) {
    return target;
  }
  const source = sources.shift();
  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (!target[key]) {
          Object.assign(target, { [key]: {} });
        }
        mergeDeep(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }
  return mergeDeep(target, ...sources);
}
class AddedComponent {
  constructor(data) {
    this.data = data;
    this.type = "Component Added";
  }
}
function isAddedComponent(x) {
  return !!x && x.type === "Component Added";
}
class RemovedComponent {
  constructor(data) {
    this.data = data;
    this.type = "Component Removed";
  }
}
function isRemovedComponent(x) {
  return !!x && x.type === "Component Removed";
}
const EntityEvents = {
  Add: "add",
  Remove: "remove",
  Initialize: "initialize",
  PreUpdate: "preupdate",
  PostUpdate: "postupdate",
  Kill: "kill"
};
const _Entity = class _Entity2 {
  constructor(componentsOrOptions, name) {
    this.id = _Entity2._ID++;
    this.name = `Entity#${this.id}`;
    this.events = new EventEmitter();
    this._tags = /* @__PURE__ */ new Set();
    this.componentAdded$ = new Observable();
    this.componentRemoved$ = new Observable();
    this.tagAdded$ = new Observable();
    this.tagRemoved$ = new Observable();
    this.components = /* @__PURE__ */ new Map();
    this.componentValues = [];
    this._componentsToRemove = [];
    this.scene = null;
    this.isActive = true;
    this._parent = null;
    this.childrenAdded$ = new Observable();
    this.childrenRemoved$ = new Observable();
    this._children = [];
    this._isInitialized = false;
    this._isAdded = false;
    let componentsToAdd;
    let nameToAdd;
    if (Array.isArray(componentsOrOptions)) {
      componentsToAdd = componentsOrOptions;
      nameToAdd = name;
    } else if (componentsOrOptions && typeof componentsOrOptions === "object") {
      const { components, name: name2 } = componentsOrOptions;
      componentsToAdd = components != null ? components : [];
      nameToAdd = name2;
    }
    if (nameToAdd) {
      this.name = nameToAdd;
    }
    if (componentsToAdd) {
      for (const component of componentsToAdd) {
        this.addComponent(component);
      }
    }
  }
  /**
   * Whether this entity is active, if set to false it will be reclaimed
   * @deprecated use isActive
   */
  get active() {
    return this.isActive;
  }
  /**
   * Whether this entity is active, if set to false it will be reclaimed
   * @deprecated use isActive
   */
  set active(val) {
    this.isActive = val;
  }
  /**
   * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.
   * If parented it will be removed from the parent when killed.
   */
  kill() {
    if (this.isActive) {
      this.isActive = false;
      this.unparent();
    }
    this.emit("kill", new KillEvent(this));
  }
  isKilled() {
    return !this.isActive;
  }
  /**
   * Specifically get the tags on the entity from {@apilink TagsComponent}
   */
  get tags() {
    return this._tags;
  }
  /**
   * Check if a tag exists on the entity
   * @param tag name to check for
   */
  hasTag(tag) {
    return this._tags.has(tag);
  }
  /**
   * Adds a tag to an entity
   * @param tag
   */
  addTag(tag) {
    this._tags.add(tag);
    this.tagAdded$.notifyAll(tag);
    return this;
  }
  /**
   * Removes a tag on the entity
   *
   * Removals are deferred until the end of update
   * @param tag
   */
  removeTag(tag) {
    this._tags.delete(tag);
    this.tagRemoved$.notifyAll(tag);
    return this;
  }
  /**
   * The types of the components on the Entity
   */
  get types() {
    return Array.from(this.components.keys());
  }
  /**
   * Returns all component instances on entity
   */
  getComponents() {
    return Array.from(this.components.values());
  }
  /**
   * Verifies that an entity has all the required types
   * @param requiredTypes
   */
  hasAll(requiredTypes) {
    for (let i = 0; i < requiredTypes.length; i++) {
      if (!this.components.has(requiredTypes[i])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Verifies that an entity has all the required tags
   * @param requiredTags
   */
  hasAllTags(requiredTags) {
    for (let i = 0; i < requiredTags.length; i++) {
      if (!this.tags.has(requiredTags[i])) {
        return false;
      }
    }
    return true;
  }
  get(type) {
    return this.components.get(type);
  }
  get parent() {
    return this._parent;
  }
  /**
   * Get the direct children of this entity
   */
  get children() {
    return this._children;
  }
  /**
   * Unparents this entity, if there is a parent. Otherwise it does nothing.
   */
  unparent() {
    if (this._parent) {
      this._parent.removeChild(this);
      this._parent = null;
    }
  }
  /**
   * Adds an entity to be a child of this entity
   * @param entity
   */
  addChild(entity) {
    if (entity.parent === null) {
      if (this.getAncestors().includes(entity)) {
        throw new Error("Cycle detected, cannot add entity");
      }
      this._children.push(entity);
      entity._parent = this;
      this.childrenAdded$.notifyAll(entity);
    } else {
      throw new Error("Entity already has a parent, cannot add without unparenting");
    }
    return this;
  }
  /**
   * Remove an entity from children if it exists
   * @param entity
   */
  removeChild(entity) {
    if (entity.parent === this) {
      removeItemFromArray(entity, this._children);
      entity._parent = null;
      this.childrenRemoved$.notifyAll(entity);
    }
    return this;
  }
  /**
   * Removes all children from this entity
   */
  removeAllChildren() {
    for (let i = this.children.length - 1; i >= 0; i--) {
      this.removeChild(this.children[i]);
    }
    return this;
  }
  /**
   * Returns a list of parent entities starting with the topmost parent. Includes the current entity.
   */
  getAncestors() {
    const result = [this];
    let current = this.parent;
    while (current) {
      result.push(current);
      current = current.parent;
    }
    return result.reverse();
  }
  /**
   * Returns a list of all the entities that descend from this entity. Includes the current entity.
   */
  getDescendants() {
    let result = [this];
    let queue = [this];
    while (queue.length > 0) {
      const curr = queue.pop();
      if (curr) {
        queue = queue.concat(curr.children);
        result = result.concat(curr.children);
      }
    }
    return result;
  }
  /**
   * Creates a deep copy of the entity and a copy of all its components
   */
  clone() {
    const newEntity = new _Entity2();
    for (const c of this.types) {
      const componentInstance = this.get(c);
      if (componentInstance) {
        newEntity.addComponent(componentInstance.clone());
      }
    }
    for (const child of this.children) {
      newEntity.addChild(child.clone());
    }
    return newEntity;
  }
  /**
   * Adds a copy of all the components from another template entity as a "prefab"
   * @param templateEntity Entity to use as a template
   * @param force Force component replacement if it already exists on the target entity
   */
  addTemplate(templateEntity, force = false) {
    for (const c of templateEntity.getComponents()) {
      this.addComponent(c.clone(), force);
    }
    for (const child of templateEntity.children) {
      this.addChild(child.clone().addTemplate(child));
    }
    return this;
  }
  _getClassHierarchyRoot(componentType) {
    var _a, _b;
    let current = componentType;
    let parent = (_a = Object.getPrototypeOf(current.prototype)) == null ? void 0 : _a.constructor;
    while (parent && parent !== Object && parent !== Component) {
      current = parent;
      parent = (_b = Object.getPrototypeOf(current.prototype)) == null ? void 0 : _b.constructor;
    }
    return current;
  }
  /**
   * Adds a component to the entity
   * @param component Component or Entity to add copy of components from
   * @param force Optionally overwrite any existing components of the same type
   */
  addComponent(component, force = false) {
    if (this.has(component.constructor)) {
      if (force) {
        this.removeComponent(component.constructor, true);
      } else {
        return this;
      }
    }
    if (component.dependencies && component.dependencies.length) {
      for (const ctor of component.dependencies) {
        this.addComponent(new ctor());
      }
    }
    component.owner = this;
    const rootComponent = this._getClassHierarchyRoot(component.constructor);
    this.components.set(rootComponent, component);
    this.components.set(component.constructor, component);
    this.componentValues.push(component);
    if (component.onAdd) {
      component.onAdd(this);
    }
    this.componentAdded$.notifyAll(component);
    return this;
  }
  /**
   * Removes a component from the entity, by default removals are deferred to the end of entity update to avoid consistency issues
   *
   * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately
   * @param typeOrInstance
   * @param force
   */
  removeComponent(typeOrInstance, force = false) {
    let type;
    if (isComponentCtor(typeOrInstance)) {
      type = typeOrInstance;
    } else {
      type = typeOrInstance.constructor;
    }
    if (force) {
      const componentToRemove = this.components.get(type);
      if (componentToRemove) {
        this.componentRemoved$.notifyAll(componentToRemove);
        componentToRemove.owner = void 0;
        if (componentToRemove.onRemove) {
          componentToRemove.onRemove(this);
        }
        const componentIndex = this.componentValues.indexOf(componentToRemove);
        if (componentIndex > -1) {
          this.componentValues.splice(componentIndex, 1);
        }
      }
      const rootComponent = this._getClassHierarchyRoot(type);
      this.components.delete(rootComponent);
      this.components.delete(type);
    } else {
      this._componentsToRemove.push(type);
    }
    return this;
  }
  clearComponents() {
    const components = this.types;
    for (const c of components) {
      this.removeComponent(c);
    }
  }
  /**
   * @hidden
   * @internal
   */
  processComponentRemoval() {
    for (const type of this._componentsToRemove) {
      this.removeComponent(type, true);
    }
    this._componentsToRemove.length = 0;
  }
  /**
   * Check if a component type exists
   * @param type
   */
  has(type) {
    return this.components.has(type);
  }
  /**
   * Gets whether the actor is Initialized
   */
  get isInitialized() {
    return this._isInitialized;
  }
  get isAdded() {
    return this._isAdded;
  }
  /**
   * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.
   *
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   * @internal
   */
  _initialize(engine) {
    if (!this.isInitialized) {
      this.onInitialize(engine);
      this.events.emit("initialize", new InitializeEvent(engine, this));
      this._isInitialized = true;
    }
  }
  /**
   * Adds this Actor, meant to be called by the Scene when Actor is added.
   *
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   * @internal
   */
  _add(engine) {
    if (!this.isAdded && this.isActive) {
      this.onAdd(engine);
      this.events.emit("add", new AddEvent(engine, this));
      this._isAdded = true;
    }
  }
  /**
   * Removes Actor, meant to be called by the Scene when Actor is added.
   *
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   * @internal
   */
  _remove(engine) {
    if (this.isAdded && !this.isActive) {
      this.onRemove(engine);
      this.events.emit("remove", new RemoveEvent(engine, this));
      this._isAdded = false;
    }
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPreUpdate} lifecycle event
   * @internal
   */
  _preupdate(engine, elapsed) {
    this.events.emit("preupdate", new PreUpdateEvent(engine, elapsed, this));
    this.onPreUpdate(engine, elapsed);
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPostUpdate} lifecycle event
   * @internal
   */
  _postupdate(engine, elapsed) {
    this.events.emit("postupdate", new PostUpdateEvent(engine, elapsed, this));
    this.onPostUpdate(engine, elapsed);
  }
  /**
   * `onInitialize` is called before the first update of the entity. This method is meant to be
   * overridden.
   *
   * Synonymous with the event handler `.on('initialize', (evt) => {...})`
   */
  onInitialize(engine) {
  }
  /**
   * `onAdd` is called when Actor is added to scene. This method is meant to be
   * overridden.
   *
   * Synonymous with the event handler `.on('add', (evt) => {...})`
   */
  onAdd(engine) {
  }
  /**
   * `onRemove` is called when Actor is added to scene. This method is meant to be
   * overridden.
   *
   * Synonymous with the event handler `.on('remove', (evt) => {...})`
   */
  onRemove(engine) {
  }
  /**
   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPreUpdate` is called directly before an entity is updated.
   */
  onPreUpdate(engine, elapsed) {
  }
  /**
   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
   *
   * `onPostUpdate` is called directly after an entity is updated.
   */
  onPostUpdate(engine, elapsed) {
  }
  /**
   *
   * Entity update lifecycle, called internally
   * @internal
   * @param engine
   * @param elapsed
   */
  update(engine, elapsed) {
    this._initialize(engine);
    this._add(engine);
    this._preupdate(engine, elapsed);
    for (const child of this.children) {
      child.update(engine, elapsed);
    }
    this._postupdate(engine, elapsed);
    this._remove(engine);
  }
  emit(eventName, event) {
    this.events.emit(eventName, event);
  }
  on(eventName, handler) {
    return this.events.on(eventName, handler);
  }
  once(eventName, handler) {
    return this.events.once(eventName, handler);
  }
  off(eventName, handler) {
    if (handler) {
      this.events.off(eventName, handler);
    } else {
      this.events.off(eventName);
    }
  }
};
_Entity._ID = 0;
let Entity = _Entity;
class EntityManager {
  constructor(_world) {
    this._world = _world;
    this.entities = [];
    this._entityIndex = {};
    this._childAddedHandlerMap = /* @__PURE__ */ new Map();
    this._childRemovedHandlerMap = /* @__PURE__ */ new Map();
    this._createChildAddedHandler = () => (e) => {
      this.addEntity(e);
    };
    this._createChildRemovedHandler = () => (e) => {
      this.removeEntity(e, false);
    };
    this._entitiesToRemove = [];
  }
  /**
   * Runs the entity lifecycle
   * @param scene
   * @param elapsed
   */
  updateEntities(scene, elapsed) {
    for (let entityIndex = 0; entityIndex < this.entities.length; entityIndex++) {
      const entity = this.entities[entityIndex];
      entity.update(scene.engine, elapsed);
      if (!entity.isActive) {
        this.removeEntity(entity);
      }
    }
  }
  findEntitiesForRemoval() {
    for (let entityIndex = 0; entityIndex < this.entities.length; entityIndex++) {
      const entity = this.entities[entityIndex];
      if (!entity.isActive) {
        this.removeEntity(entity);
      }
    }
  }
  /**
   * Adds an entity to be tracked by the EntityManager
   * @param entity
   */
  addEntity(entity) {
    entity.isActive = true;
    entity.scene = this._world.scene;
    if (entity && !this._entityIndex[entity.id]) {
      this._entityIndex[entity.id] = entity;
      this.entities.push(entity);
      this._world.queryManager.addEntity(entity);
      entity.children.forEach((c) => {
        c.scene = entity.scene;
        this.addEntity(c);
      });
      const childAdded = this._createChildAddedHandler();
      this._childAddedHandlerMap.set(entity, childAdded);
      const childRemoved = this._createChildRemovedHandler();
      this._childRemovedHandlerMap.set(entity, childRemoved);
      entity.childrenAdded$.subscribe(childAdded);
      entity.childrenRemoved$.subscribe(childRemoved);
    }
  }
  removeEntity(idOrEntity, deferred = true) {
    var _a, _b;
    let id = 0;
    if (idOrEntity instanceof Entity) {
      id = idOrEntity.id;
    } else {
      id = idOrEntity;
    }
    const entity = this._entityIndex[id];
    if (entity && entity.isActive) {
      entity.isActive = false;
    }
    if (entity && deferred) {
      this._entitiesToRemove.push(entity);
      return;
    }
    delete this._entityIndex[id];
    if (entity) {
      entity.scene = null;
      removeItemFromArray(entity, this.entities);
      this._world.queryManager.removeEntity(entity);
      entity.children.forEach((c) => {
        c.scene = null;
        this.removeEntity(c, deferred);
      });
      const childAddedHandler = this._childAddedHandlerMap.get(entity);
      if (childAddedHandler) {
        entity.childrenAdded$.unsubscribe(childAddedHandler);
        this._childAddedHandlerMap.delete(entity);
      }
      const childRemovedHandler = this._childRemovedHandlerMap.get(entity);
      if (childRemovedHandler) {
        entity.childrenRemoved$.unsubscribe(childRemovedHandler);
        this._childRemovedHandlerMap.delete(entity);
      }
      if ((_b = (_a = this._world) == null ? void 0 : _a.scene) == null ? void 0 : _b.engine) {
        this._world.scene.engine.stats.currFrame.actors.killed++;
      }
    }
  }
  processEntityRemovals() {
    for (let entityIndex = 0; entityIndex < this._entitiesToRemove.length; entityIndex++) {
      const entity = this._entitiesToRemove[entityIndex];
      if (entity.isActive) {
        continue;
      }
      this.removeEntity(entity, false);
    }
    this._entitiesToRemove.length = 0;
  }
  processComponentRemovals() {
    for (let entityIndex = 0; entityIndex < this.entities.length; entityIndex++) {
      const entity = this.entities[entityIndex];
      entity.processComponentRemoval();
    }
  }
  getById(id) {
    return this._entityIndex[id];
  }
  getByName(name) {
    return this.entities.filter((e) => e.name === name);
  }
  clear() {
    for (let i = this.entities.length - 1; i >= 0; i--) {
      this.removeEntity(this.entities[i]);
    }
  }
}
class Query {
  constructor(params) {
    this.entities = [];
    this.entityAdded$ = new Observable();
    this.entityRemoved$ = new Observable();
    this.filter = {
      components: {
        all: /* @__PURE__ */ new Set(),
        any: /* @__PURE__ */ new Set(),
        not: /* @__PURE__ */ new Set()
      },
      tags: {
        all: /* @__PURE__ */ new Set(),
        any: /* @__PURE__ */ new Set(),
        not: /* @__PURE__ */ new Set()
      }
    };
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    if (Array.isArray(params)) {
      params = { components: { all: params } };
    }
    this.filter.components.all = new Set((_b = (_a = params.components) == null ? void 0 : _a.all) != null ? _b : []);
    this.filter.components.any = new Set((_d = (_c = params.components) == null ? void 0 : _c.any) != null ? _d : []);
    this.filter.components.not = new Set((_f = (_e = params.components) == null ? void 0 : _e.not) != null ? _f : []);
    this.filter.tags.all = new Set((_h = (_g = params.tags) == null ? void 0 : _g.all) != null ? _h : []);
    this.filter.tags.any = new Set((_j = (_i = params.tags) == null ? void 0 : _i.any) != null ? _j : []);
    this.filter.tags.not = new Set((_l = (_k = params.tags) == null ? void 0 : _k.not) != null ? _l : []);
    this.id = Query.createId(params);
  }
  static createId(params) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    if (Array.isArray(params)) {
      params = { components: { all: params } };
    }
    const anyComponents = ((_a = params.components) == null ? void 0 : _a.any) ? `any_${Query.hashComponents(new Set((_b = params.components) == null ? void 0 : _b.any))}` : "";
    const allComponents = ((_c = params.components) == null ? void 0 : _c.all) ? `all_${Query.hashComponents(new Set((_d = params.components) == null ? void 0 : _d.all))}` : "";
    const notComponents = ((_e = params.components) == null ? void 0 : _e.not) ? `not_${Query.hashComponents(new Set((_f = params.components) == null ? void 0 : _f.not))}` : "";
    const anyTags = ((_g = params.tags) == null ? void 0 : _g.any) ? `any_${Query.hashTags(new Set((_h = params.tags) == null ? void 0 : _h.any))}` : "";
    const allTags = ((_i = params.tags) == null ? void 0 : _i.all) ? `all_${Query.hashTags(new Set((_j = params.tags) == null ? void 0 : _j.all))}` : "";
    const notTags = ((_k = params.tags) == null ? void 0 : _k.not) ? `not_${Query.hashTags(new Set((_l = params.tags) == null ? void 0 : _l.not))}` : "";
    return [anyComponents, allComponents, notComponents, anyTags, allTags, notTags].filter(Boolean).join("-");
  }
  static hashTags(set) {
    return Array.from(set).map((t) => `t_${t}`).sort().join("-");
  }
  static hashComponents(set) {
    return Array.from(set).map((c) => `c_${c.name}`).sort().join("-");
  }
  matches(entity) {
    for (const component of this.filter.components.all) {
      if (!entity.has(component)) {
        return false;
      }
    }
    if (this.filter.components.any.size > 0) {
      let found = false;
      for (const component of this.filter.components.any) {
        if (entity.has(component)) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    for (const component of this.filter.components.not) {
      if (entity.has(component)) {
        return false;
      }
    }
    for (const tag of this.filter.tags.all) {
      if (!entity.hasTag(tag)) {
        return false;
      }
    }
    if (this.filter.tags.any.size > 0) {
      let found = false;
      for (const tag of this.filter.tags.any) {
        if (entity.hasTag(tag)) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    for (const tag of this.filter.tags.not) {
      if (entity.hasTag(tag)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Potentially adds an entity to a query index, returns true if added, false if not
   * @param entity
   */
  checkAndAdd(entity) {
    if (this.matches(entity) && !this.entities.includes(entity)) {
      this.entities.push(entity);
      this.entityAdded$.notifyAll(entity);
      return true;
    }
    return false;
  }
  removeEntity(entity) {
    const index = this.entities.indexOf(entity);
    if (index > -1) {
      this.entities.splice(index, 1);
      this.entityRemoved$.notifyAll(entity);
    }
  }
  /**
   * Returns a list of entities that match the query
   * @param sort Optional sorting function to sort entities returned from the query
   */
  getEntities(sort) {
    if (sort) {
      this.entities.sort(sort);
    }
    return this.entities;
  }
}
class TagQuery {
  constructor(requiredTags) {
    this.requiredTags = requiredTags;
    this.tags = /* @__PURE__ */ new Set();
    this.entities = [];
    this.entityAdded$ = new Observable();
    this.entityRemoved$ = new Observable();
    if (requiredTags.length === 0) {
      throw new Error("Cannot create tag query without tags");
    }
    for (const tag of requiredTags) {
      this.tags.add(tag);
    }
    this.id = TagQuery.createId(requiredTags);
  }
  static createId(requiredComponents) {
    return requiredComponents.slice().sort().join("-");
  }
  checkAndAdd(entity) {
    if (!this.entities.includes(entity) && entity.hasAllTags(Array.from(this.tags))) {
      this.entities.push(entity);
      this.entityAdded$.notifyAll(entity);
      return true;
    }
    return false;
  }
  removeEntity(entity) {
    const index = this.entities.indexOf(entity);
    if (index > -1) {
      this.entities.splice(index, 1);
      this.entityRemoved$.notifyAll(entity);
    }
  }
  /**
   * Returns a list of entities that match the query
   * @param sort Optional sorting function to sort entities returned from the query
   */
  getEntities(sort) {
    if (sort) {
      this.entities.sort(sort);
    }
    return this.entities;
  }
}
class QueryManager {
  constructor(_world) {
    this._world = _world;
    this._queries = /* @__PURE__ */ new Map();
    this._addComponentHandlers = /* @__PURE__ */ new Map();
    this._removeComponentHandlers = /* @__PURE__ */ new Map();
    this._componentToQueriesIndex = /* @__PURE__ */ new Map();
    this._tagQueries = /* @__PURE__ */ new Map();
    this._addTagHandlers = /* @__PURE__ */ new Map();
    this._removeTagHandlers = /* @__PURE__ */ new Map();
    this._tagToQueriesIndex = /* @__PURE__ */ new Map();
    this._createAddComponentHandler = (entity) => (c) => {
      this.addComponent(entity, c);
    };
    this._createRemoveComponentHandler = (entity) => (c) => {
      this.removeComponent(entity, c);
    };
    this._createAddTagHandler = (entity) => (tag) => {
      this.addTag(entity, tag);
    };
    this._createRemoveTagHandler = (entity) => (tag) => {
      this.removeTag(entity, tag);
    };
  }
  createQuery(params) {
    const id = Query.createId(params);
    if (this._queries.has(id)) {
      return this._queries.get(id);
    }
    const query = new Query(params);
    this._queries.set(query.id, query);
    for (const component of [...query.filter.components.all, ...query.filter.components.any, ...query.filter.components.not]) {
      const queries = this._componentToQueriesIndex.get(component);
      if (!queries) {
        this._componentToQueriesIndex.set(component, [query]);
      } else {
        queries.push(query);
      }
    }
    for (const entity of this._world.entities) {
      this.addEntity(entity);
    }
    return query;
  }
  createTagQuery(requiredTags) {
    const id = TagQuery.createId(requiredTags);
    if (this._tagQueries.has(id)) {
      return this._tagQueries.get(id);
    }
    const query = new TagQuery(requiredTags);
    this._tagQueries.set(query.id, query);
    for (const tag of requiredTags) {
      const queries = this._tagToQueriesIndex.get(tag);
      if (!queries) {
        this._tagToQueriesIndex.set(tag, [query]);
      } else {
        queries.push(query);
      }
    }
    for (const entity of this._world.entities) {
      this.addEntity(entity);
    }
    return query;
  }
  /**
   * Scans queries and locates any that need this entity added
   * @param entity
   */
  addEntity(entity) {
    const maybeAddComponent = this._addComponentHandlers.get(entity);
    const maybeRemoveComponent = this._removeComponentHandlers.get(entity);
    const addComponent = maybeAddComponent != null ? maybeAddComponent : this._createAddComponentHandler(entity);
    const removeComponent = maybeRemoveComponent != null ? maybeRemoveComponent : this._createRemoveComponentHandler(entity);
    this._addComponentHandlers.set(entity, addComponent);
    this._removeComponentHandlers.set(entity, removeComponent);
    const maybeAddTag = this._addTagHandlers.get(entity);
    const maybeRemoveTag = this._removeTagHandlers.get(entity);
    const addTag = maybeAddTag != null ? maybeAddTag : this._createAddTagHandler(entity);
    const removeTag = maybeRemoveTag != null ? maybeRemoveTag : this._createRemoveTagHandler(entity);
    this._addTagHandlers.set(entity, addTag);
    this._removeTagHandlers.set(entity, removeTag);
    for (const query of this._queries.values()) {
      query.checkAndAdd(entity);
    }
    for (const tagQuery of this._tagQueries.values()) {
      tagQuery.checkAndAdd(entity);
    }
    entity.componentAdded$.subscribe(addComponent);
    entity.componentRemoved$.subscribe(removeComponent);
    entity.tagAdded$.subscribe(addTag);
    entity.tagRemoved$.subscribe(removeTag);
  }
  /**
   * Scans queries and locates any that need this entity removed
   * @param entity
   */
  removeEntity(entity) {
    const addComponent = this._addComponentHandlers.get(entity);
    const removeComponent = this._removeComponentHandlers.get(entity);
    for (const query of this._queries.values()) {
      query.removeEntity(entity);
    }
    if (addComponent) {
      entity.componentAdded$.unsubscribe(addComponent);
      this._addComponentHandlers.delete(entity);
    }
    if (removeComponent) {
      entity.componentRemoved$.unsubscribe(removeComponent);
      this._removeComponentHandlers.delete(entity);
    }
    const addTag = this._addTagHandlers.get(entity);
    const removeTag = this._removeTagHandlers.get(entity);
    for (const tagQuery of this._tagQueries.values()) {
      tagQuery.removeEntity(entity);
    }
    if (addTag) {
      entity.tagAdded$.unsubscribe(addTag);
      this._addTagHandlers.delete(entity);
    }
    if (removeTag) {
      entity.tagRemoved$.unsubscribe(removeTag);
      this._removeTagHandlers.delete(entity);
    }
  }
  /**
   * Updates any queries when a component is added to an entity
   * @param entity
   * @param component
   */
  addComponent(entity, component) {
    var _a;
    const queries = (_a = this._componentToQueriesIndex.get(component.constructor)) != null ? _a : [];
    for (const query of queries) {
      query.checkAndAdd(entity);
    }
  }
  /**
   * Updates any queries when a component is removed from an entity
   * @param entity
   * @param component
   */
  removeComponent(entity, component) {
    var _a;
    const queries = (_a = this._componentToQueriesIndex.get(component.constructor)) != null ? _a : [];
    for (const query of queries) {
      query.removeEntity(entity);
    }
  }
  /**
   * Updates any queries when a tag is added to an entity
   * @param entity
   * @param tag
   */
  addTag(entity, tag) {
    var _a;
    const queries = (_a = this._tagToQueriesIndex.get(tag)) != null ? _a : [];
    for (const query of queries) {
      query.checkAndAdd(entity);
    }
  }
  /**
   * Updates any queries when a component is removed from an entity
   * @param entity
   * @param tag
   */
  removeTag(entity, tag) {
    var _a;
    const queries = (_a = this._tagToQueriesIndex.get(tag)) != null ? _a : [];
    for (const query of queries) {
      query.removeEntity(entity);
    }
  }
}
const SystemPriority = {
  Highest: -Infinity,
  Higher: -5,
  Average: 0,
  Lower: 5,
  Lowest: Infinity
};
var SystemType = /* @__PURE__ */ ((SystemType2) => {
  SystemType2["Update"] = "update";
  SystemType2["Draw"] = "draw";
  return SystemType2;
})(SystemType || {});
class System {
}
System.priority = SystemPriority.Average;
function isSystemConstructor(x) {
  var _a, _b;
  return !!(x == null ? void 0 : x.prototype) && !!((_b = (_a = x == null ? void 0 : x.prototype) == null ? void 0 : _a.constructor) == null ? void 0 : _b.name);
}
class SystemManager {
  constructor(_world) {
    this._world = _world;
    this.systems = [];
    this.initialized = false;
  }
  /**
   * Get a system registered in the manager by type
   * @param systemType
   */
  get(systemType) {
    return this.systems.find((s) => s instanceof systemType);
  }
  /**
   * Adds a system to the manager, it will now be updated every frame
   * @param systemOrCtor
   */
  addSystem(systemOrCtor) {
    let system;
    if (systemOrCtor instanceof System) {
      system = systemOrCtor;
    } else {
      system = new systemOrCtor(this._world);
    }
    this.systems.push(system);
    this.systems.sort((a, b) => a.constructor.priority - b.constructor.priority);
    if (this.initialized && system.initialize) {
      system.initialize(this._world, this._world.scene);
    }
  }
  /**
   * Removes a system from the manager, it will no longer be updated
   * @param system
   */
  removeSystem(system) {
    removeItemFromArray(system, this.systems);
  }
  /**
   * Initialize all systems in the manager
   *
   * Systems added after initialize() will be initialized on add
   */
  initialize() {
    if (!this.initialized) {
      this.initialized = true;
      for (const s of this.systems) {
        if (s.initialize) {
          s.initialize(this._world, this._world.scene);
        }
      }
    }
  }
  /**
   * Updates all systems
   * @param type whether this is an update or draw system
   * @param scene context reference
   * @param elapsed time in milliseconds
   */
  updateSystems(type, scene, elapsed) {
    const systems = this.systems.filter((s) => s.systemType === type);
    for (const s of systems) {
      if (s.preupdate) {
        s.preupdate(scene, elapsed);
      }
    }
    for (const s of systems) {
      s.update(elapsed);
    }
    for (const s of systems) {
      if (s.postupdate) {
        s.postupdate(scene, elapsed);
      }
    }
  }
  clear() {
    for (let i = this.systems.length - 1; i >= 0; i--) {
      this.removeSystem(this.systems[i]);
    }
  }
}
class World {
  /**
   * The context type is passed to the system updates
   * @param scene
   */
  constructor(scene) {
    this.scene = scene;
    this._logger = Logger.getInstance();
    this.queryManager = new QueryManager(this);
    this.entityManager = new EntityManager(this);
    this.systemManager = new SystemManager(this);
  }
  /**
   * Query the ECS world for entities that match your components
   */
  query(params) {
    return this.queryManager.createQuery(params);
  }
  queryTags(requiredTags) {
    return this.queryManager.createTagQuery(requiredTags);
  }
  /**
   * Update systems by type and time elapsed in milliseconds
   */
  update(type, elapsed) {
    if (type === SystemType.Update) {
      this.entityManager.updateEntities(this.scene, elapsed);
    }
    this.systemManager.updateSystems(type, this.scene, elapsed);
    this.entityManager.findEntitiesForRemoval();
    this.entityManager.processComponentRemovals();
    this.entityManager.processEntityRemovals();
  }
  add(entityOrSystem) {
    if (entityOrSystem instanceof Entity) {
      this.entityManager.addEntity(entityOrSystem);
      return;
    }
    if (entityOrSystem instanceof System || isSystemConstructor(entityOrSystem)) {
      this.systemManager.addSystem(entityOrSystem);
      return;
    }
    this._logger.warn(
      `Could not add entity/system ${entityOrSystem.constructor.name} to Excalibur!

If this looks like an Excalibur type, this can be caused by 2 versions of excalibur being included on the page.

Check your bundler settings to make sure this is not the case! Excalibur has ESM & UMD bundles be sure one 1 is loaded.`
    );
  }
  /**
   * Get a system out of the ECS world
   */
  get(system) {
    return this.systemManager.get(system);
  }
  remove(entityOrSystem, deferred = true) {
    if (entityOrSystem instanceof Entity) {
      this.entityManager.removeEntity(entityOrSystem, deferred);
      return;
    }
    if (entityOrSystem instanceof System) {
      this.systemManager.removeSystem(entityOrSystem);
      return;
    }
    this._logger.warn(
      `Could not remove entity/system ${entityOrSystem.constructor.name} to Excalibur!

If this looks like an Excalibur type, this can be caused by 2 versions of excalibur being included on the page.

Check your bundler settings to make sure this is not the case! Excalibur has ESM & UMD bundles be sure one 1 is loaded.`
    );
  }
  get entities() {
    return this.entityManager.entities;
  }
  clearEntities() {
    this.entityManager.clear();
  }
  clearSystems() {
    this.systemManager.clear();
  }
}
var Side = /* @__PURE__ */ ((Side2) => {
  Side2["None"] = "None";
  Side2["Top"] = "Top";
  Side2["Bottom"] = "Bottom";
  Side2["Left"] = "Left";
  Side2["Right"] = "Right";
  return Side2;
})(Side || {});
((Side2) => {
  function getOpposite(side) {
    if (side === "Top") {
      return "Bottom";
    }
    if (side === "Bottom") {
      return "Top";
    }
    if (side === "Left") {
      return "Right";
    }
    if (side === "Right") {
      return "Left";
    }
    return "None";
  }
  Side2.getOpposite = getOpposite;
  function fromDirection(direction) {
    if (Math.abs(direction.x) >= Math.abs(direction.y)) {
      if (direction.x <= 0) {
        return "Left";
      }
      return "Right";
    }
    if (direction.y <= 0) {
      return "Top";
    }
    return "Bottom";
  }
  Side2.fromDirection = fromDirection;
})(Side || (Side = {}));
const _BoundingBox = class _BoundingBox2 {
  /**
   * Constructor allows passing of either an object with all coordinate components,
   * or the coordinate components passed separately.
   * @param leftOrOptions    Either x coordinate of the left edge or an options object
   * containing the four coordinate components.
   * @param top     y coordinate of the top edge
   * @param right   x coordinate of the right edge
   * @param bottom  y coordinate of the bottom edge
   */
  constructor(leftOrOptions = 0, top = 0, right = 0, bottom = 0) {
    this._points = [];
    if (typeof leftOrOptions === "object") {
      this.left = leftOrOptions.left;
      this.top = leftOrOptions.top;
      this.right = leftOrOptions.right;
      this.bottom = leftOrOptions.bottom;
    } else if (typeof leftOrOptions === "number") {
      this.left = leftOrOptions;
      this.top = top;
      this.right = right;
      this.bottom = bottom;
    }
  }
  /**
   * Returns a new instance of {@apilink BoundingBox} that is a copy of the current instance
   */
  clone(dest) {
    const result = dest || new _BoundingBox2(0, 0, 0, 0);
    result.left = this.left;
    result.right = this.right;
    result.top = this.top;
    result.bottom = this.bottom;
    return result;
  }
  /**
   * Resets the bounds to a zero width/height box
   */
  reset() {
    this.left = 0;
    this.top = 0;
    this.bottom = 0;
    this.right = 0;
  }
  /**
   * Given bounding box A & B, returns the side relative to A when intersection is performed.
   * @param intersection Intersection vector between 2 bounding boxes
   */
  static getSideFromIntersection(intersection) {
    if (!intersection) {
      return Side.None;
    }
    if (intersection) {
      if (Math.abs(intersection.x) > Math.abs(intersection.y)) {
        if (intersection.x < 0) {
          return Side.Right;
        }
        return Side.Left;
      } else {
        if (intersection.y < 0) {
          return Side.Bottom;
        }
        return Side.Top;
      }
    }
    return Side.None;
  }
  static fromPoints(points) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i = 0; i < points.length; i++) {
      if (points[i].x < minX) {
        minX = points[i].x;
      }
      if (points[i].x > maxX) {
        maxX = points[i].x;
      }
      if (points[i].y < minY) {
        minY = points[i].y;
      }
      if (points[i].y > maxY) {
        maxY = points[i].y;
      }
    }
    return new _BoundingBox2(minX, minY, maxX, maxY);
  }
  /**
   * Creates a bounding box from a width and height
   * @param width
   * @param height
   * @param anchor Default Vector.Half
   * @param pos Default Vector.Zero
   */
  static fromDimension(width, height, anchor = Vector.Half, pos = Vector.Zero) {
    return new _BoundingBox2(
      -width * anchor.x + pos.x,
      -height * anchor.y + pos.y,
      width - width * anchor.x + pos.x,
      height - height * anchor.y + pos.y
    );
  }
  /**
   * Returns the calculated width of the bounding box
   */
  get width() {
    return this.right - this.left;
  }
  /**
   * Returns the calculated height of the bounding box
   */
  get height() {
    return this.bottom - this.top;
  }
  /**
   * Return whether the bounding box has zero dimensions in height,width or both
   */
  hasZeroDimensions() {
    return this.width === 0 || this.height === 0;
  }
  /**
   * Returns the center of the bounding box
   */
  get center() {
    return new Vector((this.left + this.right) / 2, (this.top + this.bottom) / 2);
  }
  get topLeft() {
    return new Vector(this.left, this.top);
  }
  get bottomRight() {
    return new Vector(this.right, this.bottom);
  }
  get topRight() {
    return new Vector(this.right, this.top);
  }
  get bottomLeft() {
    return new Vector(this.left, this.bottom);
  }
  translate(pos) {
    return new _BoundingBox2(this.left + pos.x, this.top + pos.y, this.right + pos.x, this.bottom + pos.y);
  }
  /**
   * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding
   * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.
   */
  rotate(angle, point2 = Vector.Zero) {
    const points = this.getPoints().map((p) => p.rotate(angle, point2));
    return _BoundingBox2.fromPoints(points);
  }
  /**
   * Scale a bounding box by a scale factor, optionally provide a point
   * @param scale
   * @param point
   */
  scale(scale, point2 = Vector.Zero) {
    const shifted = this.translate(point2);
    return new _BoundingBox2(shifted.left * scale.x, shifted.top * scale.y, shifted.right * scale.x, shifted.bottom * scale.y);
  }
  /**
   * Transform the axis aligned bounding box by a {@apilink Matrix}, producing a new axis aligned bounding box
   * @param matrix
   */
  transform(matrix) {
    const xa1 = matrix.data[0] * this.left;
    const xa2 = matrix.data[1] * this.left;
    const xb1 = matrix.data[0] * this.right;
    const xb2 = matrix.data[1] * this.right;
    const ya1 = matrix.data[2] * this.top;
    const ya2 = matrix.data[3] * this.top;
    const yb1 = matrix.data[2] * this.bottom;
    const yb2 = matrix.data[3] * this.bottom;
    const matrixPos = matrix.getPosition();
    const left = Math.min(xa1, xb1) + Math.min(ya1, yb1) + matrixPos.x;
    const top = Math.min(xa2, xb2) + Math.min(ya2, yb2) + matrixPos.y;
    const right = Math.max(xa1, xb1) + Math.max(ya1, yb1) + matrixPos.x;
    const bottom = Math.max(xa2, xb2) + Math.max(ya2, yb2) + matrixPos.y;
    return new _BoundingBox2({
      left,
      //: topLeft.x,
      top,
      //: topLeft.y,
      right,
      //: bottomRight.x,
      bottom
      //: bottomRight.y
    });
  }
  /**
   * Returns the perimeter of the bounding box
   */
  getPerimeter() {
    const wx = this.width;
    const wy = this.height;
    return 2 * (wx + wy);
  }
  /**
   * Returns the world space points that make up the corners of the bounding box as a polygon
   */
  getPoints() {
    if (this._left !== this.left || this._right !== this.right || this._top !== this.top || this._bottom !== this.bottom) {
      this._points.length = 0;
      this._points.push(new Vector(this.left, this.top));
      this._points.push(new Vector(this.right, this.top));
      this._points.push(new Vector(this.right, this.bottom));
      this._points.push(new Vector(this.left, this.bottom));
      this._left = this.left;
      this._right = this.right;
      this._top = this.top;
      this._bottom = this.bottom;
    }
    return this._points;
  }
  /**
   * Determines whether a ray intersects with a bounding box
   */
  rayCast(ray, farClipDistance = Infinity) {
    let tMinMax, tMaxMin;
    const xInv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
    const yInv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
    const tx1 = (this.left - ray.pos.x) * xInv;
    const tx2 = (this.right - ray.pos.x) * xInv;
    tMaxMin = Math.min(tx1, tx2);
    tMinMax = Math.max(tx1, tx2);
    const ty1 = (this.top - ray.pos.y) * yInv;
    const ty2 = (this.bottom - ray.pos.y) * yInv;
    tMaxMin = Math.max(tMaxMin, Math.min(ty1, ty2));
    tMinMax = Math.min(tMinMax, Math.max(ty1, ty2));
    return tMinMax >= 0 && tMinMax >= tMaxMin && tMaxMin < farClipDistance;
  }
  /**
   * Returns the time along the ray where a raycast hits
   */
  rayCastTime(ray, farClipDistance = Infinity) {
    let tMinMax, tMaxMin;
    const xInv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
    const yInv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
    const tx1 = (this.left - ray.pos.x) * xInv;
    const tx2 = (this.right - ray.pos.x) * xInv;
    tMaxMin = Math.min(tx1, tx2);
    tMinMax = Math.max(tx1, tx2);
    const ty1 = (this.top - ray.pos.y) * yInv;
    const ty2 = (this.bottom - ray.pos.y) * yInv;
    tMaxMin = Math.max(tMaxMin, Math.min(ty1, ty2));
    tMinMax = Math.min(tMinMax, Math.max(ty1, ty2));
    if (tMinMax >= 0 && tMinMax >= tMaxMin && tMaxMin < farClipDistance) {
      return tMaxMin;
    }
    return -1;
  }
  contains(val) {
    if (val instanceof Vector) {
      return this.left <= val.x && this.top <= val.y && val.y <= this.bottom && val.x <= this.right;
    } else if (val instanceof _BoundingBox2) {
      return this.left <= val.left && this.top <= val.top && val.bottom <= this.bottom && val.right <= this.right;
    }
    return false;
  }
  /**
   * Combines this bounding box and another together returning a new bounding box
   * @param other  The bounding box to combine
   */
  combine(other, dest) {
    const compositeBB = dest || new _BoundingBox2(0, 0, 0, 0);
    const left = Math.min(this.left, other.left);
    const top = Math.min(this.top, other.top);
    const right = Math.max(this.right, other.right);
    const bottom = Math.max(this.bottom, other.bottom);
    compositeBB.left = left;
    compositeBB.top = top;
    compositeBB.right = right;
    compositeBB.bottom = bottom;
    return compositeBB;
  }
  get dimensions() {
    return new Vector(this.width, this.height);
  }
  /**
   * Returns true if the bounding boxes overlap.
   * @param other
   * @param epsilon Optionally specify a small epsilon (default 0) as amount of overlap to ignore as overlap.
   * This epsilon is useful in stable collision simulations.
   */
  overlaps(other, epsilon) {
    const e = epsilon || 0;
    if (other.hasZeroDimensions()) {
      return this.contains(other);
    }
    if (this.hasZeroDimensions()) {
      return other.contains(this);
    }
    const totalBoundingBox = this.combine(other);
    return totalBoundingBox.width + e < other.width + this.width && totalBoundingBox.height + e < other.height + this.height;
  }
  /**
   * Test wether this bounding box intersects with another returning
   * the intersection vector that can be used to resolve the collision. If there
   * is no intersection null is returned.
   * @param other  Other {@apilink BoundingBox} to test intersection with
   * @returns A Vector in the direction of the current BoundingBox, this <- other
   */
  intersect(other) {
    if (this.bottom <= other.top || other.bottom <= this.top || this.right <= other.left || other.right <= this.left) {
      return null;
    }
    const topPath = this.bottom - other.top;
    _BoundingBox2._SCRATCH_INTERSECT[0] = topPath;
    const bottomPath = other.bottom - this.top;
    _BoundingBox2._SCRATCH_INTERSECT[1] = bottomPath;
    const leftPath = this.right - other.left;
    _BoundingBox2._SCRATCH_INTERSECT[2] = leftPath;
    const rightPath = other.right - this.left;
    _BoundingBox2._SCRATCH_INTERSECT[3] = rightPath;
    const minIndex = getMinIndex(_BoundingBox2._SCRATCH_INTERSECT);
    switch (minIndex) {
      case 0:
        return new Vector(0, -topPath);
      case 1:
        return new Vector(0, bottomPath);
      case 2:
        return new Vector(-leftPath, 0);
      case 3:
        return new Vector(rightPath, 0);
      default:
        const index = minIndex;
        throw new Error(`Unreachable index: [${index}] on bounding box intersection!`);
    }
  }
  /**
   * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.
   * @param bb The other actor to test
   */
  intersectWithSide(bb) {
    const intersect = this.intersect(bb);
    return _BoundingBox2.getSideFromIntersection(intersect);
  }
  /**
   * Draw a debug bounding box
   * @param ex
   * @param color
   */
  draw(ex, color = Color.Yellow) {
    ex.debug.drawRect(this.left, this.top, this.width, this.height, { color });
  }
};
_BoundingBox._SCRATCH_INTERSECT = [0, 0, 0, 0];
let BoundingBox = _BoundingBox;
class Pair {
  constructor(colliderA, colliderB) {
    this.colliderA = colliderA;
    this.colliderB = colliderB;
    this.id = null;
    this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
  }
  /**
   * Returns whether a it is allowed for 2 colliders in a Pair to collide
   * @param colliderA
   * @param colliderB
   */
  static canCollide(colliderA, colliderB) {
    var _a, _b;
    if (colliderA.id === colliderB.id) {
      return false;
    }
    if (colliderA.owner && colliderB.owner && colliderA.owner.id === colliderB.owner.id) {
      return false;
    }
    if (colliderA.localBounds.hasZeroDimensions() || colliderB.localBounds.hasZeroDimensions()) {
      return false;
    }
    const bodyA = (_a = colliderA == null ? void 0 : colliderA.owner) == null ? void 0 : _a.get(BodyComponent);
    const bodyB = (_b = colliderB == null ? void 0 : colliderB.owner) == null ? void 0 : _b.get(BodyComponent);
    if (!bodyA || !bodyB) {
      return false;
    }
    if (!bodyA.group.canCollide(bodyB.group)) {
      return false;
    }
    if (bodyA.collisionType === CollisionType.Fixed && bodyB.collisionType === CollisionType.Fixed) {
      return false;
    }
    if (bodyB.collisionType === CollisionType.PreventCollision || bodyA.collisionType === CollisionType.PreventCollision) {
      return false;
    }
    if (!bodyA.isActive || !bodyB.isActive) {
      return false;
    }
    return true;
  }
  /**
   * Returns whether or not it is possible for the pairs to collide
   */
  get canCollide() {
    const colliderA = this.colliderA;
    const colliderB = this.colliderB;
    return Pair.canCollide(colliderA, colliderB);
  }
  /**
   * Runs the collision intersection logic on the members of this pair
   */
  collide() {
    return this.colliderA.collide(this.colliderB);
  }
  /**
   * Check if the collider is part of the pair
   * @param collider
   */
  hasCollider(collider) {
    return collider === this.colliderA || collider === this.colliderB;
  }
  /**
   * Calculates the unique pair hash id for this collision pair (owning id)
   */
  static calculatePairHash(idA, idB) {
    if (idA.value < idB.value) {
      return `#${idA.value}+${idB.value}`;
    } else {
      return `#${idB.value}+${idA.value}`;
    }
  }
}
class Projection {
  constructor(min, max) {
    this.min = min;
    this.max = max;
  }
  overlaps(projection) {
    return this.max > projection.min && projection.max > this.min;
  }
  getOverlap(projection) {
    if (this.overlaps(projection)) {
      if (this.max > projection.max) {
        return projection.max - this.min;
      } else {
        return this.max - projection.min;
      }
    }
    return 0;
  }
}
class TreeNode {
  constructor(parent) {
    this.parent = parent;
    this.parent = parent || null;
    this.data = null;
    this.bounds = new BoundingBox();
    this.left = null;
    this.right = null;
    this.height = 0;
  }
  isLeaf() {
    return !this.left && !this.right;
  }
}
class DynamicTree {
  constructor(_config, worldBounds = new BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)) {
    this._config = _config;
    this.worldBounds = worldBounds;
    this.root = null;
    this.nodes = {};
  }
  /**
   * Inserts a node into the dynamic tree
   */
  _insert(leaf) {
    if (this.root === null) {
      this.root = leaf;
      this.root.parent = null;
      return;
    }
    const leafAABB = leaf.bounds;
    let currentRoot = this.root;
    while (!currentRoot.isLeaf()) {
      const left = currentRoot.left;
      const right = currentRoot.right;
      const area = currentRoot.bounds.getPerimeter();
      const combinedAABB = currentRoot.bounds.combine(leafAABB);
      const combinedArea = combinedAABB.getPerimeter();
      const cost = 2 * combinedArea;
      const inheritanceCost = 2 * (combinedArea - area);
      let leftCost = 0;
      const leftCombined = leafAABB.combine(left.bounds);
      let newArea;
      let oldArea;
      if (left.isLeaf()) {
        leftCost = leftCombined.getPerimeter() + inheritanceCost;
      } else {
        oldArea = left.bounds.getPerimeter();
        newArea = leftCombined.getPerimeter();
        leftCost = newArea - oldArea + inheritanceCost;
      }
      let rightCost = 0;
      const rightCombined = leafAABB.combine(right.bounds);
      if (right.isLeaf()) {
        rightCost = rightCombined.getPerimeter() + inheritanceCost;
      } else {
        oldArea = right.bounds.getPerimeter();
        newArea = rightCombined.getPerimeter();
        rightCost = newArea - oldArea + inheritanceCost;
      }
      if (cost < leftCost && cost < rightCost) {
        break;
      }
      if (leftCost < rightCost) {
        currentRoot = left;
      } else {
        currentRoot = right;
      }
    }
    const oldParent = currentRoot.parent;
    const newParent = new TreeNode(oldParent);
    newParent.bounds = leafAABB.combine(currentRoot.bounds);
    newParent.height = currentRoot.height + 1;
    if (oldParent !== null) {
      if (oldParent.left === currentRoot) {
        oldParent.left = newParent;
      } else {
        oldParent.right = newParent;
      }
      newParent.left = currentRoot;
      newParent.right = leaf;
      currentRoot.parent = newParent;
      leaf.parent = newParent;
    } else {
      newParent.left = currentRoot;
      newParent.right = leaf;
      currentRoot.parent = newParent;
      leaf.parent = newParent;
      this.root = newParent;
    }
    let currentNode = leaf.parent;
    while (currentNode) {
      currentNode = this._balance(currentNode);
      if (!currentNode.left) {
        throw new Error("Parent of current leaf cannot have a null left child" + currentNode);
      }
      if (!currentNode.right) {
        throw new Error("Parent of current leaf cannot have a null right child" + currentNode);
      }
      currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
      currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
      currentNode = currentNode.parent;
    }
  }
  /**
   * Removes a node from the dynamic tree
   */
  _remove(leaf) {
    if (leaf === this.root) {
      this.root = null;
      return;
    }
    const parent = leaf.parent;
    const grandParent = parent.parent;
    let sibling;
    if (parent.left === leaf) {
      sibling = parent.right;
    } else {
      sibling = parent.left;
    }
    if (grandParent) {
      if (grandParent.left === parent) {
        grandParent.left = sibling;
      } else {
        grandParent.right = sibling;
      }
      sibling.parent = grandParent;
      let currentNode = grandParent;
      while (currentNode) {
        currentNode = this._balance(currentNode);
        currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
        currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
        currentNode = currentNode.parent;
      }
    } else {
      this.root = sibling;
      sibling.parent = null;
    }
  }
  /**
   * Tracks a body in the dynamic tree
   */
  trackCollider(collider) {
    const node = new TreeNode();
    node.data = collider;
    node.bounds = collider.bounds;
    node.bounds.left -= 2;
    node.bounds.top -= 2;
    node.bounds.right += 2;
    node.bounds.bottom += 2;
    this.nodes[collider.id.value] = node;
    this._insert(node);
  }
  /**
   * Updates the dynamic tree given the current bounds of each body being tracked
   */
  updateCollider(collider) {
    var _a;
    const node = this.nodes[collider.id.value];
    if (!node) {
      return false;
    }
    const b = collider.bounds;
    if (!this.worldBounds.contains(b)) {
      Logger.getInstance().warn(
        "Collider with id " + collider.id.value + " is outside the world bounds and will no longer be tracked for physics"
      );
      this.untrackCollider(collider);
      return false;
    }
    if (node.bounds.contains(b)) {
      return false;
    }
    this._remove(node);
    b.left -= this._config.boundsPadding;
    b.top -= this._config.boundsPadding;
    b.right += this._config.boundsPadding;
    b.bottom += this._config.boundsPadding;
    if (collider.owner) {
      const body = (_a = collider.owner) == null ? void 0 : _a.get(BodyComponent);
      if (body) {
        const multdx = body.vel.x * 32 / 1e3 * this._config.velocityMultiplier;
        const multdy = body.vel.y * 32 / 1e3 * this._config.velocityMultiplier;
        if (multdx < 0) {
          b.left += multdx;
        } else {
          b.right += multdx;
        }
        if (multdy < 0) {
          b.top += multdy;
        } else {
          b.bottom += multdy;
        }
      }
    }
    node.bounds = b;
    this._insert(node);
    return true;
  }
  /**
   * Untracks a body from the dynamic tree
   */
  untrackCollider(collider) {
    const node = this.nodes[collider.id.value];
    if (!node) {
      return;
    }
    this._remove(node);
    this.nodes[collider.id.value] = null;
    delete this.nodes[collider.id.value];
  }
  /**
   * Balances the tree about a node
   */
  _balance(node) {
    if (node === null) {
      throw new Error("Cannot balance at null node");
    }
    if (node.isLeaf() || node.height < 2) {
      return node;
    }
    const left = node.left;
    const right = node.right;
    const a = node;
    const b = left;
    const c = right;
    const d = left.left;
    const e = left.right;
    const f = right.left;
    const g = right.right;
    const balance = c.height - b.height;
    if (balance > 1) {
      c.left = a;
      c.parent = a.parent;
      a.parent = c;
      if (c.parent) {
        if (c.parent.left === a) {
          c.parent.left = c;
        } else {
          c.parent.right = c;
        }
      } else {
        this.root = c;
      }
      if (f.height > g.height) {
        c.right = f;
        a.right = g;
        g.parent = a;
        a.bounds = b.bounds.combine(g.bounds);
        c.bounds = a.bounds.combine(f.bounds);
        a.height = 1 + Math.max(b.height, g.height);
        c.height = 1 + Math.max(a.height, f.height);
      } else {
        c.right = g;
        a.right = f;
        f.parent = a;
        a.bounds = b.bounds.combine(f.bounds);
        c.bounds = a.bounds.combine(g.bounds);
        a.height = 1 + Math.max(b.height, f.height);
        c.height = 1 + Math.max(a.height, g.height);
      }
      return c;
    }
    if (balance < -1) {
      b.left = a;
      b.parent = a.parent;
      a.parent = b;
      if (b.parent) {
        if (b.parent.left === a) {
          b.parent.left = b;
        } else {
          if (b.parent.right !== a) {
            throw "Error rotating Dynamic Tree";
          }
          b.parent.right = b;
        }
      } else {
        this.root = b;
      }
      if (d.height > e.height) {
        b.right = d;
        a.left = e;
        e.parent = a;
        a.bounds = c.bounds.combine(e.bounds);
        b.bounds = a.bounds.combine(d.bounds);
        a.height = 1 + Math.max(c.height, e.height);
        b.height = 1 + Math.max(a.height, d.height);
      } else {
        b.right = e;
        a.left = d;
        d.parent = a;
        a.bounds = c.bounds.combine(d.bounds);
        b.bounds = a.bounds.combine(e.bounds);
        a.height = 1 + Math.max(c.height, d.height);
        b.height = 1 + Math.max(a.height, e.height);
      }
      return b;
    }
    return node;
  }
  /**
   * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows
   */
  getHeight() {
    if (this.root === null) {
      return 0;
    }
    return this.root.height;
  }
  /**
   * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.
   *
   * In the query callback, it will be passed a potential collider. Returning true from this callback indicates
   * that you are complete with your query and you do not want to continue. Returning false will continue searching
   * the tree until all possible colliders have been returned.
   */
  query(collider, callback) {
    const bounds = collider.bounds;
    const helper = (currentNode) => {
      if (currentNode && currentNode.bounds.overlaps(bounds)) {
        if (currentNode.isLeaf() && currentNode.data !== collider) {
          if (callback.call(collider, currentNode.data)) {
            return true;
          }
        } else {
          return helper(currentNode.left) || helper(currentNode.right);
        }
      }
      return false;
    };
    helper(this.root);
  }
  /**
   * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely
   * long ray to test the tree specified by `max`.
   *
   * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this
   * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching
   * the tree until all possible bodies that would intersect with the ray have been returned.
   */
  rayCastQuery(ray, max = Infinity, callback) {
    const helper = (currentNode) => {
      if (currentNode && currentNode.bounds.rayCast(ray, max)) {
        if (currentNode.isLeaf()) {
          if (callback.call(ray, currentNode.data)) {
            return true;
          }
        } else {
          return helper(currentNode.left) || helper(currentNode.right);
        }
      }
      return false;
    };
    helper(this.root);
  }
  getNodes() {
    const helper = (currentNode) => {
      if (currentNode) {
        return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
      } else {
        return [];
      }
    };
    return helper(this.root);
  }
  debug(ex) {
    const helper = (currentNode) => {
      if (currentNode) {
        if (currentNode.isLeaf()) {
          currentNode.bounds.draw(ex, Color.Green);
        } else {
          currentNode.bounds.draw(ex, Color.White);
        }
        if (currentNode.left) {
          helper(currentNode.left);
        }
        if (currentNode.right) {
          helper(currentNode.right);
        }
      }
    };
    helper(this.root);
  }
}
class Ray {
  /**
   * @param pos The starting position for the ray
   * @param dir The vector indicating the direction of the ray
   */
  constructor(pos, dir) {
    this.pos = pos;
    this.dir = dir.normalize();
  }
  /**
   * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
   * This number indicates the mathematical intersection time.
   * @param line  The line to test
   */
  intersect(line2) {
    const numerator = line2.begin.sub(this.pos);
    if (this.dir.cross(line2.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
      return -1;
    }
    const divisor = this.dir.cross(line2.getSlope());
    if (divisor === 0) {
      return -1;
    }
    const t = numerator.cross(line2.getSlope()) / divisor;
    if (t >= 0) {
      const u = numerator.cross(this.dir) / divisor / line2.getLength();
      if (u >= 0 && u <= 1) {
        return t;
      }
    }
    return -1;
  }
  intersectPoint(line2) {
    const time = this.intersect(line2);
    if (time < 0) {
      return null;
    }
    return this.getPoint(time);
  }
  /**
   * Returns the point of intersection given the intersection time
   */
  getPoint(time) {
    return this.pos.add(this.dir.scale(time));
  }
}
class DynamicTreeCollisionProcessor {
  constructor(_config) {
    this._config = _config;
    this._pairs = /* @__PURE__ */ new Set();
    this._collisionPairCache = [];
    this._colliders = [];
    this._dynamicCollisionTree = new DynamicTree(_config.dynamicTree);
  }
  getColliders() {
    return this._colliders;
  }
  query(pointOrBounds) {
    const results = [];
    if (pointOrBounds instanceof BoundingBox) {
      this._dynamicCollisionTree.query(
        {
          id: createId("collider", -1),
          owner: null,
          bounds: pointOrBounds
        },
        (other) => {
          results.push(other);
          return false;
        }
      );
    } else {
      this._dynamicCollisionTree.query(
        {
          id: createId("collider", -1),
          owner: null,
          bounds: new BoundingBox(pointOrBounds.x, pointOrBounds.y, pointOrBounds.x, pointOrBounds.y)
        },
        (other) => {
          results.push(other);
          return false;
        }
      );
    }
    return results;
  }
  rayCast(ray, options) {
    var _a, _b, _c;
    const results = [];
    const maxDistance = (_a = options == null ? void 0 : options.maxDistance) != null ? _a : Infinity;
    const collisionGroup = options == null ? void 0 : options.collisionGroup;
    const collisionMask = !collisionGroup ? (_b = options == null ? void 0 : options.collisionMask) != null ? _b : CollisionGroup.All.category : collisionGroup.category;
    const searchAllColliders = (_c = options == null ? void 0 : options.searchAllColliders) != null ? _c : false;
    this._dynamicCollisionTree.rayCastQuery(ray, maxDistance, (collider) => {
      const owner = collider.owner;
      const maybeBody = owner.get(BodyComponent);
      if ((options == null ? void 0 : options.ignoreCollisionGroupAll) && maybeBody.group === CollisionGroup.All) {
        return false;
      }
      const canCollide = (collisionMask & maybeBody.group.category) !== 0;
      if ((maybeBody == null ? void 0 : maybeBody.group) && !canCollide) {
        return false;
      }
      const hit = collider.rayCast(ray, maxDistance);
      if (hit) {
        if (options == null ? void 0 : options.filter) {
          if (options.filter(hit)) {
            results.push(hit);
            if (!searchAllColliders) {
              return true;
            }
          }
        } else {
          results.push(hit);
          if (!searchAllColliders) {
            return true;
          }
        }
      }
      return false;
    });
    return results;
  }
  /**
   * Tracks a physics body for collisions
   */
  track(target) {
    if (!target) {
      Logger.getInstance().warn("Cannot track null collider");
      return;
    }
    if (target instanceof CompositeCollider) {
      const colliders = target.getColliders();
      for (const c of colliders) {
        c.owner = target.owner;
        this._colliders.push(c);
        this._dynamicCollisionTree.trackCollider(c);
      }
    } else {
      this._colliders.push(target);
      this._dynamicCollisionTree.trackCollider(target);
    }
  }
  /**
   * Untracks a physics body
   */
  untrack(target) {
    if (!target) {
      Logger.getInstance().warn("Cannot untrack a null collider");
      return;
    }
    if (target instanceof CompositeCollider) {
      const colliders = target.getColliders();
      for (const c of colliders) {
        const index = this._colliders.indexOf(c);
        if (index !== -1) {
          this._colliders.splice(index, 1);
        }
        this._dynamicCollisionTree.untrackCollider(c);
      }
    } else {
      const index = this._colliders.indexOf(target);
      if (index !== -1) {
        this._colliders.splice(index, 1);
      }
      this._dynamicCollisionTree.untrackCollider(target);
    }
  }
  _pairExists(colliderA, colliderB) {
    const hash = Pair.calculatePairHash(colliderA.id, colliderB.id);
    return this._pairs.has(hash);
  }
  /**
   * Detects potential collision pairs in a broadphase approach with the dynamic AABB tree strategy
   */
  broadphase(targets, elapsed, stats) {
    const seconds = elapsed / 1e3;
    const potentialColliders = targets.filter((other) => {
      var _a, _b;
      const body = (_a = other.owner) == null ? void 0 : _a.get(BodyComponent);
      return ((_b = other.owner) == null ? void 0 : _b.isActive) && body.collisionType !== CollisionType.PreventCollision;
    });
    this._collisionPairCache = [];
    this._pairs.clear();
    let collider;
    for (let j = 0, l = potentialColliders.length; j < l; j++) {
      collider = potentialColliders[j];
      this._dynamicCollisionTree.query(collider, (other) => {
        if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {
          const pair = new Pair(collider, other);
          this._pairs.add(pair.id);
          this._collisionPairCache.push(pair);
        }
        return false;
      });
    }
    if (stats) {
      stats.physics.pairs = this._collisionPairCache.length;
    }
    if (this._config.continuous.checkForFastBodies) {
      for (const collider2 of potentialColliders) {
        const body = collider2.owner.get(BodyComponent);
        if ((body == null ? void 0 : body.collisionType) !== CollisionType.Active) {
          continue;
        }
        const updateDistance = body.vel.magnitude * seconds + // velocity term
        body.acc.magnitude * 0.5 * seconds * seconds;
        const minDimension = Math.min(collider2.bounds.height, collider2.bounds.width);
        if (this._config.continuous.disableMinimumSpeedForFastBody || updateDistance > minDimension / 2) {
          if (stats) {
            stats.physics.fastBodies++;
          }
          const updateVec = body.globalPos.sub(body.oldPos);
          const centerPoint = collider2.center;
          const furthestPoint = collider2.getFurthestPoint(body.vel);
          const origin = furthestPoint.sub(updateVec);
          const ray = new Ray(origin, body.vel);
          ray.pos = ray.pos.add(ray.dir.scale(-2 * this._config.continuous.surfaceEpsilon));
          let minCollider;
          let minTranslate = new Vector(Infinity, Infinity);
          this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + this._config.continuous.surfaceEpsilon * 2, (other) => {
            if (!this._pairExists(collider2, other) && Pair.canCollide(collider2, other)) {
              const hit = other.rayCast(ray, updateDistance + this._config.continuous.surfaceEpsilon * 10);
              if (hit) {
                const translate = hit.point.sub(origin);
                if (translate.magnitude < minTranslate.magnitude) {
                  minTranslate = translate;
                  minCollider = other;
                }
              }
            }
            return false;
          });
          if (minCollider && Vector.isValid(minTranslate)) {
            const pair = new Pair(collider2, minCollider);
            if (!this._pairs.has(pair.id)) {
              this._pairs.add(pair.id);
              this._collisionPairCache.push(pair);
            }
            const shift = centerPoint.sub(furthestPoint);
            body.globalPos = origin.add(shift).add(minTranslate).add(ray.dir.scale(10 * this._config.continuous.surfaceEpsilon));
            collider2.update(body.transform.get());
            if (stats) {
              stats.physics.fastBodyCollisions++;
            }
          }
        }
      }
    }
    return this._collisionPairCache;
  }
  /**
   * Applies narrow phase on collision pairs to find actual area intersections
   * Adds actual colliding pairs to stats' Frame data
   */
  narrowphase(pairs, stats) {
    let contacts = [];
    for (let i = 0; i < pairs.length; i++) {
      const newContacts = pairs[i].collide();
      contacts = contacts.concat(newContacts);
      if (stats && newContacts.length > 0) {
        for (const c of newContacts) {
          stats.physics.contacts.set(c.id, c);
        }
      }
    }
    if (stats) {
      stats.physics.collisions += contacts.length;
    }
    return contacts;
  }
  /**
   * Update the dynamic tree positions
   */
  update(targets) {
    let updated = 0;
    const len = targets.length;
    for (let i = 0; i < len; i++) {
      if (this._dynamicCollisionTree.updateCollider(targets[i])) {
        updated++;
      }
    }
    return updated;
  }
  debug(ex) {
    this._dynamicCollisionTree.debug(ex);
  }
}
const _Collider = class _Collider2 {
  constructor() {
    this.id = createId("collider", _Collider2._ID++);
    this.composite = null;
    this.events = new EventEmitter();
    this.offset = Vector.Zero;
  }
  /**
   * Returns a boolean indicating whether this body collided with
   * or was in stationary contact with
   * the body of the other {@apilink Collider}
   */
  touching(other) {
    const contact = this.collide(other);
    if (contact && contact.length > 0) {
      return true;
    }
    return false;
  }
};
_Collider._ID = 0;
let Collider = _Collider;
var SolverStrategy = /* @__PURE__ */ ((SolverStrategy2) => {
  SolverStrategy2["Arcade"] = "arcade";
  SolverStrategy2["Realistic"] = "realistic";
  return SolverStrategy2;
})(SolverStrategy || {});
var ContactSolveBias = /* @__PURE__ */ ((ContactSolveBias2) => {
  ContactSolveBias2["None"] = "none";
  ContactSolveBias2["VerticalFirst"] = "vertical-first";
  ContactSolveBias2["HorizontalFirst"] = "horizontal-first";
  return ContactSolveBias2;
})(ContactSolveBias || {});
const VerticalFirst = {
  vertical: 1,
  horizontal: 2
};
const HorizontalFirst = {
  horizontal: 1,
  vertical: 2
};
const None = {
  horizontal: 0,
  vertical: 0
};
var SpatialPartitionStrategy = /* @__PURE__ */ ((SpatialPartitionStrategy2) => {
  SpatialPartitionStrategy2["DynamicTree"] = "dynamic-tree";
  SpatialPartitionStrategy2["SparseHashGrid"] = "sparse-hash-grid";
  return SpatialPartitionStrategy2;
})(SpatialPartitionStrategy || {});
const getDefaultPhysicsConfig = () => ({
  enabled: true,
  gravity: vec(0, 0).clone(),
  solver: SolverStrategy.Arcade,
  substep: 1,
  colliders: {
    compositeStrategy: "together"
  },
  continuous: {
    checkForFastBodies: true,
    disableMinimumSpeedForFastBody: false,
    surfaceEpsilon: 0.1
  },
  bodies: {
    canSleepByDefault: false,
    sleepEpsilon: 0.07,
    wakeThreshold: 0.07 * 3,
    sleepBias: 0.9,
    defaultMass: 10
  },
  spatialPartition: SpatialPartitionStrategy.SparseHashGrid,
  sparseHashGrid: {
    size: 100
  },
  dynamicTree: {
    boundsPadding: 5,
    velocityMultiplier: 2
  },
  arcade: {
    contactSolveBias: ContactSolveBias.None
  },
  realistic: {
    contactSolveBias: ContactSolveBias.None,
    positionIterations: 3,
    velocityIterations: 8,
    slop: 1,
    steeringFactor: 0.2,
    warmStart: true
  }
});
class CompositeCollider extends Collider {
  constructor(colliders) {
    super();
    this._collisionProcessor = new DynamicTreeCollisionProcessor({
      ...getDefaultPhysicsConfig()
    });
    this._dynamicAABBTree = new DynamicTree({
      boundsPadding: 5,
      velocityMultiplier: 2
    });
    this._colliders = [];
    for (const c of colliders) {
      this.addCollider(c);
    }
  }
  /**
   * Treat composite collider's member colliders as either separate colliders for the purposes of onCollisionStart/onCollision
   * or as a single collider together.
   *
   * This property can be overridden on individual {@apilink CompositeColliders}.
   *
   * For composites without gaps or small groups of colliders, you probably want 'together'
   *
   * For composites with deliberate gaps, like a platforming level layout, you probably want 'separate'
   *
   * Default is 'together' if unset
   */
  set compositeStrategy(value) {
    this._compositeStrategy = value;
  }
  get compositeStrategy() {
    return this._compositeStrategy;
  }
  clearColliders() {
    this._colliders = [];
  }
  addCollider(collider) {
    let colliders;
    if (collider instanceof CompositeCollider) {
      colliders = collider.getColliders();
      colliders.forEach((c) => c.offset.addEqual(collider.offset));
    } else {
      colliders = [collider];
    }
    for (const c of colliders) {
      c.events.pipe(this.events);
      c.composite = this;
      this._colliders.push(c);
      this._collisionProcessor.track(c);
      this._dynamicAABBTree.trackCollider(c);
    }
  }
  removeCollider(collider) {
    collider.events.pipe(this.events);
    collider.composite = null;
    removeItemFromArray(collider, this._colliders);
    this._collisionProcessor.untrack(collider);
    this._dynamicAABBTree.untrackCollider(collider);
  }
  getColliders() {
    return this._colliders;
  }
  get worldPos() {
    var _a, _b;
    return ((_b = (_a = this._transform) == null ? void 0 : _a.pos) != null ? _b : Vector.Zero).add(this.offset);
  }
  get center() {
    var _a, _b;
    return ((_b = (_a = this._transform) == null ? void 0 : _a.pos) != null ? _b : Vector.Zero).add(this.offset);
  }
  get bounds() {
    var _a, _b;
    const colliders = this.getColliders();
    const results = colliders.reduce(
      (acc, collider) => acc.combine(collider.bounds),
      (_b = (_a = colliders[0]) == null ? void 0 : _a.bounds) != null ? _b : new BoundingBox().translate(this.worldPos)
    );
    return results.translate(this.offset);
  }
  get localBounds() {
    var _a, _b;
    const colliders = this.getColliders();
    const results = colliders.reduce((acc, collider) => acc.combine(collider.localBounds), (_b = (_a = colliders[0]) == null ? void 0 : _a.localBounds) != null ? _b : new BoundingBox());
    return results;
  }
  get axes() {
    const colliders = this.getColliders();
    let axes = [];
    for (const collider of colliders) {
      axes = axes.concat(collider.axes);
    }
    return axes;
  }
  getFurthestPoint(direction) {
    const colliders = this.getColliders();
    const furthestPoints = [];
    for (const collider of colliders) {
      furthestPoints.push(collider.getFurthestPoint(direction));
    }
    let bestPoint = furthestPoints[0];
    let maxDistance = -Number.MAX_VALUE;
    for (const point2 of furthestPoints) {
      const distance = point2.dot(direction);
      if (distance > maxDistance) {
        bestPoint = point2;
        maxDistance = distance;
      }
    }
    return bestPoint;
  }
  getInertia(mass) {
    const colliders = this.getColliders();
    let totalInertia = 0;
    for (const collider of colliders) {
      totalInertia += collider.getInertia(mass);
    }
    return totalInertia;
  }
  collide(other) {
    let otherColliders = [other];
    if (other instanceof CompositeCollider) {
      otherColliders = other.getColliders();
    }
    const pairs = [];
    for (const c of otherColliders) {
      this._dynamicAABBTree.query(c, (potentialCollider) => {
        pairs.push(new Pair(c, potentialCollider));
        return false;
      });
    }
    let contacts = [];
    for (const p of pairs) {
      contacts = contacts.concat(p.collide());
    }
    return contacts;
  }
  getClosestLineBetween(other) {
    const colliders = this.getColliders();
    const lines = [];
    if (other instanceof CompositeCollider) {
      const otherColliders = other.getColliders();
      for (const colliderA of colliders) {
        for (const colliderB of otherColliders) {
          const maybeLine = colliderA.getClosestLineBetween(colliderB);
          if (maybeLine) {
            lines.push(maybeLine);
          }
        }
      }
    } else {
      for (const collider of colliders) {
        const maybeLine = other.getClosestLineBetween(collider);
        if (maybeLine) {
          lines.push(maybeLine);
        }
      }
    }
    if (lines.length) {
      let minLength = lines[0].getLength();
      let minLine = lines[0];
      for (const line2 of lines) {
        const length = line2.getLength();
        if (length < minLength) {
          minLength = length;
          minLine = line2;
        }
      }
      return minLine;
    }
    return null;
  }
  contains(point2) {
    const colliders = this.getColliders();
    for (const collider of colliders) {
      if (collider.contains(point2)) {
        return true;
      }
    }
    return false;
  }
  rayCast(ray, max) {
    const colliders = this.getColliders();
    const hits = [];
    for (const collider of colliders) {
      const hit = collider.rayCast(ray, max);
      if (hit) {
        hits.push(hit);
      }
    }
    if (hits.length) {
      let minHit = hits[0];
      let minDistance = minHit.point.dot(ray.dir);
      for (const hit of hits) {
        const distance = ray.dir.dot(hit.point);
        if (distance < minDistance) {
          minHit = hit;
          minDistance = distance;
        }
      }
      return minHit;
    }
    return null;
  }
  project(axis) {
    const colliders = this.getColliders();
    const projections = [];
    for (const collider of colliders) {
      const proj = collider.project(axis);
      if (proj) {
        projections.push(proj);
      }
    }
    if (projections.length) {
      const newProjection = new Projection(projections[0].min, projections[0].max);
      for (const proj of projections) {
        newProjection.min = Math.min(proj.min, newProjection.min);
        newProjection.max = Math.max(proj.max, newProjection.max);
      }
      return newProjection;
    }
    return null;
  }
  update(transform) {
    if (transform) {
      const colliders = this.getColliders();
      for (const collider of colliders) {
        collider.owner = this.owner;
        collider.update(transform);
      }
    }
  }
  debug(ex, color, options) {
    const colliders = this.getColliders();
    ex.save();
    ex.translate(this.offset.x, this.offset.y);
    for (const collider of colliders) {
      collider.debug(ex, color, options);
    }
    ex.restore();
  }
  clone() {
    const result = new CompositeCollider(this._colliders.map((c) => c.clone()));
    result.offset = this.offset.clone();
    return result;
  }
}
class LineSegment {
  /**
   * @param begin  The starting point of the line segment
   * @param end  The ending point of the line segment
   */
  constructor(begin, end) {
    this.begin = begin;
    this.end = end;
  }
  clone(dest) {
    const result = dest || new LineSegment(this.begin.clone(), this.end.clone());
    result.begin = this.begin.clone(result.begin);
    result.end = this.end.clone(result.end);
    return result;
  }
  transform(matrix, dest) {
    const result = dest || new LineSegment(Vector.Zero, Vector.Zero);
    result.begin = matrix.multiply(this.begin, result.begin);
    result.end = matrix.multiply(this.end, result.end);
    return result;
  }
  /**
   * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.
   */
  get slope() {
    return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);
  }
  /**
   * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.
   */
  get intercept() {
    return this.begin.y - this.slope * this.begin.x;
  }
  /**
   * Gets the normal of the line
   */
  normal() {
    if (this._normal) {
      return this._normal;
    }
    return this._normal = this.end.sub(this.begin).normal();
  }
  dir() {
    if (this._dir) {
      return this._dir;
    }
    return this._dir = this.end.sub(this.begin);
  }
  getPoints() {
    return [this.begin, this.end];
  }
  /**
   * Returns the slope of the line in the form of a vector of length 1
   */
  getSlope() {
    if (this._slope) {
      return this._slope;
    }
    const begin = this.begin;
    const end = this.end;
    const distance = begin.distance(end);
    return this._slope = end.sub(begin).scale(1 / distance);
  }
  /**
   * Returns the edge of the line as vector, the length of the vector is the length of the edge
   */
  getEdge() {
    const begin = this.begin;
    const end = this.end;
    return end.sub(begin);
  }
  /**
   * Returns the length of the line segment in pixels
   */
  getLength() {
    const begin = this.begin;
    const end = this.end;
    const distance = begin.distance(end);
    return distance;
  }
  /**
   * Returns the midpoint of the edge
   */
  get midpoint() {
    return this.begin.add(this.end).scale(0.5);
  }
  /**
   * Flips the direction of the line segment
   */
  flip() {
    return new LineSegment(this.end, this.begin);
  }
  /**
   * Tests if a given point is below the line, points in the normal direction above the line are considered above.
   * @param point
   */
  below(point2) {
    const above2 = (this.end.x - this.begin.x) * (point2.y - this.begin.y) - (this.end.y - this.begin.y) * (point2.x - this.begin.x);
    return above2 >= 0;
  }
  /**
   * Returns the clip point
   * @param sideVector Vector that traces the line
   * @param length Length to clip along side
   */
  clip(sideVector, length, normalize = true) {
    let dir = sideVector;
    if (normalize) {
      dir = dir.normalize();
    }
    const near = dir.dot(this.begin) - length;
    const far = dir.dot(this.end) - length;
    const results = [];
    if (near <= 0) {
      results.push(this.begin);
    }
    if (far <= 0) {
      results.push(this.end);
    }
    if (near * far < 0) {
      const clipTime = near / (near - far);
      results.push(this.begin.add(this.end.sub(this.begin).scale(clipTime)));
    }
    if (results.length !== 2) {
      return null;
    }
    return new LineSegment(results[0], results[1]);
  }
  /**
   * Find the perpendicular distance from the line to a point
   * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
   * @param point
   */
  distanceToPoint(point2, signed = false) {
    const x0 = point2.x;
    const y0 = point2.y;
    const l = this.getLength();
    const dy = this.end.y - this.begin.y;
    const dx = this.end.x - this.begin.x;
    const distance = (dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;
    return signed ? distance : Math.abs(distance);
  }
  /**
   * Find the perpendicular line from the line to a point
   * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
   * (a - p) - ((a - p) * n)n
   * a is a point on the line
   * p is the arbitrary point above the line
   * n is a unit vector in direction of the line
   * @param point
   */
  findVectorToPoint(point2) {
    const aMinusP = this.begin.sub(point2);
    const n = this.getSlope();
    return aMinusP.sub(n.scale(aMinusP.dot(n)));
  }
  /**
   * Finds a point on the line given only an X or a Y value. Given an X value, the function returns
   * a new point with the calculated Y value and vice-versa.
   * @param x The known X value of the target point
   * @param y The known Y value of the target point
   * @returns A new point with the other calculated axis value
   */
  findPoint(x = null, y = null) {
    const m = this.slope;
    const b = this.intercept;
    if (x !== null) {
      return new Vector(x, m * x + b);
    } else if (y !== null) {
      return new Vector((y - b) / m, y);
    } else {
      throw new Error("You must provide an X or a Y value");
    }
  }
  /**
   * @see http://stackoverflow.com/a/11908158/109458
   */
  hasPoint() {
    let currPoint;
    let threshold = 0;
    if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
      currPoint = new Vector(arguments[0], arguments[1]);
      threshold = arguments[2] || 0;
    } else if (arguments[0] instanceof Vector) {
      currPoint = arguments[0];
      threshold = arguments[1] || 0;
    } else {
      throw "Could not determine the arguments for Vector.hasPoint";
    }
    const dxc = currPoint.x - this.begin.x;
    const dyc = currPoint.y - this.begin.y;
    const dx1 = this.end.x - this.begin.x;
    const dy1 = this.end.y - this.begin.y;
    const cross = dxc * dy1 - dyc * dx1;
    if (Math.abs(cross) > threshold) {
      return false;
    }
    if (Math.abs(dx1) >= Math.abs(dy1)) {
      return dx1 > 0 ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;
    } else {
      return dy1 > 0 ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;
    }
  }
}
function ClosestLine(line1, line2) {
  const EPSILON = 1e-9;
  const line1Dir = line1.dir();
  const line2Dir = line2.dir();
  const d1Squared = line1Dir.dot(line1Dir);
  const d2Squared = line2Dir.dot(line2Dir);
  if (d1Squared < EPSILON && d2Squared < EPSILON) {
    return new LineSegment(line1.begin, line2.begin);
  }
  if (d1Squared < EPSILON) {
    const t2 = clamp(line2Dir.dot(line1.begin.sub(line2.begin)) / d2Squared, 0, 1);
    const closestPoint = line2.begin.add(line2Dir.scale(t2));
    return new LineSegment(line1.begin, closestPoint);
  }
  if (d2Squared < EPSILON) {
    const t2 = clamp(line1Dir.dot(line2.begin.sub(line1.begin)) / d1Squared, 0, 1);
    const closestPoint = line1.begin.add(line1Dir.scale(t2));
    return new LineSegment(closestPoint, line2.begin);
  }
  const r = line1.begin.sub(line2.begin);
  const a = d1Squared;
  const e = d2Squared;
  const f = line2Dir.dot(r);
  const denom = a * e - Math.pow(line1Dir.dot(line2Dir), 2);
  let s = 0;
  let t = 0;
  if (Math.abs(denom) > EPSILON) {
    s = clamp((line1Dir.dot(line2Dir) * f - e * line1Dir.dot(r)) / denom, 0, 1);
  } else {
    s = clamp(line1Dir.dot(r) / a, 0, 1);
  }
  if (Math.abs(e) > EPSILON) {
    t = clamp((line1Dir.dot(line2Dir) * s + f) / e, 0, 1);
  } else {
    t = 0;
  }
  const closestPointOnLine1 = line1.begin.add(line1Dir.scale(s));
  const closestPointOnLine2 = line2.begin.add(line2Dir.scale(t));
  return new LineSegment(closestPointOnLine1, closestPointOnLine2);
}
const ClosestLineJumpTable = {
  PolygonPolygonClosestLine(polygonA, polygonB) {
    const aSides = polygonA.getSides();
    const bSides = polygonB.getSides();
    let minDistance = Number.MAX_VALUE;
    let closestLine = null;
    for (let i = 0; i < aSides.length; i++) {
      for (let j = 0; j < bSides.length; j++) {
        const line2 = ClosestLine(aSides[i], bSides[j]);
        const distance = line2.getLength();
        if (distance < minDistance) {
          minDistance = distance;
          closestLine = line2;
        }
      }
    }
    return closestLine;
  },
  PolygonEdgeClosestLine(polygon, edge) {
    const otherWorldPos = edge.worldPos;
    const otherDirection = otherWorldPos.sub(polygon.worldPos);
    const rayTowardsOther = new Ray(polygon.worldPos, otherDirection);
    const thisPoint = polygon.rayCast(rayTowardsOther).point.add(rayTowardsOther.dir.scale(0.1));
    const thisFace = polygon.getClosestFace(thisPoint);
    const edgeLine = edge.asLine();
    return ClosestLine(thisFace.face, edgeLine);
  },
  PolygonCircleClosestLine(polygon, circle2) {
    const otherWorldPos = circle2.worldPos;
    const otherDirection = otherWorldPos.sub(polygon.worldPos);
    const rayTowardsOther = new Ray(polygon.worldPos, otherDirection.normalize());
    const thisPoint = polygon.rayCast(rayTowardsOther).point.add(rayTowardsOther.dir.scale(0.1));
    const thisFace = polygon.getClosestFace(thisPoint);
    const p0 = thisFace.face.begin;
    const u = thisFace.face.getEdge();
    let t = (u.x * (otherWorldPos.x - p0.x) + u.y * (otherWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
    if (t > 1) {
      t = 1;
    } else if (t < 0) {
      t = 0;
    }
    const d = Math.sqrt(Math.pow(p0.x + u.x * t - otherWorldPos.x, 2) + Math.pow(p0.y + u.y * t - otherWorldPos.y, 2)) - circle2.radius;
    const circlex = (p0.x + u.x * t - otherWorldPos.x) * circle2.radius / (circle2.radius + d);
    const circley = (p0.y + u.y * t - otherWorldPos.y) * circle2.radius / (circle2.radius + d);
    return new LineSegment(u.scale(t).add(p0), new Vector(otherWorldPos.x + circlex, otherWorldPos.y + circley));
  },
  CircleCircleClosestLine(circleA, circleB) {
    const otherWorldPos = circleB.worldPos;
    const otherDirection = otherWorldPos.sub(circleA.worldPos);
    const thisWorldPos = circleA.worldPos;
    const thisDirection = thisWorldPos.sub(circleB.worldPos);
    const rayTowardsOther = new Ray(circleA.worldPos, otherDirection);
    const rayTowardsThis = new Ray(circleB.worldPos, thisDirection);
    const thisPoint = circleA.rayCast(rayTowardsOther);
    const otherPoint = circleB.rayCast(rayTowardsThis);
    return new LineSegment(thisPoint.point, otherPoint.point);
  },
  CircleEdgeClosestLine(circle2, edge) {
    const circleWorldPos = circle2.worldPos;
    const edgeLine = edge.asLine();
    const edgeStart = edgeLine.begin;
    const edgeVector = edgeLine.getEdge();
    const p0 = edgeStart;
    const u = edgeVector;
    let t = (u.x * (circleWorldPos.x - p0.x) + u.y * (circleWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
    if (t > 1) {
      t = 1;
    } else if (t < 0) {
      t = 0;
    }
    const d = Math.sqrt(Math.pow(p0.x + u.x * t - circleWorldPos.x, 2) + Math.pow(p0.y + u.y * t - circleWorldPos.y, 2)) - circle2.radius;
    const circlex = (p0.x + u.x * t - circleWorldPos.x) * circle2.radius / (circle2.radius + d);
    const circley = (p0.y + u.y * t - circleWorldPos.y) * circle2.radius / (circle2.radius + d);
    return new LineSegment(u.scale(t).add(p0), new Vector(circleWorldPos.x + circlex, circleWorldPos.y + circley));
  },
  EdgeEdgeClosestLine(edgeA, edgeB) {
    const edgeLineA = edgeA.asLine();
    const edgeLineB = edgeB.asLine();
    return ClosestLine(edgeLineA, edgeLineB);
  }
};
class CircleCollider extends Collider {
  constructor(options) {
    super();
    this.offset = Vector.Zero;
    this._globalMatrix = AffineMatrix.identity();
    this._localBoundsDirty = true;
    this.offset = options.offset || Vector.Zero;
    this.radius = options.radius || 0;
    this._globalMatrix.translate(this.offset.x, this.offset.y);
  }
  get worldPos() {
    return this._globalMatrix.getPosition();
  }
  /**
   * Get the radius of the circle
   */
  get radius() {
    var _a;
    if (this._radius) {
      return this._radius;
    }
    const tx = this._transform;
    const scale = (_a = tx == null ? void 0 : tx.globalScale) != null ? _a : Vector.One;
    return this._radius = this._naturalRadius * Math.min(scale.x, scale.y);
  }
  /**
   * Set the radius of the circle
   */
  set radius(val) {
    var _a;
    const tx = this._transform;
    const scale = (_a = tx == null ? void 0 : tx.globalScale) != null ? _a : Vector.One;
    this._naturalRadius = val / Math.min(scale.x, scale.y);
    this._localBoundsDirty = true;
    this._radius = val;
  }
  /**
   * Returns a clone of this shape, not associated with any collider
   */
  clone() {
    return new CircleCollider({
      offset: this.offset.clone(),
      radius: this.radius
    });
  }
  /**
   * Get the center of the collider in world coordinates
   */
  get center() {
    return this._globalMatrix.getPosition();
  }
  /**
   * Tests if a point is contained in this collider
   */
  contains(point2) {
    var _a, _b;
    const pos = (_b = (_a = this._transform) == null ? void 0 : _a.pos) != null ? _b : this.offset;
    const distance = pos.distance(point2);
    if (distance <= this.radius) {
      return true;
    }
    return false;
  }
  /**
   * Casts a ray at the Circle collider and returns the nearest point of collision
   * @param ray
   */
  rayCast(ray, max = Infinity) {
    var _a, _b;
    const c = this.center;
    const dir = ray.dir;
    const orig = ray.pos;
    const u = c.sub(orig);
    const u1 = dir.scale(u.dot(dir));
    const u2 = u.sub(u1);
    const d = u2.magnitude;
    if (d > this.radius) {
      return null;
    } else {
      let toi = 0;
      if (approximatelyEqual(d, this.radius, 1e-4)) {
        toi = -dir.dot(orig.sub(c));
        if (toi > 0 && toi < max) {
          const point2 = ray.getPoint(toi);
          return {
            point: point2,
            normal: point2.sub(c).normalize(),
            collider: this,
            body: (_a = this.owner) == null ? void 0 : _a.get(BodyComponent),
            distance: toi
          };
        }
        return null;
      } else {
        const discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) - Math.pow(orig.sub(c).distance(), 2) + Math.pow(this.radius, 2));
        const toi1 = -dir.dot(orig.sub(c)) + discriminant;
        const toi2 = -dir.dot(orig.sub(c)) - discriminant;
        const positiveToi = [];
        if (toi1 >= 0) {
          positiveToi.push(toi1);
        }
        if (toi2 >= 0) {
          positiveToi.push(toi2);
        }
        const minToi = Math.min(...positiveToi);
        if (minToi <= max) {
          const point2 = ray.getPoint(minToi);
          return {
            point: point2,
            normal: point2.sub(c).normalize(),
            collider: this,
            body: (_b = this.owner) == null ? void 0 : _b.get(BodyComponent),
            distance: minToi
          };
        }
        return null;
      }
    }
  }
  getClosestLineBetween(shape) {
    if (shape instanceof CircleCollider) {
      return ClosestLineJumpTable.CircleCircleClosestLine(this, shape);
    } else if (shape instanceof PolygonCollider) {
      return ClosestLineJumpTable.PolygonCircleClosestLine(shape, this).flip();
    } else if (shape instanceof EdgeCollider) {
      return ClosestLineJumpTable.CircleEdgeClosestLine(this, shape).flip();
    } else {
      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
    }
  }
  /**
   * @inheritdoc
   */
  collide(collider) {
    if (collider instanceof CircleCollider) {
      return CollisionJumpTable.CollideCircleCircle(this, collider);
    } else if (collider instanceof PolygonCollider) {
      return CollisionJumpTable.CollideCirclePolygon(this, collider);
    } else if (collider instanceof EdgeCollider) {
      return CollisionJumpTable.CollideCircleEdge(this, collider);
    } else {
      throw new Error(`Circle could not collide with unknown CollisionShape ${typeof collider}`);
    }
  }
  /**
   * Find the point on the collider furthest in the direction specified
   */
  getFurthestPoint(direction) {
    return this.center.add(direction.normalize().scale(this.radius));
  }
  /**
   * Find the local point on the shape in the direction specified
   * @param direction
   */
  getFurthestLocalPoint(direction) {
    const dir = direction.normalize();
    return dir.scale(this.radius);
  }
  /**
   * Get the axis aligned bounding box for the circle collider in world coordinates
   */
  get bounds() {
    return this.localBounds.transform(this._globalMatrix);
  }
  /**
   * Get the axis aligned bounding box for the circle collider in local coordinates
   */
  get localBounds() {
    if (this._localBoundsDirty) {
      this._localBounds = new BoundingBox(-this._naturalRadius, -this._naturalRadius, +this._naturalRadius, +this._naturalRadius);
      this._localBoundsDirty = false;
    }
    return this._localBounds;
  }
  /**
   * Get axis not implemented on circles, since there are infinite axis in a circle
   */
  get axes() {
    return [];
  }
  /**
   * Returns the moment of inertia of a circle given it's mass
   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
   */
  getInertia(mass) {
    return mass * this.radius * this.radius / 2;
  }
  /* istanbul ignore next */
  update(transform) {
    var _a;
    this._transform = transform;
    const globalMat = (_a = transform.matrix) != null ? _a : this._globalMatrix;
    globalMat.clone(this._globalMatrix);
    this._globalMatrix.translate(this.offset.x, this.offset.y);
    this._radius = void 0;
  }
  /**
   * Project the circle along a specified axis
   */
  project(axis) {
    const scalars = [];
    const point2 = this.center;
    const dotProduct = point2.dot(axis);
    scalars.push(dotProduct);
    scalars.push(dotProduct + this.radius);
    scalars.push(dotProduct - this.radius);
    return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
  }
  debug(ex, color, options) {
    var _a, _b, _c, _d;
    const { lineWidth } = { ...{ lineWidth: 1 }, ...options };
    const tx = this._transform;
    const scale = (_a = tx == null ? void 0 : tx.globalScale) != null ? _a : Vector.One;
    const rotation = (_b = tx == null ? void 0 : tx.globalRotation) != null ? _b : 0;
    const pos = (_c = tx == null ? void 0 : tx.globalPos) != null ? _c : Vector.Zero;
    ex.save();
    ex.translate(pos.x, pos.y);
    ex.rotate(rotation);
    ex.scale(scale.x, scale.y);
    ex.drawCircle((_d = this.offset) != null ? _d : Vector.Zero, this._naturalRadius, Color.Transparent, color, lineWidth);
    ex.restore();
  }
}
class CollisionContact {
  constructor(colliderA, colliderB, mtv, normal, tangent, points, localPoints, info) {
    this._canceled = false;
    this.bodyA = null;
    this.bodyB = null;
    var _a, _b, _c, _d, _e, _f;
    this.colliderA = colliderA;
    this.colliderB = colliderB;
    this.mtv = mtv;
    this.normal = normal;
    this.tangent = tangent;
    this.points = points;
    this.localPoints = localPoints;
    this.info = info;
    this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
    if (colliderA.composite || colliderB.composite) {
      const colliderAId = ((_a = colliderA.composite) == null ? void 0 : _a.compositeStrategy) === "separate" ? colliderA.id : (_c = (_b = colliderA.composite) == null ? void 0 : _b.id) != null ? _c : colliderA.id;
      const colliderBId = ((_d = colliderB.composite) == null ? void 0 : _d.compositeStrategy) === "separate" ? colliderB.id : (_f = (_e = colliderB.composite) == null ? void 0 : _e.id) != null ? _f : colliderB.id;
      this.id += "|" + Pair.calculatePairHash(colliderAId, colliderBId);
    }
    if (this.colliderA.owner) {
      this.bodyA = this.colliderA.owner.get(BodyComponent);
    }
    if (this.colliderB.owner) {
      this.bodyB = this.colliderB.owner.get(BodyComponent);
    }
  }
  /**
   * Match contact awake state, except if body's are Fixed
   */
  matchAwake() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    if (bodyA && bodyB) {
      if (bodyA.isSleeping !== bodyB.isSleeping) {
        if (bodyA.isSleeping && bodyA.collisionType !== CollisionType.Fixed && bodyB.sleepMotion >= bodyA.wakeThreshold) {
          bodyA.isSleeping = false;
        }
        if (bodyB.isSleeping && bodyB.collisionType !== CollisionType.Fixed && bodyA.sleepMotion >= bodyB.wakeThreshold) {
          bodyB.isSleeping = false;
        }
      }
    }
  }
  isCanceled() {
    return this._canceled;
  }
  cancel() {
    this._canceled = true;
  }
  /**
   * Biases the contact so that the given collider is colliderA
   */
  bias(collider) {
    if (collider !== this.colliderA && collider !== this.colliderB) {
      throw new Error("Collider must be either colliderA or colliderB from this contact");
    }
    if (collider === this.colliderA) {
      return this;
    }
    const colliderA = this.colliderA;
    const colliderB = this.colliderB;
    this.colliderB = colliderA;
    this.colliderA = colliderB;
    this.mtv = this.mtv.negate();
    this.normal = this.normal.negate();
    this.tangent = this.tangent.negate();
    return this;
  }
}
class Pool {
  constructor(builder, recycler, maxObjects = 100) {
    this.builder = builder;
    this.recycler = recycler;
    this.maxObjects = maxObjects;
    this.totalAllocations = 0;
    this.index = 0;
    this.objects = [];
    this.disableWarnings = false;
    this._logger = Logger.getInstance();
  }
  dispose() {
    this.objects.length = 0;
  }
  preallocate() {
    for (let i = 0; i < this.maxObjects; i++) {
      this.objects[i] = this.builder();
    }
  }
  /**
   * Use many instances out of the in the context and return all to the pool.
   *
   * By returning values out of the context they will be un-hooked from the pool and are free to be passed to consumers
   * @param context
   */
  using(context) {
    const result = context(this);
    if (result) {
      return this.done(...result);
    }
    return this.done();
  }
  /**
   * Use a single instance out of th pool and immediately return it to the pool
   * @param context
   */
  borrow(context) {
    const object = this.get();
    context(object);
    this.index--;
  }
  /**
   * Retrieve a value from the pool, will allocate a new instance if necessary or recycle from the pool
   */
  get() {
    if (this.index === this.maxObjects) {
      if (!this.disableWarnings) {
        this._logger.warn("Max pooled objects reached, possible memory leak? Doubling");
      }
      this.maxObjects = this.maxObjects * 2;
    }
    if (this.objects[this.index]) {
      if (this.recycler) {
        return this.recycler(this.objects[this.index++]);
      }
      return this.objects[this.index++];
    } else {
      this.totalAllocations++;
      const object = this.objects[this.index++] = this.builder();
      return object;
    }
  }
  done(...objects) {
    this.index = 0;
    for (const object of objects) {
      const poolIndex = this.objects.indexOf(object);
      this.objects[poolIndex] = this.builder();
      this.totalAllocations++;
    }
    return objects;
  }
}
class SeparationInfo {
  constructor() {
    this.axis = vec(0, 0);
    this.localAxis = vec(0, 0);
    this.side = new LineSegment(vec(0, 0), vec(0, 0));
    this.localSide = new LineSegment(vec(0, 0), vec(0, 0));
    this.point = vec(0, 0);
    this.localPoint = vec(0, 0);
  }
}
const _SeparatingAxis = class _SeparatingAxis2 {
  static findPolygonPolygonSeparation(polyA, polyB) {
    if (polyB.transform.matrix.determinant() === 0) {
      return _SeparatingAxis2.findPolygonPolygonSeparationDegenerate(polyA, polyB);
    }
    let bestSeparation = -Number.MAX_VALUE;
    let bestSideIndex = -1;
    let localPoint;
    const toPolyBSpace = polyB.transform.inverse.multiply(polyA.transform.matrix, _SeparatingAxis2._SCRATCH_MATRIX);
    const toPolyBSpaceRotation = toPolyBSpace.getRotation();
    const normalsA = polyA.normals;
    const pointsA = polyA.points;
    const pointsB = polyB.points;
    for (let pointsAIndex = 0; pointsAIndex < pointsA.length; pointsAIndex++) {
      const normal = normalsA[pointsAIndex].rotate(toPolyBSpaceRotation, _SeparatingAxis2._ZERO, _SeparatingAxis2._SCRATCH_NORMAL);
      const point2 = toPolyBSpace.multiply(pointsA[pointsAIndex], _SeparatingAxis2._SCRATCH_POINT);
      let smallestPointDistance = Number.MAX_VALUE;
      let smallestLocalPoint;
      for (let pointsBIndex = 0; pointsBIndex < pointsB.length; pointsBIndex++) {
        const distance = normal.dot(pointsB[pointsBIndex].sub(point2, _SeparatingAxis2._SCRATCH_SUB_POINT));
        if (distance < smallestPointDistance) {
          smallestPointDistance = distance;
          smallestLocalPoint = pointsB[pointsBIndex];
        }
      }
      if (smallestPointDistance > bestSeparation) {
        bestSeparation = smallestPointDistance;
        bestSideIndex = pointsAIndex;
        localPoint = smallestLocalPoint;
      }
    }
    const bestSide2 = (bestSideIndex + 1) % pointsA.length;
    const separationInfo = _SeparatingAxis2.SeparationPool.get();
    separationInfo.collider = polyA;
    separationInfo.separation = bestSeparation;
    if (bestSeparation > 0) {
      return separationInfo;
    }
    normalsA[bestSideIndex].clone(separationInfo.localAxis);
    normalsA[bestSideIndex].rotate(polyA.transform.rotation, _SeparatingAxis2._ZERO, separationInfo.axis);
    polyA.transform.matrix.multiply(pointsA[bestSideIndex], separationInfo.side.begin);
    polyA.transform.matrix.multiply(pointsA[bestSide2], separationInfo.side.end);
    polyB.transform.matrix.multiply(localPoint, separationInfo.point);
    separationInfo.sideId = bestSideIndex;
    localPoint.clone(separationInfo.localPoint);
    pointsA[bestSideIndex].clone(separationInfo.localSide.begin);
    pointsA[bestSide2].clone(separationInfo.localSide.end);
    return separationInfo;
  }
  static findCirclePolygonSeparation(circle2, polygon) {
    const axes = polygon.axes;
    const pc = polygon.center;
    const polyDir = pc.sub(circle2.worldPos);
    const closestPointOnPoly = polygon.getFurthestPoint(polyDir.negate());
    axes.push(closestPointOnPoly.sub(circle2.worldPos).normalize());
    let minOverlap = Number.MAX_VALUE;
    let minAxis = null;
    let minIndex = -1;
    for (let i = 0; i < axes.length; i++) {
      const proj1 = polygon.project(axes[i]);
      const proj2 = circle2.project(axes[i]);
      const overlap = proj1.getOverlap(proj2);
      if (overlap <= 0) {
        return null;
      } else {
        if (overlap < minOverlap) {
          minOverlap = overlap;
          minAxis = axes[i];
          minIndex = i;
        }
      }
    }
    if (minIndex < 0) {
      return null;
    }
    return minAxis.normalize().scale(minOverlap);
  }
  static findPolygonPolygonSeparationDegenerate(polyA, polyB) {
    let bestSeparation = -Number.MAX_VALUE;
    let bestSide = null;
    let bestAxis = null;
    let bestSideIndex = -1;
    let bestOtherPoint = null;
    const sides = polyA.getSides();
    const localSides = polyA.getLocalSides();
    for (let i = 0; i < sides.length; i++) {
      const side = sides[i];
      const axis = side.normal();
      const vertB = polyB.getFurthestPoint(axis.negate());
      const vertSeparation = side.distanceToPoint(vertB, true);
      if (vertSeparation > bestSeparation) {
        bestSeparation = vertSeparation;
        bestSide = side;
        bestAxis = axis;
        bestSideIndex = i;
        bestOtherPoint = vertB;
      }
    }
    return {
      collider: polyA,
      separation: bestAxis ? bestSeparation : 99,
      axis: bestAxis,
      side: bestSide,
      localSide: localSides[bestSideIndex],
      sideId: bestSideIndex,
      point: bestOtherPoint,
      localPoint: bestAxis ? polyB.getFurthestLocalPoint(bestAxis.negate()) : null
    };
  }
};
_SeparatingAxis.SeparationPool = new Pool(
  () => new SeparationInfo(),
  (i) => i,
  // no recycle
  500
);
_SeparatingAxis._ZERO = vec(0, 0);
_SeparatingAxis._SCRATCH_POINT = vec(0, 0);
_SeparatingAxis._SCRATCH_SUB_POINT = vec(0, 0);
_SeparatingAxis._SCRATCH_NORMAL = vec(0, 0);
_SeparatingAxis._SCRATCH_MATRIX = AffineMatrix.identity();
let SeparatingAxis = _SeparatingAxis;
SeparatingAxis.SeparationPool.disableWarnings = true;
const ScratchZero = Vector.Zero;
const ScratchNormal = Vector.Zero;
const ScratchMatrix = AffineMatrix.identity();
const CollisionJumpTable = {
  CollideCircleCircle(circleA, circleB) {
    const circleAPos = circleA.worldPos;
    const circleBPos = circleB.worldPos;
    const combinedRadius = circleA.radius + circleB.radius;
    const distance = circleAPos.distance(circleBPos);
    if (distance > combinedRadius) {
      return [];
    }
    const separation = combinedRadius - distance;
    const normal = circleBPos.sub(circleAPos).normalize();
    const tangent = normal.perpendicular();
    const mvt = normal.scale(separation);
    const point2 = circleA.getFurthestPoint(normal);
    const local = circleA.getFurthestLocalPoint(normal);
    const info = {
      collider: circleA,
      separation,
      axis: normal,
      point: point2
    };
    return [new CollisionContact(circleA, circleB, mvt, normal, tangent, [point2], [local], info)];
  },
  CollideCirclePolygon(circle2, polygon) {
    var _a, _b;
    let minAxis = SeparatingAxis.findCirclePolygonSeparation(circle2, polygon);
    if (!minAxis) {
      return [];
    }
    const sameDir = minAxis.dot(polygon.center.sub(circle2.center));
    minAxis = sameDir < 0 ? minAxis.negate() : minAxis;
    const point2 = circle2.getFurthestPoint(minAxis);
    const xf = (_b = (_a = circle2.owner) == null ? void 0 : _a.get(TransformComponent)) != null ? _b : new TransformComponent();
    const local = xf.applyInverse(point2);
    const normal = minAxis.normalize();
    const info = {
      collider: circle2,
      separation: -minAxis.magnitude,
      axis: normal,
      point: point2,
      localPoint: local,
      side: polygon.findSide(normal.negate()),
      localSide: polygon.findLocalSide(normal.negate())
    };
    return [new CollisionContact(circle2, polygon, minAxis, normal, normal.perpendicular(), [point2], [local], info)];
  },
  CollideCircleEdge(circle2, edge) {
    const cc = circle2.center;
    const edgeWorld = edge.asLine();
    const e = edgeWorld.end.sub(edgeWorld.begin);
    const u = e.dot(edgeWorld.end.sub(cc));
    const v = e.dot(cc.sub(edgeWorld.begin));
    const side = edge.asLine();
    const localSide = edge.asLocalLine();
    if (v <= 0) {
      const da = edgeWorld.begin.sub(cc);
      const dda = da.dot(da);
      if (dda > circle2.radius * circle2.radius) {
        return [];
      }
      const normal2 = da.normalize();
      const separation2 = circle2.radius - Math.sqrt(dda);
      const info2 = {
        collider: circle2,
        separation: separation2,
        axis: normal2,
        point: side.begin,
        side,
        localSide
      };
      return [
        new CollisionContact(circle2, edge, normal2.scale(separation2), normal2, normal2.perpendicular(), [side.begin], [localSide.begin], info2)
      ];
    }
    if (u <= 0) {
      const db = edgeWorld.end.sub(cc);
      const ddb = db.dot(db);
      if (ddb > circle2.radius * circle2.radius) {
        return [];
      }
      const normal2 = db.normalize();
      const separation2 = circle2.radius - Math.sqrt(ddb);
      const info2 = {
        collider: circle2,
        separation: separation2,
        axis: normal2,
        point: side.end,
        side,
        localSide
      };
      return [
        new CollisionContact(circle2, edge, normal2.scale(separation2), normal2, normal2.perpendicular(), [side.end], [localSide.end], info2)
      ];
    }
    const den = e.dot(e);
    const pointOnEdge = edgeWorld.begin.scale(u).add(edgeWorld.end.scale(v)).scale(1 / den);
    const d = cc.sub(pointOnEdge);
    const dd = d.dot(d);
    if (dd > circle2.radius * circle2.radius) {
      return [];
    }
    let normal = e.perpendicular();
    if (normal.dot(cc.sub(edgeWorld.begin)) < 0) {
      normal.x = -normal.x;
      normal.y = -normal.y;
    }
    normal = normal.normalize();
    const separation = circle2.radius - Math.sqrt(dd);
    const mvt = normal.scale(separation);
    const info = {
      collider: circle2,
      separation,
      axis: normal,
      point: pointOnEdge,
      side,
      localSide
    };
    return [
      new CollisionContact(
        circle2,
        edge,
        mvt,
        normal.negate(),
        normal.negate().perpendicular(),
        [pointOnEdge],
        [pointOnEdge.sub(edge.worldPos)],
        info
      )
    ];
  },
  CollideEdgeEdge() {
    return [];
  },
  CollidePolygonEdge(polygon, edge) {
    var _a;
    const pc = polygon.center;
    const ec = edge.center;
    const dir = ec.sub(pc).normalize();
    const linePoly = new PolygonCollider({
      points: [edge.begin, edge.end, edge.end.add(dir.scale(100)), edge.begin.add(dir.scale(100))],
      offset: edge.offset
    });
    linePoly.owner = edge.owner;
    const tx = (_a = edge.owner) == null ? void 0 : _a.get(TransformComponent);
    if (tx) {
      linePoly.update(edge.owner.get(TransformComponent).get());
    }
    const contact = this.CollidePolygonPolygon(polygon, linePoly);
    if (contact.length) {
      contact[0].colliderB = edge;
      contact[0].id = Pair.calculatePairHash(polygon.id, edge.id);
    }
    return contact;
  },
  CollidePolygonPolygon(polyA, polyB) {
    const separationA = SeparatingAxis.findPolygonPolygonSeparation(polyA, polyB);
    if (separationA.separation > 0) {
      return [];
    }
    const separationB = SeparatingAxis.findPolygonPolygonSeparation(polyB, polyA);
    if (separationB.separation > 0) {
      return [];
    }
    const separation = separationA.separation > separationB.separation ? separationA : separationB;
    const other = separation.collider === polyA ? polyB : polyA;
    const main = separation.collider === polyA ? polyA : polyB;
    const toIncidentFrame = other.transform.inverse.multiply(main.transform.matrix, ScratchMatrix);
    const toIncidentFrameRotation = toIncidentFrame.getRotation();
    const referenceEdgeNormal = main.normals[separation.sideId].rotate(toIncidentFrameRotation, ScratchZero, ScratchNormal);
    let minEdge = Number.MAX_VALUE;
    let incidentEdgeIndex = 0;
    for (let i = 0; i < other.normals.length; i++) {
      const value = referenceEdgeNormal.dot(other.normals[i]);
      if (value < minEdge) {
        minEdge = value;
        incidentEdgeIndex = i;
      }
    }
    if (!separation.localSide || !separation.localAxis || !separation.axis) {
      return [];
    }
    const referenceSide = separation.localSide.transform(toIncidentFrame);
    const referenceDirection = separation.localAxis.perpendicular().negate().rotate(toIncidentFrameRotation);
    const incidentSide = new LineSegment(other.points[incidentEdgeIndex], other.points[(incidentEdgeIndex + 1) % other.points.length]);
    const clipRight = incidentSide.clip(referenceDirection.negate(), -referenceDirection.dot(referenceSide.begin), false);
    let clipLeft = null;
    if (clipRight) {
      clipLeft = clipRight.clip(referenceDirection, referenceDirection.dot(referenceSide.end), false);
    }
    if (clipLeft) {
      const localPoints = [];
      const points = [];
      const clipPoints = clipLeft.getPoints();
      for (let i = 0; i < clipPoints.length; i++) {
        const p = clipPoints[i];
        if (referenceSide.below(p)) {
          localPoints.push(p);
          points.push(other.transform.apply(p));
        }
      }
      let normal = separation.axis;
      let tangent = normal.perpendicular();
      if (polyB.center.sub(polyA.center).dot(normal) < 0) {
        normal = normal.negate();
        tangent = normal.perpendicular();
      }
      return [new CollisionContact(polyA, polyB, normal.scale(-separation.separation), normal, tangent, points, localPoints, separation)];
    }
    return [];
  },
  FindContactSeparation(contact, localPoint) {
    var _a, _b, _c, _d;
    const shapeA = contact.colliderA;
    const txA = (_b = (_a = contact.bodyA) == null ? void 0 : _a.transform) != null ? _b : new TransformComponent();
    const shapeB = contact.colliderB;
    const txB = (_d = (_c = contact.bodyB) == null ? void 0 : _c.transform) != null ? _d : new TransformComponent();
    if (shapeA instanceof CircleCollider && shapeB instanceof CircleCollider) {
      const combinedRadius = shapeA.radius + shapeB.radius;
      const distance = txA.pos.distance(txB.pos);
      const separation = combinedRadius - distance;
      return -separation;
    }
    if (shapeA instanceof PolygonCollider && shapeB instanceof PolygonCollider) {
      if (contact.info.localSide) {
        let side;
        let worldPoint;
        if (contact.info.collider === shapeA) {
          side = new LineSegment(
            txA.apply(contact.info.localSide.begin).add(shapeA.offset),
            txA.apply(contact.info.localSide.end).add(shapeA.offset)
          );
          worldPoint = txB.apply(localPoint).add(shapeB.offset);
        } else {
          side = new LineSegment(
            txB.apply(contact.info.localSide.begin).add(shapeB.offset),
            txB.apply(contact.info.localSide.end).add(shapeB.offset)
          );
          worldPoint = txA.apply(localPoint).add(shapeA.offset);
        }
        return side.distanceToPoint(worldPoint, true);
      }
    }
    if (shapeA instanceof PolygonCollider && shapeB instanceof CircleCollider || shapeB instanceof PolygonCollider && shapeA instanceof CircleCollider) {
      const worldPoint = txA.apply(localPoint);
      if (contact.info.side) {
        return contact.info.side.distanceToPoint(worldPoint, true);
      }
    }
    if (shapeA instanceof EdgeCollider && shapeB instanceof PolygonCollider || shapeB instanceof EdgeCollider && shapeA instanceof PolygonCollider) {
      let worldPoint;
      if (contact.info.collider === shapeA) {
        worldPoint = txB.apply(localPoint);
      } else {
        worldPoint = txA.apply(localPoint);
      }
      if (contact.info.side) {
        return contact.info.side.distanceToPoint(worldPoint, true);
      }
    }
    if (shapeA instanceof CircleCollider && shapeB instanceof EdgeCollider || shapeB instanceof CircleCollider && shapeA instanceof EdgeCollider) {
      const worldPoint = txB.apply(localPoint);
      let circlePoint;
      if (shapeA instanceof CircleCollider) {
        circlePoint = shapeA.getFurthestPoint(contact.normal);
      }
      const dist = worldPoint.distance(circlePoint);
      if (contact.info.side) {
        return dist > 0 ? -dist : 0;
      }
    }
    return 0;
  }
};
class EdgeCollider extends Collider {
  constructor(options) {
    var _a;
    super();
    this._globalMatrix = AffineMatrix.identity();
    this.begin = options.begin || Vector.Zero;
    this.end = options.end || Vector.Zero;
    this.offset = (_a = options.offset) != null ? _a : Vector.Zero;
  }
  /**
   * Returns a clone of this Edge, not associated with any collider
   */
  clone() {
    return new EdgeCollider({
      begin: this.begin.clone(),
      end: this.end.clone()
    });
  }
  get worldPos() {
    var _a;
    const tx = this._transform;
    return (_a = tx == null ? void 0 : tx.globalPos.add(this.offset)) != null ? _a : this.offset;
  }
  /**
   * Get the center of the collision area in world coordinates
   */
  get center() {
    const begin = this._getTransformedBegin();
    const end = this._getTransformedEnd();
    const pos = begin.average(end);
    return pos;
  }
  _getTransformedBegin() {
    return this._globalMatrix.multiply(this.begin);
  }
  _getTransformedEnd() {
    return this._globalMatrix.multiply(this.end);
  }
  /**
   * Returns the slope of the line in the form of a vector
   */
  getSlope() {
    const begin = this._getTransformedBegin();
    const end = this._getTransformedEnd();
    const distance = begin.distance(end);
    return end.sub(begin).scale(1 / distance);
  }
  /**
   * Returns the length of the line segment in pixels
   */
  getLength() {
    const begin = this._getTransformedBegin();
    const end = this._getTransformedEnd();
    const distance = begin.distance(end);
    return distance;
  }
  /**
   * Tests if a point is contained in this collision area
   */
  contains() {
    return false;
  }
  /**
   * @inheritdoc
   */
  rayCast(ray, max = Infinity) {
    var _a;
    const numerator = this._getTransformedBegin().sub(ray.pos);
    if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {
      return null;
    }
    const divisor = ray.dir.cross(this.getSlope());
    if (divisor === 0) {
      return null;
    }
    const t = numerator.cross(this.getSlope()) / divisor;
    if (t >= 0 && t <= max) {
      const u = numerator.cross(ray.dir) / divisor / this.getLength();
      if (u >= 0 && u <= 1) {
        return {
          distance: t,
          normal: this.asLine().normal(),
          collider: this,
          body: (_a = this.owner) == null ? void 0 : _a.get(BodyComponent),
          point: ray.getPoint(t)
        };
      }
    }
    return null;
  }
  /**
   * Returns the closes line between this and another collider, from this -> collider
   * @param shape
   */
  getClosestLineBetween(shape) {
    if (shape instanceof CircleCollider) {
      return ClosestLineJumpTable.CircleEdgeClosestLine(shape, this);
    } else if (shape instanceof PolygonCollider) {
      return ClosestLineJumpTable.PolygonEdgeClosestLine(shape, this).flip();
    } else if (shape instanceof EdgeCollider) {
      return ClosestLineJumpTable.EdgeEdgeClosestLine(this, shape);
    } else {
      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
    }
  }
  /**
   * @inheritdoc
   */
  collide(shape) {
    if (shape instanceof CircleCollider) {
      return CollisionJumpTable.CollideCircleEdge(shape, this);
    } else if (shape instanceof PolygonCollider) {
      return CollisionJumpTable.CollidePolygonEdge(shape, this);
    } else if (shape instanceof EdgeCollider) {
      return CollisionJumpTable.CollideEdgeEdge();
    } else {
      throw new Error(`Edge could not collide with unknown CollisionShape ${typeof shape}`);
    }
  }
  /**
   * Find the point on the collider furthest in the direction specified
   */
  getFurthestPoint(direction) {
    const transformedBegin = this._getTransformedBegin();
    const transformedEnd = this._getTransformedEnd();
    if (direction.dot(transformedBegin) > 0) {
      return transformedBegin;
    } else {
      return transformedEnd;
    }
  }
  _boundsFromBeginEnd(begin, end, padding = 10) {
    return new BoundingBox(
      Math.min(begin.x, end.x) - padding,
      Math.min(begin.y, end.y) - padding,
      Math.max(begin.x, end.x) + padding,
      Math.max(begin.y, end.y) + padding
    );
  }
  /**
   * Get the axis aligned bounding box for the edge collider in world space
   */
  get bounds() {
    const transformedBegin = this._getTransformedBegin();
    const transformedEnd = this._getTransformedEnd();
    return this._boundsFromBeginEnd(transformedBegin, transformedEnd);
  }
  /**
   * Get the axis aligned bounding box for the edge collider in local space
   */
  get localBounds() {
    return this._boundsFromBeginEnd(this.begin, this.end);
  }
  /**
   * Returns this edge represented as a line in world coordinates
   */
  asLine() {
    return new LineSegment(this._getTransformedBegin(), this._getTransformedEnd());
  }
  /**
   * Return this edge as a line in local line coordinates (relative to the position)
   */
  asLocalLine() {
    return new LineSegment(this.begin, this.end);
  }
  /**
   * Get the axis associated with the edge
   */
  get axes() {
    const e = this._getTransformedEnd().sub(this._getTransformedBegin());
    const edgeNormal = e.normal();
    const axes = [];
    axes.push(edgeNormal);
    axes.push(edgeNormal.negate());
    axes.push(edgeNormal.normal());
    axes.push(edgeNormal.normal().negate());
    return axes;
  }
  /**
   * Get the moment of inertia for an edge
   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
   */
  getInertia(mass) {
    const length = this.end.sub(this.begin).distance() / 2;
    return mass * length * length;
  }
  /**
   * @inheritdoc
   */
  update(transform) {
    var _a;
    this._transform = transform;
    const globalMat = (_a = transform.matrix) != null ? _a : this._globalMatrix;
    globalMat.clone(this._globalMatrix);
    this._globalMatrix.translate(this.offset.x, this.offset.y);
  }
  /**
   * Project the edge along a specified axis
   */
  project(axis) {
    const scalars = [];
    const points = [this._getTransformedBegin(), this._getTransformedEnd()];
    const len = points.length;
    for (let i = 0; i < len; i++) {
      scalars.push(points[i].dot(axis));
    }
    return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
  }
  debug(ex, color) {
    const begin = this._getTransformedBegin();
    const end = this._getTransformedEnd();
    ex.drawLine(begin, end, color, 2);
    ex.drawCircle(begin, 2, color);
    ex.drawCircle(end, 2, color);
  }
}
class PolygonCollider extends Collider {
  constructor(options) {
    var _a;
    super();
    this._logger = Logger.getInstance();
    this._transform = new Transform();
    this._transformedPoints = [];
    this._sides = [];
    this._localSides = [];
    this._transformedPointsDirty = true;
    this._sidesDirty = true;
    this._localSidesDirty = true;
    this._localBoundsDirty = true;
    this.offset = (_a = options.offset) != null ? _a : Vector.Zero;
    this._transform.pos.x += this.offset.x;
    this._transform.pos.y += this.offset.y;
    this.points = options.points;
    if (!this.isConvex()) {
      if (!options.suppressConvexWarning) {
        this._logger.warn(
          "Excalibur only supports convex polygon colliders and will not behave properly.Call PolygonCollider.triangulate() to build a new collider composed of smaller convex triangles"
        );
      }
    }
    this._calculateTransformation();
  }
  flagDirty() {
    this._localBoundsDirty = true;
    this._localSidesDirty = true;
    this._transformedPointsDirty = true;
    this._sidesDirty = true;
  }
  get normals() {
    return this._normals;
  }
  /**
   * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.
   * Excalibur stores these in counter-clockwise order
   */
  set points(points) {
    if (points.length < 3) {
      throw new Error("PolygonCollider cannot be created with less that 3 points");
    }
    this._points = points;
    this._checkAndUpdateWinding(this._points);
    this._calculateNormals();
    this.flagDirty();
  }
  _calculateNormals() {
    const normals = [];
    for (let i = 0; i < this._points.length; i++) {
      normals.push(this._points[(i + 1) % this._points.length].sub(this._points[i]).normal());
    }
    this._normals = normals;
  }
  /**
   * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.
   * Excalibur stores these in counter-clockwise order
   */
  get points() {
    return this._points;
  }
  get transform() {
    return this._transform;
  }
  _checkAndUpdateWinding(points) {
    const counterClockwise = this._isCounterClockwiseWinding(points);
    if (!counterClockwise) {
      points.reverse();
    }
  }
  _isCounterClockwiseWinding(points) {
    let sum = 0;
    for (let i = 0; i < points.length; i++) {
      sum += (points[(i + 1) % points.length].x - points[i].x) * (points[(i + 1) % points.length].y + points[i].y);
    }
    return sum < 0;
  }
  /**
   * Returns if the polygon collider is convex, Excalibur does not handle non-convex collision shapes.
   * Call {@apilink Polygon.triangulate} to generate a {@apilink CompositeCollider} from this non-convex shape
   */
  isConvex() {
    if (this.points.length < 3) {
      return false;
    }
    let oldPoint = this.points[this.points.length - 2];
    let newPoint = this.points[this.points.length - 1];
    let direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);
    let oldDirection = 0;
    let orientation = 0;
    let angleSum = 0;
    for (const [i, point2] of this.points.entries()) {
      oldPoint = newPoint;
      oldDirection = direction;
      newPoint = point2;
      direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);
      if (oldPoint.equals(newPoint)) {
        return false;
      }
      let angle = direction - oldDirection;
      if (angle <= -Math.PI) {
        angle += Math.PI * 2;
      } else if (angle > Math.PI) {
        angle -= Math.PI * 2;
      }
      if (i === 0) {
        if (angle === 0) {
          return false;
        }
        orientation = angle > 0 ? 1 : -1;
      } else {
        if (orientation * angle <= 0) {
          return false;
        }
      }
      angleSum += angle;
    }
    return Math.abs(Math.round(angleSum / (Math.PI * 2))) === 1;
  }
  /**
   * Tessellates the polygon into a triangle fan as a {@apilink CompositeCollider} of triangle polygons
   */
  tessellate() {
    const polygons = [];
    for (let i = 1; i < this.points.length - 2; i++) {
      polygons.push([this.points[0], this.points[i + 1], this.points[i + 2]]);
    }
    polygons.push([this.points[0], this.points[1], this.points[2]]);
    return new CompositeCollider(polygons.map((points) => Shape.Polygon(points)));
  }
  /**
   * Triangulate the polygon collider using the "Ear Clipping" algorithm.
   * Returns a new {@apilink CompositeCollider} made up of smaller triangles.
   */
  triangulate() {
    if (this.points.length < 3) {
      throw Error("Invalid polygon");
    }
    const triangles = [];
    const vertices = [...this.points].reverse();
    let vertexCount = vertices.length;
    function getPrevIndex(index) {
      return index === 0 ? vertexCount - 1 : index - 1;
    }
    function getNextIndex(index) {
      return index === vertexCount - 1 ? 0 : index + 1;
    }
    function isConvex(index) {
      const prev = getPrevIndex(index);
      const next = getNextIndex(index);
      const va = vertices[prev];
      const vb = vertices[index];
      const vc = vertices[next];
      const leftArm = va.sub(vb);
      const rightArm = vc.sub(vb);
      if (leftArm.cross(rightArm) < 0) {
        return false;
      }
      return true;
    }
    const convexVertices = vertices.map((_, i) => isConvex(i));
    function isPointInTriangle(point2, a, b, c) {
      const ab = b.sub(a);
      const bc = c.sub(b);
      const ca = a.sub(c);
      const ap = point2.sub(a);
      const bp = point2.sub(b);
      const cp = point2.sub(c);
      const cross1 = ab.cross(ap);
      const cross2 = bc.cross(bp);
      const cross3 = ca.cross(cp);
      if (cross1 > 0 || cross2 > 0 || cross3 > 0) {
        return false;
      }
      return true;
    }
    function findEarTip() {
      for (let i = 0; i < vertexCount; i++) {
        if (convexVertices[i]) {
          const prev = getPrevIndex(i);
          const next = getNextIndex(i);
          const va = vertices[prev];
          const vb = vertices[i];
          const vc = vertices[next];
          let isEar = true;
          for (let j = 0; j < vertexCount; j++) {
            if (j === i || j === prev || j === next) {
              continue;
            }
            const point2 = vertices[j];
            if (isPointInTriangle(point2, va, vb, vc)) {
              isEar = false;
              break;
            }
          }
          if (isEar) {
            return i;
          }
        }
      }
      for (let i = 0; i < vertexCount; i++) {
        if (convexVertices[i]) {
          return i;
        }
      }
      return 0;
    }
    function cutEarTip(index) {
      const prev = getPrevIndex(index);
      const next = getNextIndex(index);
      const va = vertices[prev];
      const vb = vertices[index];
      const vc = vertices[next];
      triangles.push([va, vb, vc]);
      vertices.splice(index, 1);
      convexVertices.splice(index, 1);
      vertexCount--;
    }
    while (vertexCount > 3) {
      const earIndex = findEarTip();
      cutEarTip(earIndex);
      for (let i = 0; i < vertexCount; i++) {
        convexVertices[i] = isConvex(i);
      }
    }
    triangles.push([vertices[0], vertices[1], vertices[2]]);
    return new CompositeCollider(triangles.map((points) => Shape.Polygon(points, Vector.Zero, true)));
  }
  /**
   * Returns a clone of this ConvexPolygon, not associated with any collider
   */
  clone() {
    return new PolygonCollider({
      offset: this.offset.clone(),
      points: this.points.map((p) => p.clone())
    });
  }
  /**
   * Returns the world position of the collider, which is the current body transform plus any defined offset
   */
  get worldPos() {
    return this._transform.pos;
  }
  /**
   * Get the center of the collider in world coordinates
   */
  get center() {
    return this.bounds.center;
  }
  /**
   * Calculates the underlying transformation from the body relative space to world space
   */
  _calculateTransformation() {
    const points = this.points;
    const len = points.length;
    this._transformedPoints.length = 0;
    for (let i = 0; i < len; i++) {
      this._transformedPoints[i] = this._transform.apply(points[i].clone());
    }
  }
  /**
   * Gets the points that make up the polygon in world space, from actor relative space (if specified)
   */
  getTransformedPoints() {
    if (this._transformedPointsDirty) {
      this._calculateTransformation();
      this._transformedPointsDirty = false;
    }
    return this._transformedPoints;
  }
  /**
   * Gets the sides of the polygon in world space
   */
  getSides() {
    if (this._sidesDirty) {
      const lines = [];
      const points = this.getTransformedPoints();
      const len = points.length;
      for (let i = 0; i < len; i++) {
        lines.push(new LineSegment(points[i], points[(i + 1) % len]));
      }
      this._sides = lines;
      this._sidesDirty = false;
    }
    return this._sides;
  }
  /**
   * Returns the local coordinate space sides
   */
  getLocalSides() {
    if (this._localSidesDirty) {
      const lines = [];
      const points = this.points;
      const len = points.length;
      for (let i = 0; i < len; i++) {
        lines.push(new LineSegment(points[i], points[(i + 1) % len]));
      }
      this._localSides = lines;
      this._localSidesDirty = false;
    }
    return this._localSides;
  }
  /**
   * Given a direction vector find the world space side that is most in that direction
   * @param direction
   */
  findSide(direction) {
    const sides = this.getSides();
    let bestSide = sides[0];
    let maxDistance = -Number.MAX_VALUE;
    for (let side = 0; side < sides.length; side++) {
      const currentSide = sides[side];
      const sideNormal = currentSide.normal();
      const mostDirection = sideNormal.dot(direction);
      if (mostDirection > maxDistance) {
        bestSide = currentSide;
        maxDistance = mostDirection;
      }
    }
    return bestSide;
  }
  /**
   * Given a direction vector find the local space side that is most in that direction
   * @param direction
   */
  findLocalSide(direction) {
    const sides = this.getLocalSides();
    let bestSide = sides[0];
    let maxDistance = -Number.MAX_VALUE;
    for (let side = 0; side < sides.length; side++) {
      const currentSide = sides[side];
      const sideNormal = currentSide.normal();
      const mostDirection = sideNormal.dot(direction);
      if (mostDirection > maxDistance) {
        bestSide = currentSide;
        maxDistance = mostDirection;
      }
    }
    return bestSide;
  }
  /**
   * Get the axis associated with the convex polygon
   */
  get axes() {
    const axes = [];
    const sides = this.getSides();
    for (let i = 0; i < sides.length; i++) {
      axes.push(sides[i].normal());
    }
    return axes;
  }
  /**
   * Updates the transform for the collision geometry
   *
   * Collision geometry (points/bounds) will not change until this is called.
   * @param transform
   */
  update(transform) {
    if (transform) {
      transform.cloneWithParent(this._transform);
      this._transformedPointsDirty = true;
      this._sidesDirty = true;
      if (this.offset.x !== 0 || this.offset.y !== 0) {
        this._transform.pos.x += this.offset.x;
        this._transform.pos.y += this.offset.y;
      }
      if (this._transform.isMirrored()) {
        this.points = this.points.map((p) => vec(p.x * sign(this._transform.scale.x), p.y * sign(this._transform.scale.y)));
        this._transform.scale.x = Math.abs(this._transform.scale.x);
        this._transform.scale.y = Math.abs(this._transform.scale.y);
      }
    }
  }
  /**
   * Tests if a point is contained in this collider in world space
   */
  contains(point2) {
    const localPoint = this._transform.applyInverse(point2);
    const testRay = new Ray(localPoint, new Vector(1, 0));
    let intersectCount = 0;
    const sides = this.getLocalSides();
    for (let sideIndex = 0; sideIndex < sides.length; sideIndex++) {
      const side = sides[sideIndex];
      if (testRay.intersect(side) >= 0) {
        intersectCount++;
      }
    }
    if (intersectCount % 2 === 0) {
      return false;
    }
    return true;
  }
  getClosestLineBetween(collider) {
    if (collider instanceof CircleCollider) {
      return ClosestLineJumpTable.PolygonCircleClosestLine(this, collider);
    } else if (collider instanceof PolygonCollider) {
      return ClosestLineJumpTable.PolygonPolygonClosestLine(this, collider);
    } else if (collider instanceof EdgeCollider) {
      return ClosestLineJumpTable.PolygonEdgeClosestLine(this, collider);
    } else {
      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
    }
  }
  /**
   * Returns a collision contact if the 2 colliders collide, otherwise collide will
   * return null.
   * @param collider
   */
  collide(collider) {
    if (collider instanceof CircleCollider) {
      return CollisionJumpTable.CollideCirclePolygon(collider, this);
    } else if (collider instanceof PolygonCollider) {
      return CollisionJumpTable.CollidePolygonPolygon(this, collider);
    } else if (collider instanceof EdgeCollider) {
      return CollisionJumpTable.CollidePolygonEdge(this, collider);
    } else {
      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
    }
  }
  /**
   * Find the point on the collider furthest in the direction specified
   */
  getFurthestPoint(direction) {
    const pts = this.getTransformedPoints();
    let furthestPoint = null;
    let maxDistance = -Number.MAX_VALUE;
    for (let i = 0; i < pts.length; i++) {
      const distance = direction.dot(pts[i]);
      if (distance > maxDistance) {
        maxDistance = distance;
        furthestPoint = pts[i];
      }
    }
    return furthestPoint;
  }
  /**
   * Find the local point on the collider furthest in the direction specified
   * @param direction
   */
  getFurthestLocalPoint(direction) {
    const pts = this.points;
    let furthestPoint = pts[0];
    let maxDistance = -Number.MAX_VALUE;
    for (let i = 0; i < pts.length; i++) {
      const distance = direction.dot(pts[i]);
      if (distance > maxDistance) {
        maxDistance = distance;
        furthestPoint = pts[i];
      }
    }
    return furthestPoint;
  }
  /**
   * Finds the closes face to the point using perpendicular distance
   * @param point point to test against polygon
   */
  getClosestFace(point2) {
    const sides = this.getSides();
    let min = Number.POSITIVE_INFINITY;
    let faceIndex = -1;
    let distance = -1;
    for (let i = 0; i < sides.length; i++) {
      const dist = sides[i].distanceToPoint(point2);
      if (dist < min) {
        min = dist;
        faceIndex = i;
        distance = dist;
      }
    }
    if (faceIndex !== -1) {
      return {
        distance: sides[faceIndex].normal().scale(distance),
        face: sides[faceIndex]
      };
    }
    return null;
  }
  /**
   * Get the axis aligned bounding box for the polygon collider in world coordinates
   */
  get bounds() {
    return this.localBounds.transform(this._transform.matrix);
  }
  /**
   * Get the axis aligned bounding box for the polygon collider in local coordinates
   */
  get localBounds() {
    if (this._localBoundsDirty) {
      this._localBounds = BoundingBox.fromPoints(this.points);
      this._localBoundsDirty = false;
    }
    return this._localBounds;
  }
  /**
   * Get the moment of inertia for an arbitrary polygon
   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
   */
  getInertia(mass) {
    if (this._cachedMass === mass && this._cachedInertia) {
      return this._cachedInertia;
    }
    let numerator = 0;
    let denominator = 0;
    const points = this.points;
    for (let i = 0; i < points.length; i++) {
      const iplusone = (i + 1) % points.length;
      const crossTerm = points[iplusone].cross(points[i]);
      numerator += crossTerm * (points[i].dot(points[i]) + points[i].dot(points[iplusone]) + points[iplusone].dot(points[iplusone]));
      denominator += crossTerm;
    }
    this._cachedMass = mass;
    return this._cachedInertia = mass / 6 * (numerator / denominator);
  }
  /**
   * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.
   */
  rayCast(ray, max = Infinity) {
    var _a;
    const sides = this.getSides();
    const len = sides.length;
    let minContactTime = Number.MAX_VALUE;
    let contactSide;
    let contactIndex = -1;
    for (let i = 0; i < len; i++) {
      const contactTime = ray.intersect(sides[i]);
      if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {
        minContactTime = contactTime;
        contactSide = sides[i];
        contactIndex = i;
      }
    }
    if (contactIndex >= 0) {
      return {
        collider: this,
        distance: minContactTime,
        body: (_a = this.owner) == null ? void 0 : _a.get(BodyComponent),
        point: ray.getPoint(minContactTime),
        normal: contactSide.normal()
      };
    }
    return null;
  }
  /**
   * Project the edges of the polygon along a specified axis
   */
  project(axis) {
    const points = this.getTransformedPoints();
    const len = points.length;
    let min = Number.MAX_VALUE;
    let max = -Number.MAX_VALUE;
    for (let i = 0; i < len; i++) {
      const scalar = points[i].dot(axis);
      min = Math.min(min, scalar);
      max = Math.max(max, scalar);
    }
    return new Projection(min, max);
  }
  debug(ex, color, options) {
    const points = this.getTransformedPoints();
    Debug.drawPolygon(points, { color });
  }
}
class Shape {
  /**
   * Creates a box collider, under the hood defines a {@apilink PolygonCollider} collider
   * @param width Width of the box
   * @param height Height of the box
   * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position
   * @param offset Optional offset relative to the collider in local coordinates
   */
  static Box(width, height, anchor = Vector.Half, offset = Vector.Zero) {
    return new PolygonCollider({
      points: new BoundingBox(-width * anchor.x, -height * anchor.y, width - width * anchor.x, height - height * anchor.y).getPoints().slice(),
      offset
    });
  }
  /**
   * Creates a new {@apilink PolygonCollider | `arbitrary polygon`} collider
   *
   * PolygonColliders are useful for creating convex polygon shapes
   * @param points Points specified in counter clockwise
   * @param offset Optional offset relative to the collider in local coordinates
   */
  static Polygon(points, offset = Vector.Zero, suppressConvexWarning = false) {
    return new PolygonCollider({
      points,
      offset,
      suppressConvexWarning
    });
  }
  /**
   * Creates a new {@apilink CircleCollider | `circle`} collider
   *
   * Circle colliders are useful for balls, or to make collisions more forgiving on sharp edges
   * @param radius Radius of the circle collider
   * @param offset Optional offset relative to the collider in local coordinates
   */
  static Circle(radius, offset = Vector.Zero) {
    return new CircleCollider({
      radius,
      offset
    });
  }
  /**
   * Creates a new {@apilink EdgeCollider | `edge`} collider
   *
   * Edge colliders are useful for  floors, walls, and other barriers
   * @param begin Beginning of the edge in local coordinates to the collider
   * @param end Ending of the edge in local coordinates to the collider
   */
  static Edge(begin, end) {
    return new EdgeCollider({
      begin,
      end
    });
  }
  /**
   * Creates a new capsule shaped {@apilink CompositeCollider} using 2 circles and a box
   *
   * Capsule colliders are useful for platformers with incline or jagged floors to have a smooth
   * player experience.
   * @param width
   * @param height
   * @param offset Optional offset
   */
  static Capsule(width, height, offset = Vector.Zero) {
    const logger = Logger.getInstance();
    if (width === height) {
      logger.warn("A capsule collider with equal width and height is a circle, consider using a ex.Shape.Circle or ex.CircleCollider");
    }
    const vertical = height >= width;
    if (vertical) {
      const capsule = new CompositeCollider([
        Shape.Circle(width / 2, vec(0, -height / 2 + width / 2).add(offset)),
        Shape.Box(width, height - width, Vector.Half, offset),
        Shape.Circle(width / 2, vec(0, height / 2 - width / 2).add(offset))
      ]);
      capsule.compositeStrategy = "together";
      return capsule;
    } else {
      const capsule = new CompositeCollider([
        Shape.Circle(height / 2, vec(-width / 2 + height / 2, 0).add(offset)),
        Shape.Box(width - height, height, Vector.Half, offset),
        Shape.Circle(height / 2, vec(width / 2 - height / 2, 0).add(offset))
      ]);
      capsule.compositeStrategy = "together";
      return capsule;
    }
  }
}
function watch(type, change) {
  if (!type) {
    return type;
  }
  if (type.__isProxy === void 0) {
    return new Proxy(type, {
      set: (obj, prop, value) => {
        if (obj[prop] !== value) {
          obj[prop] = value;
          if (typeof prop === "string") {
            if (prop[0] !== "_") {
              change(obj);
            }
          }
        }
        return true;
      },
      get: (obj, prop) => {
        if (prop !== "__isProxy") {
          return obj[prop];
        }
        return true;
      }
    });
  }
  return type;
}
const createHandler = (path = [], change, typeType) => ({
  get: (target, key) => {
    if (key === "__isProxy") {
      return true;
    }
    if (typeof target[key] === "object" && target[key] != null) {
      return new Proxy(target[key], createHandler([...path, key], change, typeType));
    }
    return target[key];
  },
  set: (target, key, value) => {
    if (typeof key === "string") {
      if (key[0] !== "_") {
        change(typeType);
      }
    }
    target[key] = value;
    return true;
  }
});
function watchDeep(type, change) {
  if (!type) {
    return type;
  }
  if (type.__isProxy === void 0) {
    return new Proxy(type, createHandler([], change, type));
  }
  return type;
}
const _Graphic = class _Graphic2 {
  constructor(options) {
    this.id = _Graphic2._ID++;
    this.transform = AffineMatrix.identity();
    this._transformStale = true;
    this.showDebug = false;
    this._flipHorizontal = false;
    this._flipVertical = false;
    this._rotation = 0;
    this.opacity = 1;
    this._scale = Vector.One;
    this._width = 0;
    this._height = 0;
    var _a, _b, _c, _d, _e, _f, _g;
    if (options) {
      this.origin = (_a = options.origin) != null ? _a : this.origin;
      this.flipHorizontal = (_b = options.flipHorizontal) != null ? _b : this.flipHorizontal;
      this.flipVertical = (_c = options.flipVertical) != null ? _c : this.flipVertical;
      this.rotation = (_d = options.rotation) != null ? _d : this.rotation;
      this.opacity = (_e = options.opacity) != null ? _e : this.opacity;
      this.scale = (_f = options.scale) != null ? _f : this.scale;
      this.tint = (_g = options.tint) != null ? _g : this.tint;
      if (options.width) {
        this._width = options.width;
      }
      if (options.height) {
        this._height = options.height;
      }
    }
  }
  isStale() {
    return this._transformStale;
  }
  /**
   * Gets or sets the flipHorizontal, which will flip the graphic horizontally (across the y axis)
   */
  get flipHorizontal() {
    return this._flipHorizontal;
  }
  set flipHorizontal(value) {
    this._flipHorizontal = value;
    this._transformStale = true;
  }
  /**
   * Gets or sets the flipVertical, which will flip the graphic vertically (across the x axis)
   */
  get flipVertical() {
    return this._flipVertical;
  }
  set flipVertical(value) {
    this._flipVertical = value;
    this._transformStale = true;
  }
  /**
   * Gets or sets the rotation of the graphic
   */
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    this._rotation = value;
    this._transformStale = true;
  }
  /**
   * Gets or sets the scale of the graphic, this affects the width and
   */
  get scale() {
    return this._scale;
  }
  set scale(value) {
    this._scale = watch(value, () => {
      this._transformStale = true;
    });
    this._transformStale = true;
  }
  /**
   * Gets or sets the origin of the graphic, if not set the center of the graphic is the origin
   */
  get origin() {
    return this._origin;
  }
  set origin(value) {
    if (value) {
      this._origin = watch(value, () => {
        this._transformStale = true;
      });
    }
    this._transformStale = true;
  }
  cloneGraphicOptions() {
    return {
      width: this.width / this.scale.x,
      height: this.height / this.scale.y,
      origin: this.origin ? this.origin.clone() : void 0,
      flipHorizontal: this.flipHorizontal,
      flipVertical: this.flipVertical,
      rotation: this.rotation,
      opacity: this.opacity,
      scale: this.scale ? this.scale.clone() : void 0,
      tint: this.tint ? this.tint.clone() : void 0
    };
  }
  /**
   * Gets or sets the width of the graphic (always positive)
   */
  get width() {
    return Math.abs(this._width * this.scale.x);
  }
  /**
   * Gets or sets the height of the graphic (always positive)
   */
  get height() {
    return Math.abs(this._height * this.scale.y);
  }
  set width(value) {
    this._width = value;
    this._transformStale = true;
  }
  set height(value) {
    this._height = value;
    this._transformStale = true;
  }
  /**
   * Gets a copy of the bounds in pixels occupied by the graphic on the the screen. This includes scale.
   */
  get localBounds() {
    return BoundingBox.fromDimension(this.width, this.height, Vector.Zero);
  }
  /**
   * Draw the whole graphic to the context including transform
   * @param ex The excalibur graphics context
   * @param x
   * @param y
   */
  draw(ex, x, y) {
    this._preDraw(ex, x, y);
    this._drawImage(ex, 0, 0);
    this._postDraw(ex);
  }
  /**
   * Apply affine transformations to the graphics context to manipulate the graphic before {@apilink Graphic._drawImage}
   * @param ex
   * @param x
   * @param y
   */
  _preDraw(ex, x, y) {
    ex.save();
    ex.translate(x, y);
    if (this._transformStale) {
      this.transform.reset();
      this.transform.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));
      this._rotate(this.transform);
      this._flip(this.transform);
      this._transformStale = false;
    }
    ex.multiply(this.transform);
    ex.opacity = ex.opacity * this.opacity;
    if (this.tint) {
      ex.tint = this.tint;
    }
  }
  _rotate(ex) {
    var _a;
    const scaleDirX = this.scale.x > 0 ? 1 : -1;
    const scaleDirY = this.scale.y > 0 ? 1 : -1;
    const origin = (_a = this.origin) != null ? _a : vec(this.width / 2, this.height / 2);
    ex.translate(origin.x, origin.y);
    ex.rotate(this.rotation);
    ex.scale(scaleDirX, scaleDirY);
    ex.translate(-origin.x, -origin.y);
  }
  _flip(ex) {
    if (this.flipHorizontal) {
      ex.translate(this.width / this.scale.x, 0);
      ex.scale(-1, 1);
    }
    if (this.flipVertical) {
      ex.translate(0, this.height / this.scale.y);
      ex.scale(1, -1);
    }
  }
  /**
   * Apply any additional work after {@apilink Graphic._drawImage} and restore the context state.
   * @param ex
   */
  _postDraw(ex) {
    if (this.showDebug) {
      ex.debug.drawRect(0, 0, this.width, this.height);
    }
    ex.restore();
  }
};
_Graphic._ID = 0;
let Graphic = _Graphic;
var AnimationDirection = /* @__PURE__ */ ((AnimationDirection2) => {
  AnimationDirection2["Forward"] = "forward";
  AnimationDirection2["Backward"] = "backward";
  return AnimationDirection2;
})(AnimationDirection || {});
var AnimationStrategy = /* @__PURE__ */ ((AnimationStrategy2) => {
  AnimationStrategy2["End"] = "end";
  AnimationStrategy2["Loop"] = "loop";
  AnimationStrategy2["PingPong"] = "pingpong";
  AnimationStrategy2["Freeze"] = "freeze";
  return AnimationStrategy2;
})(AnimationStrategy || {});
const AnimationEvents = {
  Frame: "frame",
  Loop: "loop",
  End: "end"
};
const _Animation = class _Animation2 extends Graphic {
  constructor(options) {
    var _a, _b, _c;
    super(options);
    this.events = new EventEmitter();
    this.frames = [];
    this.strategy = "loop";
    this.frameDuration = 100;
    this._idempotencyToken = -1;
    this._firstTick = true;
    this._currentFrame = 0;
    this._timeLeftInFrame = 0;
    this._pingPongDirection = 1;
    this._done = false;
    this._playing = true;
    this._speed = 1;
    this._wasResetDuringFrameCalc = false;
    this._reversed = false;
    this.frames = options.frames;
    this.speed = (_a = options.speed) != null ? _a : this.speed;
    this.strategy = (_b = options.strategy) != null ? _b : this.strategy;
    this.frameDuration = options.totalDuration ? options.totalDuration / this.frames.length : (_c = options.frameDuration) != null ? _c : this.frameDuration;
    this.data = options.data ? new Map(Object.entries(options.data)) : /* @__PURE__ */ new Map();
    if (options.reverse) {
      this.reverse();
    }
    this.goToFrame(0);
  }
  clone() {
    const ctor = this.constructor;
    return new ctor({
      frames: this.frames.map((f) => ({ ...f })),
      frameDuration: this.frameDuration,
      speed: this.speed,
      reverse: this._reversed,
      strategy: this.strategy,
      ...this.cloneGraphicOptions()
    });
  }
  get width() {
    const maybeFrame = this.currentFrame;
    if (maybeFrame && maybeFrame.graphic) {
      return Math.abs(maybeFrame.graphic.width * this.scale.x);
    }
    return 0;
  }
  get height() {
    const maybeFrame = this.currentFrame;
    if (maybeFrame && maybeFrame.graphic) {
      return Math.abs(maybeFrame.graphic.height * this.scale.y);
    }
    return 0;
  }
  /**
   * Create an Animation from a {@apilink SpriteSheet}, a list of indices into the sprite sheet, a duration per frame
   * and optional {@apilink AnimationStrategy}
   *
   * Example:
   * ```typescript
   * const spriteSheet = SpriteSheet.fromImageSource({...});
   *
   * const anim = Animation.fromSpriteSheet(spriteSheet, range(0, 5), 200, AnimationStrategy.Loop);
   * ```
   * @param spriteSheet ex.SpriteSheet
   * @param spriteSheetIndex 0 based index from left to right, top down (row major order) of the ex.SpriteSheet
   * @param durationPerFrame duration per frame in milliseconds
   * @param strategy Optional strategy, default AnimationStrategy.Loop
   */
  static fromSpriteSheet(spriteSheet, spriteSheetIndex, durationPerFrame, strategy = "loop", data) {
    const maxIndex = spriteSheet.sprites.length - 1;
    const invalidIndices = spriteSheetIndex.filter((index) => index < 0 || index > maxIndex);
    if (invalidIndices.length) {
      _Animation2._LOGGER.warn(
        `Indices into SpriteSheet were provided that don't exist: ${invalidIndices.join(",")} no frame will be shown`
      );
    }
    return new this({
      frames: spriteSheet.sprites.filter((_, index) => spriteSheetIndex.indexOf(index) > -1).map((f) => ({
        graphic: f,
        duration: durationPerFrame
      })),
      strategy,
      data
    });
  }
  /**
   * Create an {@apilink Animation} from a {@apilink SpriteSheet} given a list of coordinates
   *
   * Example:
   * ```typescript
   * const spriteSheet = SpriteSheet.fromImageSource({...});
   *
   * const anim = Animation.fromSpriteSheetCoordinates({
   *  spriteSheet,
   *  frameCoordinates: [
   *    {x: 0, y: 5, duration: 100, options { flipHorizontal: true }},
   *    {x: 1, y: 5, duration: 200},
   *    {x: 2, y: 5},
   *    {x: 3, y: 5}
   *  ],
   *  strategy: AnimationStrategy.PingPong
   * });
   * ```
   * @param options
   * @returns Animation
   */
  static fromSpriteSheetCoordinates(options) {
    var _a;
    const { spriteSheet, frameCoordinates, durationPerFrame, durationPerFrameMs, speed, strategy, reverse, data } = options;
    const defaultDuration = (_a = durationPerFrame != null ? durationPerFrame : durationPerFrameMs) != null ? _a : 100;
    const frames = [];
    for (const coord of frameCoordinates) {
      const { x, y, duration, options: options2 } = coord;
      const sprite = spriteSheet.getSprite(x, y, options2);
      if (sprite) {
        frames.push({
          graphic: sprite,
          duration: duration != null ? duration : defaultDuration
        });
      } else {
        _Animation2._LOGGER.warn(
          `Skipping frame! SpriteSheet does not have coordinate (${x}, ${y}), please check your SpriteSheet to confirm that sprite exists`
        );
      }
    }
    return new this({
      frames,
      strategy,
      speed,
      reverse,
      data
    });
  }
  /**
   * Current animation speed
   *
   * 1 meaning normal 1x speed.
   * 2 meaning 2x speed and so on.
   */
  get speed() {
    return this._speed;
  }
  /**
   * Current animation speed
   *
   * 1 meaning normal 1x speed.
   * 2 meaning 2x speed and so on.
   */
  set speed(val) {
    this._speed = clamp(Math.abs(val), 0, Infinity);
  }
  /**
   * Returns the current Frame of the animation
   *
   * Use {@apilink Animation.currentFrameIndex} to get the frame number and
   * {@apilink Animation.goToFrame} to set the current frame index
   */
  get currentFrame() {
    if (this._currentFrame >= 0 && this._currentFrame < this.frames.length) {
      return this.frames[this._currentFrame];
    }
    return null;
  }
  /**
   * Returns the current frame index of the animation
   *
   * Use {@apilink Animation.currentFrame} to grab the current {@apilink Frame} object
   */
  get currentFrameIndex() {
    return this._currentFrame;
  }
  /**
   * Returns the amount of time in milliseconds left in the current frame
   */
  get currentFrameTimeLeft() {
    return this._timeLeftInFrame;
  }
  /**
   * Returns `true` if the animation is playing
   */
  get isPlaying() {
    return this._playing;
  }
  get isReversed() {
    return this._reversed;
  }
  /**
   * Reverses the play direction of the Animation, this preserves the current frame
   */
  reverse() {
    this.frames = this.frames.slice().reverse();
    this._reversed = !this._reversed;
  }
  /**
   * Returns the current play direction of the animation
   */
  get direction() {
    const reversed = this._reversed && this._pingPongDirection === 1 ? true : false;
    return reversed ? "backward" : "forward";
  }
  /**
   * Plays or resumes the animation from the current frame
   */
  play() {
    this._playing = true;
  }
  /**
   * Pauses the animation on the current frame
   */
  pause() {
    this._playing = false;
    this._firstTick = true;
  }
  /**
   * Reset the animation back to the beginning, including if the animation were done
   */
  reset() {
    this._wasResetDuringFrameCalc = true;
    this._done = false;
    this._firstTick = true;
    this._currentFrame = 0;
    this._timeLeftInFrame = this.frameDuration;
    const maybeFrame = this.frames[this._currentFrame];
    if (maybeFrame) {
      this._timeLeftInFrame = (maybeFrame == null ? void 0 : maybeFrame.duration) || this.frameDuration;
    }
  }
  /**
   * Returns `true` if the animation can end
   */
  get canFinish() {
    switch (this.strategy) {
      case "end":
      case "freeze": {
        return true;
      }
      default: {
        return false;
      }
    }
  }
  /**
   * Returns `true` if the animation is done, for looping type animations
   * `ex.AnimationStrategy.PingPong` and `ex.AnimationStrategy.Loop` this will always return `false`
   *
   * See the `ex.Animation.canFinish()` method to know if an animation type can end
   */
  get done() {
    return this._done;
  }
  /**
   * Jump the animation immediately to a specific frame if it exists
   *
   * Optionally specify an override for the duration of the frame, useful for
   * keeping multiple animations in sync with one another.
   * @param frameNumber
   * @param duration
   */
  goToFrame(frameNumber, duration) {
    this._currentFrame = frameNumber;
    this._timeLeftInFrame = duration != null ? duration : this.frameDuration;
    const maybeFrame = this.frames[this._currentFrame];
    if (maybeFrame && !this._done) {
      this._timeLeftInFrame = duration != null ? duration : (maybeFrame == null ? void 0 : maybeFrame.duration) || this.frameDuration;
      this.events.emit("frame", { ...maybeFrame, frameIndex: this.currentFrameIndex });
    }
  }
  _nextFrame() {
    this._wasResetDuringFrameCalc = false;
    const currentFrame = this._currentFrame;
    if (this._done) {
      return currentFrame;
    }
    let next = -1;
    switch (this.strategy) {
      case "loop": {
        next = (currentFrame + 1) % this.frames.length;
        if (next === 0) {
          this.events.emit("loop", this);
        }
        break;
      }
      case "end": {
        next = currentFrame + 1;
        if (next >= this.frames.length) {
          this._done = true;
          this._currentFrame = this.frames.length;
          this.events.emit("end", this);
        }
        break;
      }
      case "freeze": {
        next = clamp(currentFrame + 1, 0, this.frames.length - 1);
        if (currentFrame + 1 >= this.frames.length) {
          this._done = true;
          this.events.emit("end", this);
        }
        break;
      }
      case "pingpong": {
        if (currentFrame + this._pingPongDirection >= this.frames.length) {
          this._pingPongDirection = -1;
          this.events.emit("loop", this);
        }
        if (currentFrame + this._pingPongDirection < 0) {
          this._pingPongDirection = 1;
          this.events.emit("loop", this);
        }
        next = currentFrame + this._pingPongDirection % this.frames.length;
        break;
      }
    }
    if (this._wasResetDuringFrameCalc) {
      this._wasResetDuringFrameCalc = false;
      return this._currentFrame;
    }
    return next;
  }
  /**
   * Called internally by Excalibur to update the state of the animation potential update the current frame
   * @param elapsed Milliseconds elapsed
   * @param idempotencyToken Prevents double ticking in a frame by passing a unique token to the frame
   */
  tick(elapsed, idempotencyToken = 0) {
    if (this._idempotencyToken === idempotencyToken) {
      return;
    }
    this._idempotencyToken = idempotencyToken;
    if (!this._playing) {
      return;
    }
    if (this._firstTick) {
      this._firstTick = false;
      this.events.emit("frame", { ...this.currentFrame, frameIndex: this.currentFrameIndex });
    }
    this._timeLeftInFrame -= elapsed * this._speed;
    if (this._timeLeftInFrame <= 0) {
      this.goToFrame(this._nextFrame());
    }
  }
  _drawImage(ctx, x, y) {
    if (this.currentFrame && this.currentFrame.graphic) {
      this.currentFrame.graphic.draw(ctx, x, y);
    }
  }
};
_Animation._LOGGER = Logger.getInstance();
let Animation = _Animation;
class GraphicsGroup extends Graphic {
  constructor(options) {
    var _a;
    super(options);
    this._logger = Logger.getInstance();
    this.useAnchor = true;
    this.members = [];
    this.members = options.members;
    this.useAnchor = (_a = options.useAnchor) != null ? _a : this.useAnchor;
    this._updateDimensions();
  }
  clone() {
    return new GraphicsGroup({
      members: [...this.members],
      ...this.cloneGraphicOptions()
    });
  }
  _updateDimensions() {
    const bb = this.localBounds;
    this.width = bb.width;
    this.height = bb.height;
    return bb;
  }
  get localBounds() {
    const bb = new BoundingBox();
    for (const member of this.members) {
      if (member instanceof Graphic) {
        member.localBounds.combine(bb, bb);
      } else {
        const { graphic, offset: pos, useBounds } = member;
        const shouldUseBounds = useBounds === void 0 ? true : useBounds;
        if (graphic) {
          if (shouldUseBounds) {
            graphic.localBounds.translate(pos).combine(bb, bb);
          }
        } else {
          this._logger.warnOnce(`Graphics group member has an null or undefined graphic, member definition: ${JSON.stringify(member)}.`);
        }
      }
    }
    return bb;
  }
  _isAnimationOrGroup(graphic) {
    return graphic instanceof Animation || graphic instanceof GraphicsGroup;
  }
  tick(elapsed, idempotencyToken) {
    for (const member of this.members) {
      let graphic;
      if (member instanceof Graphic) {
        graphic = member;
      } else {
        graphic = member.graphic;
      }
      if (this._isAnimationOrGroup(graphic)) {
        graphic.tick(elapsed, idempotencyToken);
      }
    }
  }
  reset() {
    for (const member of this.members) {
      let graphic;
      if (member instanceof Graphic) {
        graphic = member;
      } else {
        graphic = member.graphic;
      }
      if (this._isAnimationOrGroup(graphic)) {
        graphic.reset();
      }
    }
  }
  _preDraw(ex, x, y) {
    this._updateDimensions();
    super._preDraw(ex, this.useAnchor ? x : 0, this.useAnchor ? y : 0);
  }
  _drawImage(ex, x, y) {
    const pos = Vector.Zero;
    for (const member of this.members) {
      let graphic;
      if (member instanceof Graphic) {
        graphic = member;
      } else {
        graphic = member.graphic;
        member.offset.clone(pos);
      }
      if (!graphic) {
        continue;
      }
      ex.save();
      ex.translate(x, y);
      graphic.draw(ex, pos.x, pos.y);
      if (this.showDebug) {
        ex.debug.drawRect(0, 0, this.width, this.height);
      }
      ex.restore();
    }
  }
}
class Raster extends Graphic {
  constructor(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    super(omit({ ...options }, ["width", "height"]));
    this.lineCap = "butt";
    this.quality = 1;
    this._dirty = true;
    this._smoothing = false;
    this._color = watch(Color.Black, () => this.flagDirty());
    this._lineWidth = 1;
    this._lineDash = [];
    this._padding = 0;
    if (options) {
      this.quality = (_a = options.quality) != null ? _a : this.quality;
      this.color = (_b = options.color) != null ? _b : Color.Black;
      this.strokeColor = options == null ? void 0 : options.strokeColor;
      this.smoothing = (_c = options.smoothing) != null ? _c : this.smoothing;
      this.lineWidth = (_d = options.lineWidth) != null ? _d : this.lineWidth;
      this.lineDash = (_e = options.lineDash) != null ? _e : this.lineDash;
      this.lineCap = (_f = options.lineCap) != null ? _f : this.lineCap;
      this.padding = (_g = options.padding) != null ? _g : this.padding;
      this.filtering = (_h = options.filtering) != null ? _h : this.filtering;
    }
    this._bitmap = document.createElement("canvas");
    const bitmapWidth = (_i = options == null ? void 0 : options.width) != null ? _i : this._bitmap.width;
    const bitmapHeight = (_j = options == null ? void 0 : options.height) != null ? _j : this._bitmap.height;
    this.width = bitmapWidth;
    this.height = bitmapHeight;
    const maybeCtx = this._bitmap.getContext("2d");
    if (!maybeCtx) {
      throw new Error("Browser does not support 2d canvas drawing, cannot create Raster graphic");
    } else {
      this._ctx = maybeCtx;
    }
  }
  cloneRasterOptions() {
    return {
      color: this.color ? this.color.clone() : void 0,
      strokeColor: this.strokeColor ? this.strokeColor.clone() : void 0,
      smoothing: this.smoothing,
      lineWidth: this.lineWidth,
      lineDash: this.lineDash,
      lineCap: this.lineCap,
      quality: this.quality,
      padding: this.padding
    };
  }
  /**
   * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized
   */
  get dirty() {
    return this._dirty;
  }
  /**
   * Flags the graphic as dirty, meaning it must be re-rasterized before draw.
   * This should be called any time the graphics state changes such that it affects the outputted drawing
   */
  flagDirty() {
    this._dirty = true;
  }
  /**
   * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster
   * to be flagged dirty causing a re-raster on the next draw.
   *
   * Any `padding`s or `quality` set will be factored into the width
   */
  get width() {
    return Math.abs(this._getTotalWidth() * this.scale.x);
  }
  set width(value) {
    value /= Math.abs(this.scale.x);
    this._bitmap.width = value;
    this._originalWidth = value;
    this.flagDirty();
  }
  /**
   * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster
   * to be flagged dirty causing a re-raster on the next draw.
   *
   * Any `padding` or `quality` set will be factored into the height
   */
  get height() {
    return Math.abs(this._getTotalHeight() * this.scale.y);
  }
  set height(value) {
    value /= Math.abs(this.scale.y);
    this._bitmap.height = value;
    this._originalHeight = value;
    this.flagDirty();
  }
  _getTotalWidth() {
    var _a;
    return (((_a = this._originalWidth) != null ? _a : this._bitmap.width) + this.padding * 2) * 1;
  }
  _getTotalHeight() {
    var _a;
    return (((_a = this._originalHeight) != null ? _a : this._bitmap.height) + this.padding * 2) * 1;
  }
  /**
   * Returns the local bounds of the Raster including the padding
   */
  get localBounds() {
    return BoundingBox.fromDimension(this._getTotalWidth() * this.scale.x, this._getTotalHeight() * this.scale.y, Vector.Zero);
  }
  /**
   * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster
   * to be flagged dirty causing a re-raster on the next draw.
   */
  get smoothing() {
    return this._smoothing;
  }
  set smoothing(value) {
    this._smoothing = value;
    this.flagDirty();
  }
  /**
   * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be
   * flagged dirty causing a re-raster on the next draw.
   */
  get color() {
    return this._color;
  }
  set color(value) {
    this.flagDirty();
    this._color = watch(value, () => this.flagDirty());
  }
  /**
   * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be
   * flagged dirty causing a re-raster on the next draw.
   */
  get strokeColor() {
    return this._strokeColor;
  }
  set strokeColor(value) {
    this.flagDirty();
    if (value) {
      this._strokeColor = watch(value, () => this.flagDirty());
    }
  }
  /**
   * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be
   * flagged dirty causing a re-raster on the next draw.
   */
  get lineWidth() {
    return this._lineWidth;
  }
  set lineWidth(value) {
    this._lineWidth = value;
    this.flagDirty();
  }
  get lineDash() {
    return this._lineDash;
  }
  set lineDash(value) {
    this._lineDash = value;
    this.flagDirty();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
    this.flagDirty();
  }
  /**
   * Rasterize the graphic to a bitmap making it usable as in excalibur. Rasterize is called automatically if
   * the graphic is {@apilink Raster.dirty} on the next {@apilink Graphic.draw} call
   */
  rasterize() {
    this._dirty = false;
    this._ctx.clearRect(0, 0, this._getTotalWidth(), this._getTotalHeight());
    this._ctx.save();
    this._applyRasterProperties(this._ctx);
    this.execute(this._ctx);
    this._ctx.restore();
  }
  _applyRasterProperties(ctx) {
    var _a, _b, _c, _d;
    this._bitmap.width = this._getTotalWidth() * this.quality;
    this._bitmap.height = this._getTotalHeight() * this.quality;
    this._bitmap.setAttribute("filtering", this.filtering);
    this._bitmap.setAttribute("forceUpload", "true");
    ctx.scale(this.quality, this.quality);
    ctx.translate(this.padding, this.padding);
    ctx.imageSmoothingEnabled = this.smoothing;
    ctx.lineWidth = this.lineWidth;
    ctx.setLineDash((_a = this.lineDash) != null ? _a : ctx.getLineDash());
    ctx.lineCap = this.lineCap;
    ctx.strokeStyle = (_c = (_b = this.strokeColor) == null ? void 0 : _b.toString()) != null ? _c : "";
    ctx.fillStyle = (_d = this.color) == null ? void 0 : _d.toString();
  }
  _drawImage(ex, x, y) {
    if (this._dirty) {
      this.rasterize();
    }
    ex.scale(1 / this.quality, 1 / this.quality);
    ex.drawImage(this._bitmap, x, y);
  }
}
var FontUnit = /* @__PURE__ */ ((FontUnit2) => {
  FontUnit2["Em"] = "em";
  FontUnit2["Rem"] = "rem";
  FontUnit2["Px"] = "px";
  FontUnit2["Pt"] = "pt";
  FontUnit2["Percent"] = "%";
  return FontUnit2;
})(FontUnit || {});
var TextAlign = /* @__PURE__ */ ((TextAlign2) => {
  TextAlign2["Left"] = "left";
  TextAlign2["Right"] = "right";
  TextAlign2["Center"] = "center";
  TextAlign2["Start"] = "start";
  TextAlign2["End"] = "end";
  return TextAlign2;
})(TextAlign || {});
var BaseAlign = /* @__PURE__ */ ((BaseAlign2) => {
  BaseAlign2["Top"] = "top";
  BaseAlign2["Hanging"] = "hanging";
  BaseAlign2["Middle"] = "middle";
  BaseAlign2["Alphabetic"] = "alphabetic";
  BaseAlign2["Ideographic"] = "ideographic";
  BaseAlign2["Bottom"] = "bottom";
  return BaseAlign2;
})(BaseAlign || {});
var FontStyle = /* @__PURE__ */ ((FontStyle2) => {
  FontStyle2["Normal"] = "normal";
  FontStyle2["Italic"] = "italic";
  FontStyle2["Oblique"] = "oblique";
  return FontStyle2;
})(FontStyle || {});
var Direction = /* @__PURE__ */ ((Direction2) => {
  Direction2["LeftToRight"] = "ltr";
  Direction2["RightToLeft"] = "rtl";
  return Direction2;
})(Direction || {});
var ImageFiltering = /* @__PURE__ */ ((ImageFiltering2) => {
  ImageFiltering2["Pixel"] = "Pixel";
  ImageFiltering2["Blended"] = "Blended";
  return ImageFiltering2;
})(ImageFiltering || {});
function parseImageFiltering(val) {
  switch (val) {
    case "Pixel":
      return "Pixel";
    case "Blended":
      return "Blended";
    default:
      return void 0;
  }
}
function line(ctx, color = Color.Red, x1, y1, x2, y2, thickness = 1, cap = "butt") {
  ctx.save();
  ctx.beginPath();
  ctx.lineWidth = thickness;
  ctx.lineCap = cap;
  ctx.strokeStyle = color.toString();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function point(ctx, color = Color.Red, point2) {
  ctx.beginPath();
  ctx.strokeStyle = color.toString();
  ctx.arc(point2.x, point2.y, 5, 0, Math.PI * 2);
  ctx.closePath();
  ctx.stroke();
}
function vector(ctx, color, origin, vector2, scale = 1) {
  const c = color ? color.toString() : "blue";
  const v = vector2.scale(scale);
  ctx.beginPath();
  ctx.strokeStyle = c;
  ctx.moveTo(origin.x, origin.y);
  ctx.lineTo(origin.x + v.x, origin.y + v.y);
  ctx.closePath();
  ctx.stroke();
}
function roundRect(ctx, x, y, width, height, radius = 5, stroke = Color.White, fill = null) {
  let br;
  if (typeof radius === "number") {
    br = { tl: radius, tr: radius, br: radius, bl: radius };
  } else {
    const defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
    for (const prop in defaultRadius) {
      if (defaultRadius.hasOwnProperty(prop)) {
        const side = prop;
        br[side] = radius[side] || defaultRadius[side];
      }
    }
  }
  ctx.beginPath();
  ctx.moveTo(x + br.tl, y);
  ctx.lineTo(x + width - br.tr, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);
  ctx.lineTo(x + width, y + height - br.br);
  ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);
  ctx.lineTo(x + br.bl, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);
  ctx.lineTo(x, y + br.tl);
  ctx.quadraticCurveTo(x, y, x + br.tl, y);
  ctx.closePath();
  if (fill) {
    ctx.fillStyle = fill.toString();
    ctx.fill();
  }
  if (stroke) {
    ctx.strokeStyle = stroke.toString();
    ctx.stroke();
  }
}
function circle(ctx, x, y, radius, stroke = Color.White, fill = null) {
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.closePath();
  if (fill) {
    ctx.fillStyle = fill.toString();
    ctx.fill();
  }
  if (stroke) {
    ctx.strokeStyle = stroke.toString();
    ctx.stroke();
  }
}
const DrawUtil = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  circle,
  line,
  point,
  roundRect,
  vector
}, Symbol.toStringTag, { value: "Module" }));
class RentalPool {
  constructor(builder, cleaner, preAllocate = 1) {
    this.builder = builder;
    this.cleaner = cleaner;
    this._pool = [];
    this._size = 0;
    this.grow(preAllocate);
  }
  /**
   * Grow the pool size by an amount
   * @param amount
   */
  grow(amount) {
    if (amount > 0) {
      this._size += amount;
      for (let i = 0; i < amount; i++) {
        this._pool.push(this.builder());
      }
    }
  }
  /**
   * Rent an object from the pool, optionally clean it. If not cleaned previous state may be set.
   *
   * The pool will automatically double if depleted
   * @param clean
   */
  rent(clean = false) {
    if (this._pool.length === 0) {
      this.grow(this._size);
    }
    return clean ? this.cleaner(this._pool.pop()) : this._pool.pop();
  }
  /**
   * Return an object to the pool
   * @param object
   */
  return(object) {
    this._pool.push(object);
  }
}
class TransformStack {
  constructor() {
    this._pool = new RentalPool(
      () => AffineMatrix.identity(),
      (mat) => mat.reset(),
      100
    );
    this._transforms = [];
    this._currentTransform = this._pool.rent(true);
  }
  save() {
    this._transforms.push(this._currentTransform);
    this._currentTransform = this._currentTransform.clone(this._pool.rent());
  }
  restore() {
    this._pool.return(this._currentTransform);
    this._currentTransform = this._transforms.pop();
  }
  translate(x, y) {
    return this._currentTransform.translate(x, y);
  }
  rotate(angle) {
    return this._currentTransform.rotate(angle);
  }
  scale(x, y) {
    return this._currentTransform.scale(x, y);
  }
  reset() {
    this._currentTransform.reset();
  }
  set current(matrix) {
    this._currentTransform = matrix;
  }
  get current() {
    return this._currentTransform;
  }
}
class ContextState {
  constructor() {
    this.opacity = 1;
    this.z = 0;
    this.tint = Color.White;
    this.material = null;
  }
}
class StateStack {
  constructor() {
    this._pool = new RentalPool(
      () => new ContextState(),
      (s) => {
        s.opacity = 1;
        s.z = 0;
        s.tint = Color.White;
        s.material = null;
        return s;
      },
      100
    );
    this.current = this._pool.rent(true);
    this._states = [];
  }
  _cloneState(dest) {
    var _a;
    dest.opacity = this.current.opacity;
    dest.z = this.current.z;
    dest.tint = (_a = this.current.tint) == null ? void 0 : _a.clone();
    dest.material = this.current.material;
    return dest;
  }
  save() {
    this._states.push(this.current);
    this.current = this._cloneState(this._pool.rent());
  }
  restore() {
    this._pool.return(this.current);
    this.current = this._states.pop();
  }
}
const ResourceEvents = {
  Complete: "complete",
  Load: "load",
  LoadStart: "loadstart",
  Progress: "progress",
  Error: "error"
};
class Resource {
  /**
   * @param path          Path to the remote resource
   * @param responseType  The type to expect as a response: "" | "arraybuffer" | "blob" | "document" | "json" | "text";
   * @param bustCache     Whether or not to cache-bust requests
   */
  constructor(path, responseType, bustCache = false) {
    this.path = path;
    this.responseType = responseType;
    this.bustCache = bustCache;
    this.data = null;
    this.logger = Logger.getInstance();
    this.events = new EventEmitter();
  }
  /**
   * Returns true if the Resource is completely loaded and is ready
   * to be drawn.
   */
  isLoaded() {
    return this.data !== null;
  }
  _cacheBust(uri) {
    const query = /\?\w*=\w*/;
    if (query.test(uri)) {
      uri += "&__=" + Date.now();
    } else {
      uri += "?__=" + Date.now();
    }
    return uri;
  }
  /**
   * Begin loading the resource and returns a promise to be resolved on completion
   */
  load() {
    return new Promise((resolve, reject) => {
      if (this.data !== null) {
        this.logger.debug("Already have data for resource", this.path);
        this.events.emit("complete", this.data);
        resolve(this.data);
        return;
      }
      const request = new XMLHttpRequest();
      request.open("GET", this.bustCache ? this._cacheBust(this.path) : this.path, true);
      request.responseType = this.responseType;
      request.addEventListener("loadstart", (e) => this.events.emit("loadstart", e));
      request.addEventListener("progress", (e) => this.events.emit("progress", e));
      request.addEventListener("error", (e) => this.events.emit("error", e));
      request.addEventListener("load", (e) => this.events.emit("load", e));
      request.addEventListener("load", () => {
        if (request.status !== 0 && request.status !== 200) {
          this.logger.error("Failed to load resource ", this.path, " server responded with error code", request.status);
          this.events.emit("error", request.response);
          reject(new Error(request.statusText));
          return;
        }
        if (request.response instanceof Blob && request.response.type === "text/html") {
          const errorText = `Expected blob (usually image) data from the server when loading ${this.path}, but got HTML content instead!

Check your server configuration, for example Vite serves static files from the /public folder`;
          this.events.emit("error", request.response);
          reject(new Error(errorText));
          return;
        }
        this.data = request.response;
        this.events.emit("complete", this.data);
        this.logger.debug("Completed loading resource", this.path);
        resolve(this.data);
      });
      request.send();
    });
  }
}
class Sprite extends Graphic {
  constructor(options) {
    var _a, _b;
    super(options);
    this._logger = Logger.getInstance();
    this._dirty = true;
    this.image = options.image;
    const { width, height } = options;
    this.sourceView = (_a = options.sourceView) != null ? _a : { x: 0, y: 0, width: width != null ? width : 0, height: height != null ? height : 0 };
    this.destSize = (_b = options.destSize) != null ? _b : { width: width != null ? width : 0, height: height != null ? height : 0 };
    this._updateSpriteDimensions();
    this.image.ready.then(() => {
      this._updateSpriteDimensions();
    });
  }
  static from(image, options) {
    return new Sprite({
      image,
      ...options
    });
  }
  get width() {
    return Math.abs(this.destSize.width * this.scale.x);
  }
  get height() {
    return Math.abs(this.destSize.height * this.scale.y);
  }
  set width(newWidth) {
    newWidth /= Math.abs(this.scale.x);
    this.destSize.width = newWidth;
    super.width = Math.ceil(this.destSize.width);
  }
  set height(newHeight) {
    newHeight /= Math.abs(this.scale.y);
    this.destSize.height = newHeight;
    super.height = Math.ceil(this.destSize.height);
  }
  _updateSpriteDimensions() {
    var _a, _b, _c, _d, _e, _f;
    const { width: nativeWidth, height: nativeHeight } = this.image;
    this.sourceView.width = ((_a = this.sourceView) == null ? void 0 : _a.width) || nativeWidth;
    this.sourceView.height = ((_b = this.sourceView) == null ? void 0 : _b.height) || nativeHeight;
    this.destSize.width = ((_c = this.destSize) == null ? void 0 : _c.width) || ((_d = this.sourceView) == null ? void 0 : _d.width) || nativeWidth;
    this.destSize.height = ((_e = this.destSize) == null ? void 0 : _e.height) || ((_f = this.sourceView) == null ? void 0 : _f.height) || nativeHeight;
    this.width = Math.ceil(this.destSize.width) * this.scale.x;
    this.height = Math.ceil(this.destSize.height) * this.scale.y;
  }
  _preDraw(ex, x, y) {
    if (this.image.isLoaded() && this._dirty) {
      this._dirty = false;
      this._updateSpriteDimensions();
    }
    super._preDraw(ex, x, y);
  }
  _drawImage(ex, x, y) {
    if (this.image.isLoaded()) {
      ex.drawImage(
        this.image.image,
        this.sourceView.x,
        this.sourceView.y,
        this.sourceView.width,
        this.sourceView.height,
        x,
        y,
        this.destSize.width,
        this.destSize.height
      );
    } else {
      this._logger.warnOnce(
        `ImageSource ${this.image.path} is not yet loaded and won't be drawn. Please call .load() or include in a Loader.

Read https://excaliburjs.com/docs/imagesource for more information.`
      );
    }
  }
  clone() {
    return new Sprite({
      image: this.image,
      sourceView: { ...this.sourceView },
      destSize: { ...this.destSize },
      ...this.cloneGraphicOptions()
    });
  }
}
var ImageWrapping = /* @__PURE__ */ ((ImageWrapping2) => {
  ImageWrapping2["Clamp"] = "Clamp";
  ImageWrapping2["Repeat"] = "Repeat";
  ImageWrapping2["Mirror"] = "Mirror";
  return ImageWrapping2;
})(ImageWrapping || {});
function parseImageWrapping(val) {
  switch (val) {
    case "Clamp":
      return "Clamp";
    case "Repeat":
      return "Repeat";
    case "Mirror":
      return "Mirror";
    default:
      return "Clamp";
  }
}
const _TextureLoader = class _TextureLoader2 {
  constructor(gl, _garbageCollector) {
    this._garbageCollector = _garbageCollector;
    this._textureMap = /* @__PURE__ */ new Map();
    this._collect = (image) => {
      var _a2;
      if (this._gl) {
        const name = (_a2 = image.dataset.originalSrc) != null ? _a2 : image.constructor.name;
        _TextureLoader2._LOGGER.debug(`WebGL Texture for ${name} collected`);
        this.delete(image);
        return true;
      }
      return false;
    };
    var _a;
    this._gl = gl;
    _TextureLoader2._MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    if (this._garbageCollector) {
      _TextureLoader2._LOGGER.debug("WebGL Texture collection interval:", this._garbageCollector.collectionInterval);
      (_a = this._garbageCollector.garbageCollector) == null ? void 0 : _a.registerCollector("texture", this._garbageCollector.collectionInterval, this._collect);
    }
  }
  dispose() {
    for (const [image] of this._textureMap) {
      this.delete(image);
    }
    this._textureMap.clear();
    this._gl = null;
  }
  /**
   * Get the WebGL Texture from a source image
   * @param image
   */
  get(image) {
    return this._textureMap.get(image);
  }
  /**
   * Returns whether a source image has been loaded as a texture
   * @param image
   */
  has(image) {
    return this._textureMap.has(image);
  }
  /**
   * Loads a graphic into webgl and returns it's texture info, a webgl context must be previously registered
   * @param image Source graphic
   * @param options {ImageSourceOptions} Optionally configure the ImageFiltering and ImageWrapping mode to apply to the loaded texture
   * @param forceUpdate Optionally force a texture to be reloaded, useful if the source graphic has changed
   */
  load(image, options, forceUpdate = false) {
    var _a, _b;
    const gl = this._gl;
    if (!gl) {
      return null;
    }
    const { filtering, wrapping } = { ...options };
    let tex = null;
    if (this.has(image)) {
      tex = this.get(image);
    }
    if (tex) {
      if (forceUpdate) {
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      }
      (_a = this._garbageCollector) == null ? void 0 : _a.garbageCollector.touch(image);
      return tex;
    }
    tex = gl.createTexture();
    _TextureLoader2.checkImageSizeSupportedAndLog(image);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
    let wrappingConfig;
    if (wrapping) {
      if (typeof wrapping === "string") {
        wrappingConfig = {
          x: wrapping,
          y: wrapping
        };
      } else {
        wrappingConfig = {
          x: wrapping.x,
          y: wrapping.y
        };
      }
    }
    const { x: xWrap, y: yWrap } = wrappingConfig != null ? wrappingConfig : _TextureLoader2.wrapping;
    switch (xWrap) {
      case ImageWrapping.Clamp:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        break;
      case ImageWrapping.Repeat:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        break;
      case ImageWrapping.Mirror:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
        break;
      default:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    }
    switch (yWrap) {
      case ImageWrapping.Clamp:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        break;
      case ImageWrapping.Repeat:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        break;
      case ImageWrapping.Mirror:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
        break;
      default:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
    const filterMode = filtering != null ? filtering : _TextureLoader2.filtering;
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    this._textureMap.set(image, tex);
    (_b = this._garbageCollector) == null ? void 0 : _b.garbageCollector.addCollectableResource("texture", image);
    return tex;
  }
  delete(image) {
    const gl = this._gl;
    if (!gl) {
      return;
    }
    if (this.has(image)) {
      const texture = this.get(image);
      if (texture) {
        this._textureMap.delete(image);
        gl.deleteTexture(texture);
      }
    }
  }
  /**
   * Takes an image and returns if it meets size criteria for hardware
   * @param image
   * @returns if the image will be supported at runtime
   */
  static checkImageSizeSupportedAndLog(image) {
    var _a;
    const originalSrc = (_a = image.dataset.originalSrc) != null ? _a : "internal canvas bitmap";
    if (image.width > _TextureLoader2._MAX_TEXTURE_SIZE || image.height > _TextureLoader2._MAX_TEXTURE_SIZE) {
      _TextureLoader2._LOGGER.error(
        `The image [${originalSrc}] provided to Excalibur is too large for the device's maximum texture size of (${_TextureLoader2._MAX_TEXTURE_SIZE}x${_TextureLoader2._MAX_TEXTURE_SIZE}) please resize to an image for excalibur to render properly.

Images will likely render as black rectangles.

Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`
      );
      return false;
    } else if (image.width > 4096 || image.height > 4096) {
      _TextureLoader2._LOGGER.warn(
        `The image [${originalSrc}] provided to excalibur is too large may not work on all mobile devices, it is recommended you resize images to a maximum (4096x4096).

Images will likely render as black rectangles on some mobile platforms.

Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`
      );
    }
    return true;
  }
};
_TextureLoader._LOGGER = Logger.getInstance();
_TextureLoader.filtering = ImageFiltering.Blended;
_TextureLoader.wrapping = { x: ImageWrapping.Clamp, y: ImageWrapping.Clamp };
_TextureLoader._MAX_TEXTURE_SIZE = 4096;
let TextureLoader = _TextureLoader;
const ImageSourceAttributeConstants = {
  Filtering: "filtering",
  WrappingX: "wrapping-x",
  WrappingY: "wrapping-y"
};
class ImageSource {
  constructor(pathOrBase64, bustCacheOrOptions, filtering) {
    this._logger = Logger.getInstance();
    this.data = new Image();
    this._readyFuture = new Future();
    this.ready = this._readyFuture.promise;
    this.path = pathOrBase64;
    let bustCache = false;
    let wrapping;
    if (typeof bustCacheOrOptions === "boolean") {
      bustCache = bustCacheOrOptions;
    } else {
      ({ filtering, wrapping, bustCache } = { ...bustCacheOrOptions });
    }
    this._resource = new Resource(pathOrBase64, "blob", bustCache);
    this.filtering = filtering != null ? filtering : this.filtering;
    if (typeof wrapping === "string") {
      this.wrapping = {
        x: wrapping,
        y: wrapping
      };
    } else {
      this.wrapping = wrapping != null ? wrapping : this.wrapping;
    }
    if (pathOrBase64.endsWith(".gif")) {
      this._logger.warn(
        `Use the ex.Gif type to load gifs, you may have mixed results with ${pathOrBase64} in ex.ImageSource. Fully supported: svg, jpg, bmp, and png`
      );
    }
  }
  /**
   * The original size of the source image in pixels
   */
  get width() {
    return this.image.naturalWidth;
  }
  /**
   * The original height of the source image in pixels
   */
  get height() {
    return this.image.naturalHeight;
  }
  /**
   * Returns true if the Texture is completely loaded and is ready
   * to be drawn.
   */
  isLoaded() {
    if (!this._src) {
      this._src = this.data.src;
    }
    return !!this._src;
  }
  get image() {
    return this.data;
  }
  /**
   * Create an ImageSource from and HTML <image> tag element
   * @param image
   */
  static fromHtmlImageElement(image, options) {
    const imageSource = new ImageSource("");
    imageSource._src = "image-element";
    imageSource.data = image;
    imageSource.data.setAttribute("data-original-src", "image-element");
    if (options == null ? void 0 : options.filtering) {
      imageSource.data.setAttribute(ImageSourceAttributeConstants.Filtering, options == null ? void 0 : options.filtering);
    } else {
      imageSource.data.setAttribute(ImageSourceAttributeConstants.Filtering, ImageFiltering.Blended);
    }
    if (options == null ? void 0 : options.wrapping) {
      let wrapping;
      if (typeof options.wrapping === "string") {
        wrapping = {
          x: options.wrapping,
          y: options.wrapping
        };
      } else {
        wrapping = {
          x: options.wrapping.x,
          y: options.wrapping.y
        };
      }
      imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingX, wrapping.x);
      imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingY, wrapping.y);
    } else {
      imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingX, ImageWrapping.Clamp);
      imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingY, ImageWrapping.Clamp);
    }
    TextureLoader.checkImageSizeSupportedAndLog(image);
    imageSource._readyFuture.resolve(image);
    return imageSource;
  }
  static fromHtmlCanvasElement(image, options) {
    const imageSource = new ImageSource("");
    imageSource._src = "canvas-element-blob";
    imageSource.data.setAttribute("data-original-src", "canvas-element-blob");
    if (options == null ? void 0 : options.filtering) {
      imageSource.data.setAttribute(ImageSourceAttributeConstants.Filtering, options == null ? void 0 : options.filtering);
    } else {
      imageSource.data.setAttribute(ImageSourceAttributeConstants.Filtering, ImageFiltering.Blended);
    }
    if (options == null ? void 0 : options.wrapping) {
      let wrapping;
      if (typeof options.wrapping === "string") {
        wrapping = {
          x: options.wrapping,
          y: options.wrapping
        };
      } else {
        wrapping = {
          x: options.wrapping.x,
          y: options.wrapping.y
        };
      }
      imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingX, wrapping.x);
      imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingY, wrapping.y);
    } else {
      imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingX, ImageWrapping.Clamp);
      imageSource.data.setAttribute(ImageSourceAttributeConstants.WrappingY, ImageWrapping.Clamp);
    }
    TextureLoader.checkImageSizeSupportedAndLog(image);
    image.toBlob((blob) => {
      const url = URL.createObjectURL(blob);
      imageSource.image.onload = () => {
        URL.revokeObjectURL(url);
        imageSource.data = imageSource.image;
        imageSource._readyFuture.resolve(imageSource.image);
      };
      imageSource.image.src = url;
    });
    return imageSource;
  }
  static fromSvgString(svgSource, options) {
    const blob = new Blob([svgSource], { type: "image/svg+xml" });
    const url = URL.createObjectURL(blob);
    return new ImageSource(url, options);
  }
  /**
   * Should excalibur add a cache busting querystring? By default false.
   * Must be set before loading
   */
  get bustCache() {
    return this._resource.bustCache;
  }
  set bustCache(val) {
    this._resource.bustCache = val;
  }
  /**
   * Begins loading the image and returns a promise that resolves when the image is loaded
   */
  async load() {
    var _a, _b, _c, _d;
    if (this.isLoaded()) {
      return this.data;
    }
    try {
      let url;
      if (!this.path.includes("data:image/")) {
        const blob = await this._resource.load();
        url = URL.createObjectURL(blob);
      } else {
        url = this.path;
      }
      const image = new Image();
      const loadedFuture = new Future();
      image.onload = () => loadedFuture.resolve();
      image.src = url;
      image.setAttribute("data-original-src", this.path);
      await loadedFuture.promise;
      this.data = image;
      TextureLoader.checkImageSizeSupportedAndLog(this.data);
    } catch (error) {
      throw `Error loading ImageSource from path '${this.path}' with error [${error.message}]`;
    }
    this.data.setAttribute(ImageSourceAttributeConstants.Filtering, this.filtering);
    this.data.setAttribute(ImageSourceAttributeConstants.WrappingX, (_b = (_a = this.wrapping) == null ? void 0 : _a.x) != null ? _b : ImageWrapping.Clamp);
    this.data.setAttribute(ImageSourceAttributeConstants.WrappingY, (_d = (_c = this.wrapping) == null ? void 0 : _c.y) != null ? _d : ImageWrapping.Clamp);
    this._readyFuture.resolve(this.data);
    return this.data;
  }
  /**
   * Build a sprite from this ImageSource
   */
  toSprite(options) {
    return Sprite.from(this, options);
  }
  /**
   * Unload images from memory
   */
  unload() {
    this.data = new Image();
  }
}
class SpriteFont extends Graphic {
  constructor(options) {
    super(options);
    this._text = "";
    this.alphabet = "";
    this.shadow = void 0;
    this.caseInsensitive = false;
    this.spacing = 0;
    this.lineHeight = void 0;
    this._logger = Logger.getInstance();
    const { alphabet, spriteSheet, caseInsensitive, spacing, shadow, lineHeight } = options;
    this.alphabet = alphabet;
    this.spriteSheet = spriteSheet;
    this.caseInsensitive = caseInsensitive != null ? caseInsensitive : this.caseInsensitive;
    this.spacing = spacing != null ? spacing : this.spacing;
    this.shadow = shadow != null ? shadow : this.shadow;
    this.lineHeight = lineHeight != null ? lineHeight : this.lineHeight;
  }
  _getCharacterSprites(text) {
    const results = [];
    const textToRender = this.caseInsensitive ? text.toLocaleLowerCase() : text;
    const alphabet = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;
    for (let letterIndex = 0; letterIndex < textToRender.length; letterIndex++) {
      const letter = textToRender[letterIndex];
      let spriteIndex = alphabet.indexOf(letter);
      if (spriteIndex === -1) {
        spriteIndex = 0;
        this._logger.warnOnce(`SpriteFont - Cannot find letter '${letter}' in configured alphabet '${alphabet}'.`);
        this._logger.warnOnce("There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.");
      }
      const letterSprite = this.spriteSheet.sprites[spriteIndex];
      if (letterSprite) {
        results.push(letterSprite);
      } else {
        this._logger.warnOnce(`SpriteFont - Cannot find sprite for '${letter}' at index '${spriteIndex}' in configured SpriteSheet`);
        this._logger.warnOnce("There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.");
      }
    }
    return results;
  }
  measureText(text, maxWidth) {
    const lines = this._getLinesFromText(text, maxWidth);
    const maxWidthLine = lines.reduce((a, b) => {
      return a.length > b.length ? a : b;
    });
    const sprites = this._getCharacterSprites(maxWidthLine);
    let width = 0;
    let height = 0;
    for (const sprite of sprites) {
      width += sprite.width + this.spacing;
      height = Math.max(height, sprite.height);
    }
    return BoundingBox.fromDimension(width * this.scale.x, height * lines.length * this.scale.y, Vector.Zero);
  }
  _drawImage(ex, x, y, maxWidth) {
    var _a;
    let xCursor = 0;
    let yCursor = 0;
    let height = 0;
    const lines = this._getLinesFromText(this._text, maxWidth);
    for (const line2 of lines) {
      for (const sprite of this._getCharacterSprites(line2)) {
        sprite.draw(ex, x + xCursor, y + yCursor);
        xCursor += sprite.width + this.spacing;
        height = Math.max(height, sprite.height);
      }
      xCursor = 0;
      yCursor += (_a = this.lineHeight) != null ? _a : height;
    }
  }
  render(ex, text, _color, x, y, maxWidth) {
    this._text = text;
    const bounds = this.measureText(text, maxWidth);
    this.width = bounds.width;
    this.height = bounds.height;
    if (this.shadow) {
      ex.save();
      ex.translate(this.shadow.offset.x, this.shadow.offset.y);
      this._preDraw(ex, x, y);
      this._drawImage(ex, 0, 0, maxWidth);
      this._postDraw(ex);
      ex.restore();
    }
    this._preDraw(ex, x, y);
    this._drawImage(ex, 0, 0, maxWidth);
    this._postDraw(ex);
  }
  clone() {
    return new SpriteFont({
      alphabet: this.alphabet,
      spriteSheet: this.spriteSheet,
      spacing: this.spacing
    });
  }
  _getLinesFromText(text, maxWidth) {
    var _a;
    if (this._cachedText === text && this._cachedRenderWidth === maxWidth && ((_a = this._cachedLines) == null ? void 0 : _a.length)) {
      return this._cachedLines;
    }
    const lines = text.split("\n");
    if (maxWidth == null) {
      return lines;
    }
    for (let i = 0; i < lines.length; i++) {
      let line2 = lines[i];
      let newLine = "";
      if (this.measureText(line2).width > maxWidth) {
        while (this.measureText(line2).width > maxWidth) {
          newLine = line2[line2.length - 1] + newLine;
          line2 = line2.slice(0, -1);
        }
        lines[i] = line2;
        lines[i + 1] = newLine;
      }
    }
    this._cachedText = text;
    this._cachedLines = lines;
    this._cachedRenderWidth = maxWidth;
    return lines;
  }
}
class TiledSprite extends Sprite {
  constructor(options) {
    super({
      image: options.image,
      sourceView: options.sourceView,
      destSize: { width: options.width, height: options.height },
      flipHorizontal: options.flipHorizontal,
      flipVertical: options.flipVertical,
      rotation: options.rotation,
      scale: options.scale,
      opacity: options.opacity,
      tint: options.tint,
      origin: options.origin
    });
    this._ready = new Future();
    this.ready = this._ready.promise;
    this._options = options;
    if (this.image.isLoaded()) {
      this._applyTiling();
    } else {
      this.image.ready.then(() => this._applyTiling());
    }
  }
  static fromSprite(sprite, options) {
    return new TiledSprite({
      sourceView: { ...sprite.sourceView },
      width: sprite.width,
      height: sprite.height,
      ...options,
      image: sprite.image
    });
  }
  _applyTiling() {
    const { width, height, filtering, wrapping } = { ...this._options };
    const spriteCanvas = document.createElement("canvas");
    spriteCanvas.width = this.sourceView.width;
    spriteCanvas.height = this.sourceView.height;
    const spriteCtx = spriteCanvas.getContext("2d");
    spriteCtx.drawImage(
      this.image.image,
      this.sourceView.x,
      this.sourceView.y,
      this.sourceView.width,
      this.sourceView.height,
      0,
      0,
      this.sourceView.width,
      this.sourceView.height
    );
    const tiledImageSource = ImageSource.fromHtmlCanvasElement(spriteCanvas, {
      wrapping: wrapping != null ? wrapping : ImageWrapping.Repeat,
      filtering
    });
    if (width) {
      this.destSize.width = width;
      this.sourceView.width = width;
    }
    if (height) {
      this.destSize.height = height;
      this.sourceView.height = height;
    }
    this.sourceView.x = 0;
    this.sourceView.y = 0;
    this.image = tiledImageSource;
    this.image.ready.then(() => this._ready.resolve());
  }
}
class SpriteSheet {
  /**
   * Build a new sprite sheet from a list of sprites
   *
   * Use {@apilink SpriteSheet.fromImageSource} to create a SpriteSheet from an {@apilink ImageSource} organized in a grid
   * @param options
   */
  constructor(options) {
    this.sprites = [];
    const { sprites, rows, columns } = options;
    this.sprites = sprites;
    this.rows = rows != null ? rows : 1;
    this.columns = columns != null ? columns : this.sprites.length;
  }
  /**
   * Find a sprite by their x/y integer coordinates in the SpriteSheet, for example `getSprite(0, 0)` is the {@apilink Sprite} in the top-left
   * and `getSprite(1, 0)` is the sprite one to the right.
   * @param x
   * @param y
   */
  getSprite(x, y, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    if (x >= this.columns || x < 0) {
      throw Error(`No sprite exists in the SpriteSheet at (${x}, ${y}), x: ${x} should be between 0 and ${this.columns - 1} columns`);
    }
    if (y >= this.rows || y < 0) {
      throw Error(`No sprite exists in the SpriteSheet at (${x}, ${y}), y: ${y} should be between 0 and ${this.rows - 1} rows`);
    }
    const spriteIndex = x + y * this.columns;
    const sprite = this.sprites[spriteIndex];
    if (sprite) {
      if (options) {
        const spriteWithOptions = sprite.clone();
        spriteWithOptions.flipHorizontal = (_a = options.flipHorizontal) != null ? _a : spriteWithOptions.flipHorizontal;
        spriteWithOptions.flipVertical = (_b = options.flipVertical) != null ? _b : spriteWithOptions.flipVertical;
        spriteWithOptions.width = (_c = options.width) != null ? _c : spriteWithOptions.width;
        spriteWithOptions.height = (_d = options.height) != null ? _d : spriteWithOptions.height;
        spriteWithOptions.rotation = (_e = options.rotation) != null ? _e : spriteWithOptions.rotation;
        spriteWithOptions.scale = (_f = options.scale) != null ? _f : spriteWithOptions.scale;
        spriteWithOptions.opacity = (_g = options.opacity) != null ? _g : spriteWithOptions.opacity;
        spriteWithOptions.tint = (_h = options.tint) != null ? _h : spriteWithOptions.tint;
        spriteWithOptions.origin = (_i = options.origin) != null ? _i : spriteWithOptions.origin;
        return spriteWithOptions;
      }
      return sprite;
    }
    throw Error(`Invalid sprite coordinates (${x}, ${y})`);
  }
  /**
   * Find a sprite by their x/y integer coordinates in the SpriteSheet and configures tiling to repeat by default,
   * for example `getTiledSprite(0, 0)` is the {@apilink TiledSprite} in the top-left
   * and `getTiledSprite(1, 0)` is the sprite one to the right.
   *
   * Example:
   *
   * ```typescript
   * spriteSheet.getTiledSprite(1, 0, {
   * width: game.screen.width,
   * height: 200,
   * wrapping: {
   * x: ex.ImageWrapping.Repeat,
   * y: ex.ImageWrapping.Clamp
   * }
   * });
   * ```
   * @param x
   * @param y
   * @param options
   */
  getTiledSprite(x, y, options) {
    if (x >= this.columns || x < 0) {
      throw Error(`No sprite exists in the SpriteSheet at (${x}, ${y}), x: ${x} should be between 0 and ${this.columns - 1} columns`);
    }
    if (y >= this.rows || y < 0) {
      throw Error(`No sprite exists in the SpriteSheet at (${x}, ${y}), y: ${y} should be between 0 and ${this.rows - 1} rows`);
    }
    const spriteIndex = x + y * this.columns;
    const sprite = this.sprites[spriteIndex];
    if (sprite) {
      return TiledSprite.fromSprite(sprite, options);
    }
    throw Error(`Invalid sprite coordinates (${x}, ${y})`);
  }
  /**
   * Create a sprite sheet from a sparse set of {@apilink SourceView} rectangles
   * @param options
   */
  static fromImageSourceWithSourceViews(options) {
    const sprites = options.sourceViews.map((sourceView) => {
      return new Sprite({
        image: options.image,
        sourceView
      });
    });
    return new SpriteSheet({ sprites });
  }
  /**
   * Create a SpriteSheet from an {@apilink ImageSource} organized in a grid
   *
   * Example:
   * ```
   * const spriteSheet = SpriteSheet.fromImageSource({
   *   image: imageSource,
   *   grid: {
   *     rows: 5,
   *     columns: 2,
   *     spriteWidth: 32, // pixels
   *     spriteHeight: 32 // pixels
   *   },
   *   // Optionally specify spacing
   *   spacing: {
   *     // pixels from the top left to start the sprite parsing
   *     originOffset: {
   *       x: 5,
   *       y: 5
   *     },
   *     // pixels between each sprite while parsing
   *     margin: {
   *       x: 1,
   *       y: 1
   *     }
   *   }
   * })
   * ```
   * @param options
   */
  static fromImageSource(options) {
    var _a;
    const sprites = [];
    options.spacing = (_a = options.spacing) != null ? _a : {};
    const {
      image,
      grid: { rows, columns: cols, spriteWidth, spriteHeight },
      spacing: { originOffset, margin }
    } = options;
    let newmargin;
    let neworiginOffset;
    if (originOffset instanceof Vector) {
      neworiginOffset = { x: originOffset.x, y: originOffset.y };
    } else {
      if (originOffset) {
        neworiginOffset = { x: originOffset.x, y: originOffset.y };
      }
    }
    if (margin instanceof Vector) {
      newmargin = { x: margin.x, y: margin.y };
    } else {
      if (margin) {
        newmargin = { x: margin.x, y: margin.y };
      }
    }
    const offsetDefaults = { x: 0, y: 0, ...neworiginOffset };
    const marginDefaults = { x: 0, y: 0, ...newmargin };
    for (let x = 0; x < cols; x++) {
      for (let y = 0; y < rows; y++) {
        sprites[x + y * cols] = new Sprite({
          image,
          sourceView: {
            x: x * spriteWidth + marginDefaults.x * x + offsetDefaults.x,
            y: y * spriteHeight + marginDefaults.y * y + offsetDefaults.y,
            width: spriteWidth,
            height: spriteHeight
          },
          destSize: { height: spriteHeight, width: spriteWidth }
        });
      }
    }
    return new SpriteSheet({
      sprites,
      rows,
      columns: cols
    });
  }
  clone() {
    return new SpriteSheet({
      sprites: this.sprites.map((sprite) => sprite.clone()),
      rows: this.rows,
      columns: this.columns
    });
  }
}
const debugFont = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAABACAYAAAD1Xam+AAAAAXNSR0IArs4c6QAABlFJREFUeJztndmy4yoMRcWt/v9fdr8EWoDAaDD4JntVpeqcxBrMIGQDNhEAAAAAAAAAAAAAAOCrSbMfr+u6yoEpTY+906GV57YtPkjyXj9WZZ+wHWHfo2N3/bU6Tte9Rv6ptruqRyMvKvvIX/zY3I/vjLeqsg6l/CWdp0KHKO/1Y1H2EdsR9j06Ntdfp+N03SvkH2u7i3pu5XkQ+DNTkgNJSok+/183xpcdWZHjgUzpQ2pGD67vaf//KRAGAq3tdhCy2tcMQKPyXyz7iPqrdBjbX5h9g7xbtvWf4ZJvM4D/BKG24Sd+IkQ0TC9aW5NM5FbO2HgrPVzW2vmN50DZNv/QWtl5bfPy85SBtdy9dFmjsf2F2SehTBVE+u+tkE5+lAGcJlFwGuodwRRU2Qe3rx0FhPNflc3HWC7BEh8EDGVR5IMCiLnDONtPp87qhxVH/S/LvzUAuDs/kyGimA5oSONKR1w8vsLpv+v+S9vhmS71JRiX1xB5CWZNw7m6rMrllMag/RJyWb67BEgpDVMWSydc+K47pr35w05kWd7ReEq6116KaG4CsbJ7OmV9PdZLEKkONiC1/7ZONVgDsajLIJPYp2OUAXRpnPcGmnIE6eSK4nv5YQqqSYO52JqnYfYj/PdQXQIY7XszuMofMgZRT/1LdeC5h2I5/0EdWDMY2Yb05WDE1RodVdpSA5r85slArAVnSf+89iP896St0f5bZKVA7Gk/3ja8q+152/+wrLqBWZTem3IBADbRBoDuHgAA4HdAAADgh0EAAOCHQQAA4IdBAADgh0EAAOCHuVsKbJ3P9M7jjuxHzGfv8j9iDt47Dx7hP8cjq5F/o/0T62Aer//ZOgDrajBp6aNlOWTEajKLjgj/Pcs/vfZD/a++3Pc8hNfZ966EVeh5vP75luDRJUAl0KzJfnopaqbaTuzZiulc2BS5lltFXntu3dcQsXadl59Wn1H+dfYNtrt2d6D/LDF9HkCQw6eXFbr8P9X5W/un5Ol8gz1t39p5pWOPn0vLynbgdnfe8maEQw+UIPJdfxdOd/4oTtVD0IYg8wDywGas0I04T5O3P8/qf2UWwPpkn1PbOT1bN2tFe59EM7TvKf+TRFw+erZ2ey4hpS3hp9qBkqq/tjsSU1OYqucBWB1yynt5QxC42Mdk30pAEIio//zRG3feBzLUX+TTjCKwlH83aI/KbpQBVEHgUGF0j/SitcLofHem8q6AyH0wBhFv4WszuOjy0yK2vc/oRWQoP2X9ve78jfaLnpncbBqQSC6s0HnIRT0a2yNZjfxT8+ir8t+yDsDTWaS6X70GP33+d77stp+I5HtBdwEAAPBl8ECApcAA/DBvfSowAGAB7/05ZAAA/DAIAADMMU3fOuS2ggAAwBjrorKoxWiPBxHMAgAg490Ts0VeePdA+ZfJDKcCh7sBqY88mmjklZeOt9iXPrvx2I2QPRnN2/qzyJ84h4gNcbtfasq5mM1rZr+bBWh2A+bIIX13Z9wqL+nQvFno7v3oq4tJItCed7isUT6C/I7BUn9KP95wDicYBYpcjncrO2c/dmW4tBtw4RiRld1IDxDyYsoXMHxF1w3dyz0Nne8033AOFsT6VgRCafl89fenTZUfbm8CGhrgdDcS7anAsvnkkP0IeCfQ+JzYunky6jhNYj5bl7++4fJvN9WDSKS/292A0wyANyKDI91bfkm3kcH7ckaP/SKW/VHKRZAcI14pP3beu0fPyn/DuZQbWMogNnsc16sziE96f7H/iai7uTf0/3N8lwFz/e13T00Djt4OrInCnkeChXT+qOcKOLA21tJpsv/G8/COnGnw97J9QwbTvd6djYSv7fxEVTuV/LzNhj7nOawv6bfbAGCYEpQ6HxFtuxs6sq9tzOYHobQ6Nje+6vo5BwFrPZ4OgMayS4PPt1NlzdLfbRCYBoBc+NaO4JWPwLEf33oN3unY3InKPQBW6Z7nEZzEmrl4iZjC804lqgePPEOguQcwWghUphxm343wyt/pWpWR0OrR+jvyxavHajfb9pTjbt9bH07Z5/expM4TLWfwb7QQqMoC+UDWXZo/4RgA38LOgUvLJAAQ1Td9y9//0ylxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB+g79apuVUsS5ZmwAAAABJRU5ErkJggg==";
class DebugText {
  constructor() {
    this.fontSheet = debugFont;
    this.size = 16;
    this.load();
  }
  load() {
    this._imageSource = new ImageSource(this.fontSheet);
    return this._imageSource.load().then(() => {
      this._spriteSheet = SpriteSheet.fromImageSource({
        image: this._imageSource,
        grid: {
          rows: 4,
          columns: 16,
          spriteWidth: 16,
          spriteHeight: 16
        }
      });
      this._spriteFont = new SpriteFont({
        alphabet: `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,!'&."?-()+# `,
        caseInsensitive: true,
        spriteSheet: this._spriteSheet,
        spacing: -6
      });
    });
  }
  /**
   * Writes debug text using the built in sprint font
   * @param ctx
   * @param text
   * @param pos
   */
  write(ctx, text, pos) {
    if (this._imageSource.isLoaded()) {
      this._spriteFont.render(ctx, text, null, pos.x, pos.y);
    }
  }
}
class RenderSource {
  constructor(_gl, _texture) {
    this._gl = _gl;
    this._texture = _texture;
  }
  use() {
    const gl = this._gl;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this._texture);
  }
  disable() {
    const gl = this._gl;
    gl.bindTexture(gl.TEXTURE_2D, null);
  }
}
class RenderTarget {
  constructor(options) {
    this.antialias = false;
    this.samples = 1;
    var _a, _b;
    this._gl = options.gl;
    this.width = options.width;
    this.height = options.height;
    this.transparency = options.transparency;
    this.antialias = (_a = options.antialias) != null ? _a : this.antialias;
    this.samples = (_b = options.samples) != null ? _b : this._gl.getParameter(this._gl.MAX_SAMPLES);
    const gl = this._gl;
    if (gl.drawingBufferFormat) {
      this.bufferFormat = gl.drawingBufferFormat;
    } else {
      if (this.transparency) {
        this.bufferFormat = gl.RGBA8;
      } else {
        this.bufferFormat = gl.RGB8;
      }
    }
    this._setupRenderBuffer();
    this._setupFramebuffer();
  }
  setResolution(width, height) {
    const gl = this._gl;
    this.width = width;
    this.height = height;
    gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    if (this._renderBuffer) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, this._renderBuffer);
      gl.renderbufferStorageMultisample(
        gl.RENDERBUFFER,
        Math.min(this.samples, gl.getParameter(gl.MAX_SAMPLES)),
        this.bufferFormat,
        this.width,
        this.height
      );
    }
  }
  get renderBuffer() {
    return this._renderBuffer;
  }
  get renderFrameBuffer() {
    return this._renderFrameBuffer;
  }
  get frameBuffer() {
    return this._frameBuffer;
  }
  get frameTexture() {
    return this._frameTexture;
  }
  _setupRenderBuffer() {
    if (this.antialias) {
      const gl = this._gl;
      this._renderBuffer = gl.createRenderbuffer();
      this._renderFrameBuffer = gl.createFramebuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, this._renderBuffer);
      gl.renderbufferStorageMultisample(
        gl.RENDERBUFFER,
        Math.min(this.samples, gl.getParameter(gl.MAX_SAMPLES)),
        this.bufferFormat,
        this.width,
        this.height
      );
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._renderFrameBuffer);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this._renderBuffer);
    }
  }
  _setupFramebuffer() {
    const gl = this._gl;
    this._frameTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    const attachmentPoint = gl.COLOR_ATTACHMENT0;
    this._frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, this._frameTexture, 0);
    this.disable();
  }
  toRenderSource() {
    if (this.renderBuffer) {
      this.blitRenderBufferToFrameBuffer();
    }
    const source = new RenderSource(this._gl, this._frameTexture);
    return source;
  }
  blitToScreen() {
    const gl = this._gl;
    if (this._renderBuffer) {
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.renderFrameBuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      gl.clearBufferfv(gl.COLOR, 0, [0, 0, 1, 1]);
      gl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, gl.COLOR_BUFFER_BIT, gl.LINEAR);
    } else {
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.frameBuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      gl.clearBufferfv(gl.COLOR, 0, [0, 0, 1, 1]);
      gl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, gl.COLOR_BUFFER_BIT, gl.LINEAR);
    }
  }
  blitRenderBufferToFrameBuffer() {
    if (this._renderBuffer) {
      const gl = this._gl;
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.renderFrameBuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBuffer);
      gl.clearBufferfv(gl.COLOR, 0, [0, 0, 1, 1]);
      gl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, gl.COLOR_BUFFER_BIT, gl.LINEAR);
    }
  }
  copyToTexture(texture) {
    const gl = this._gl;
    if (this._renderBuffer) {
      this.blitRenderBufferToFrameBuffer();
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, this.width, this.height, 0);
  }
  /**
   * When called, all drawing gets redirected to this render target
   */
  use() {
    const gl = this._gl;
    if (this.antialias) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._renderFrameBuffer);
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    }
    gl.viewport(0, 0, this.width, this.height);
  }
  /**
   * When called, all drawing is sent back to the canvas
   */
  disable() {
    const gl = this._gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }
}
const lineVertexSource = "#version 300 es\nin vec2 a_position;\nin vec4 a_color;\n\nout lowp vec4 v_color;\n\nuniform mat4 u_matrix;\n\nvoid main() {\n   // Set the vertex position using the ortho transform matrix\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\n\n   // Passthrough the color\n   v_color = a_color;\n}";
const lineFragmentSource = "#version 300 es\nprecision mediump float;\n\n// Color\nin lowp vec4 v_color;\n\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = v_color;\n}";
class Line extends Graphic {
  constructor(options) {
    super();
    this.color = Color.Black;
    this.thickness = 1;
    const { start, end, color, thickness } = options;
    this.start = start;
    this.end = end;
    this.color = color != null ? color : this.color;
    this.thickness = thickness != null ? thickness : this.thickness;
    this._localBounds = this._calculateBounds();
    const { width, height } = this._localBounds;
    this.width = width;
    this.height = height;
  }
  get localBounds() {
    return this._localBounds;
  }
  _calculateBounds() {
    const lineNormal = this.end.sub(this.start).normal();
    const halfThickness = this.thickness / 2;
    const points = [
      this.start.add(lineNormal.scale(halfThickness)),
      this.end.add(lineNormal.scale(halfThickness)),
      this.end.add(lineNormal.scale(-halfThickness)),
      this.start.add(lineNormal.scale(-halfThickness))
    ];
    return BoundingBox.fromPoints(points);
  }
  _drawImage(ctx, _x, _y) {
    ctx.drawLine(this.start, this.end, this.color, this.thickness);
  }
  clone() {
    return new Line({
      start: this.start,
      end: this.end,
      color: this.color,
      thickness: this.thickness
    });
  }
}
class DebugGraphicsComponent extends Component {
  constructor(draw, useTransform = true) {
    super();
    this.draw = draw;
    this.useTransform = useTransform;
  }
}
class ParallaxComponent extends Component {
  constructor(parallaxFactor) {
    super();
    this.parallaxFactor = vec(1, 1);
    this.parallaxFactor = parallaxFactor != null ? parallaxFactor : this.parallaxFactor;
  }
}
const _FontCache = class _FontCache2 {
  static measureText(text, font, maxWidth) {
    const hash = FontTextInstance.getHashCode(font, text);
    if (_FontCache2._MEASURE_CACHE.has(hash)) {
      return _FontCache2._MEASURE_CACHE.get(hash);
    }
    _FontCache2._LOGGER.debug("Font text measurement cache miss");
    const measurement = font.measureTextWithoutCache(text, maxWidth);
    _FontCache2._MEASURE_CACHE.set(hash, measurement);
    return measurement;
  }
  static getTextInstance(text, font, color) {
    const hash = FontTextInstance.getHashCode(font, text, color);
    let textInstance = _FontCache2._TEXT_CACHE.get(hash);
    if (!textInstance) {
      textInstance = new FontTextInstance(font, text, color);
      _FontCache2._TEXT_CACHE.set(hash, textInstance);
      _FontCache2._LOGGER.debug("Font text instance cache miss");
    }
    _FontCache2._TEXT_USAGE.set(textInstance, performance.now());
    return textInstance;
  }
  static checkAndClearCache() {
    const deferred = [];
    const currentHashCodes = /* @__PURE__ */ new Set();
    for (const [textInstance, time] of _FontCache2._TEXT_USAGE.entries()) {
      if (time + _FontCache2.FONT_TIMEOUT < performance.now()) {
        _FontCache2._LOGGER.debug(`Text cache entry timed out ${textInstance.text}`);
        deferred.push(textInstance);
        textInstance.dispose();
      } else {
        const hash = textInstance.getHashCode(false);
        currentHashCodes.add(hash);
      }
    }
    deferred.forEach((t) => {
      _FontCache2._TEXT_USAGE.delete(t);
    });
    this._TEXT_CACHE.clear();
    for (const [textInstance] of this._TEXT_USAGE.entries()) {
      this._TEXT_CACHE.set(textInstance.getHashCode(), textInstance);
    }
    const newTextMeasurementCache = /* @__PURE__ */ new Map();
    for (const current of currentHashCodes) {
      if (_FontCache2._MEASURE_CACHE.has(current)) {
        newTextMeasurementCache.set(current, _FontCache2._MEASURE_CACHE.get(current));
      }
    }
    this._MEASURE_CACHE.clear();
    this._MEASURE_CACHE = newTextMeasurementCache;
  }
  static get cacheSize() {
    return _FontCache2._TEXT_USAGE.size;
  }
  /**
   * Force clear all cached text bitmaps
   */
  static clearCache() {
    for (const [textInstance] of _FontCache2._TEXT_USAGE.entries()) {
      textInstance.dispose();
    }
    _FontCache2._TEXT_USAGE.clear();
    _FontCache2._TEXT_CACHE.clear();
    _FontCache2._MEASURE_CACHE.clear();
  }
};
_FontCache.FONT_TIMEOUT = 500;
_FontCache._LOGGER = Logger.getInstance();
_FontCache._TEXT_USAGE = /* @__PURE__ */ new Map();
_FontCache._TEXT_CACHE = /* @__PURE__ */ new Map();
_FontCache._MEASURE_CACHE = /* @__PURE__ */ new Map();
let FontCache = _FontCache;
function blendTransform(oldTx, newTx, blend, target) {
  if (oldTx.parent !== newTx.parent) {
    const oldTxWithNewParent = oldTx.clone();
    const oldGlobalPos = oldTx.globalPos.clone();
    const oldGlobalScale = oldTx.globalScale.clone();
    const oldGlobalRotation = oldTx.globalRotation;
    oldTxWithNewParent.parent = newTx.parent;
    oldTxWithNewParent.globalPos = oldGlobalPos;
    oldTxWithNewParent.globalScale = oldGlobalScale;
    oldTxWithNewParent.globalRotation = oldGlobalRotation;
    oldTx = oldTxWithNewParent;
  }
  let interpolatedPos = newTx.pos;
  let interpolatedScale = newTx.scale;
  let interpolatedRotation = newTx.rotation;
  interpolatedPos = newTx.pos.scale(blend).add(oldTx.pos.scale(1 - blend));
  interpolatedScale = newTx.scale.scale(blend).add(oldTx.scale.scale(1 - blend));
  const cosine = (1 - blend) * Math.cos(oldTx.rotation) + blend * Math.cos(newTx.rotation);
  const sine = (1 - blend) * Math.sin(oldTx.rotation) + blend * Math.sin(newTx.rotation);
  interpolatedRotation = Math.atan2(sine, cosine);
  const tx = target != null ? target : new Transform();
  tx.setTransform(interpolatedPos, interpolatedRotation, interpolatedScale);
  return tx;
}
class GraphicsSystem extends System {
  constructor(world) {
    super();
    this.world = world;
    this.systemType = SystemType.Draw;
    this._token = 0;
    this._sortedTransforms = [];
    this._zHasChanged = false;
    this._zIndexUpdate = () => {
      this._zHasChanged = true;
    };
    this._targetInterpolationTransform = new Transform();
    this.query = this.world.query([TransformComponent, GraphicsComponent]);
    this.query.entityAdded$.subscribe((e) => {
      const tx = e.get(TransformComponent);
      this._sortedTransforms.push(tx);
      tx.zIndexChanged$.subscribe(this._zIndexUpdate);
      this._zHasChanged = true;
    });
    this.query.entityRemoved$.subscribe((e) => {
      const tx = e.get(TransformComponent);
      tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);
      const index = this._sortedTransforms.indexOf(tx);
      if (index > -1) {
        this._sortedTransforms.splice(index, 1);
      }
    });
  }
  get sortedTransforms() {
    return this._sortedTransforms;
  }
  initialize(world, scene) {
    this._camera = scene.camera;
    this._engine = scene.engine;
  }
  preupdate() {
    this._graphicsContext = this._engine.graphicsContext;
    if (this._zHasChanged) {
      this._sortedTransforms.sort((a, b) => {
        return a.globalZ - b.globalZ;
      });
      this._zHasChanged = false;
    }
  }
  update(elapsed) {
    this._token++;
    let graphics;
    FontCache.checkAndClearCache();
    this._graphicsContext.save();
    if (this._camera) {
      this._camera.draw(this._graphicsContext);
    }
    for (let transformIndex = 0; transformIndex < this._sortedTransforms.length; transformIndex++) {
      const transform = this._sortedTransforms[transformIndex];
      const entity = transform.owner;
      if (entity.hasTag("ex.offscreen")) {
        continue;
      }
      graphics = entity.get(GraphicsComponent);
      if (!graphics.isVisible) {
        continue;
      }
      if (graphics.onPreTransformDraw) {
        graphics.onPreTransformDraw(this._graphicsContext, elapsed);
      }
      entity.events.emit("pretransformdraw", new PreTransformDrawEvent(this._graphicsContext, elapsed, entity));
      if (transform.coordPlane === CoordPlane.Screen) {
        this._graphicsContext.restore();
      }
      this._graphicsContext.save();
      if (transform.coordPlane === CoordPlane.Screen) {
        this._graphicsContext.translate(this._engine.screen.contentArea.left, this._engine.screen.contentArea.top);
      }
      graphics.update(elapsed, this._token);
      const parallax = entity.get(ParallaxComponent);
      if (parallax) {
        const oneMinusFactor = Vector.One.sub(parallax.parallaxFactor);
        const parallaxOffset = this._camera.drawPos.scale(oneMinusFactor);
        this._graphicsContext.translate(parallaxOffset.x, parallaxOffset.y);
      }
      this._applyTransform(entity);
      if (graphics.material) {
        this._graphicsContext.material = graphics.material;
      }
      if (graphics.onPreDraw) {
        graphics.onPreDraw(this._graphicsContext, elapsed);
      }
      entity.events.emit("predraw", new PreDrawEvent(this._graphicsContext, elapsed, entity));
      this._applyOpacity(entity);
      this._drawGraphicsComponent(graphics, transform);
      if (graphics.onPostDraw) {
        graphics.onPostDraw(this._graphicsContext, elapsed);
      }
      entity.events.emit("postdraw", new PostDrawEvent(this._graphicsContext, elapsed, entity));
      this._graphicsContext.restore();
      if (transform.coordPlane === CoordPlane.Screen) {
        this._graphicsContext.save();
        if (this._camera) {
          this._camera.draw(this._graphicsContext);
        }
      }
      if (graphics.onPostTransformDraw) {
        graphics.onPostTransformDraw(this._graphicsContext, elapsed);
      }
      entity.events.emit("posttransformdraw", new PostTransformDrawEvent(this._graphicsContext, elapsed, entity));
    }
    this._graphicsContext.restore();
  }
  _drawGraphicsComponent(graphicsComponent, transformComponent) {
    var _a, _b;
    if (graphicsComponent.isVisible) {
      const flipHorizontal = graphicsComponent.flipHorizontal;
      const flipVertical = graphicsComponent.flipVertical;
      const graphic = graphicsComponent.current;
      const options = (_a = graphicsComponent.currentOptions) != null ? _a : {};
      if (graphic) {
        let anchor = graphicsComponent.anchor;
        let offset = graphicsComponent.offset;
        let scaleX = 1;
        let scaleY = 1;
        if (options == null ? void 0 : options.anchor) {
          anchor = options.anchor;
        }
        if (options == null ? void 0 : options.offset) {
          offset = options.offset;
        }
        const globalScale = transformComponent.globalScale;
        scaleX *= graphic.scale.x * globalScale.x;
        scaleY *= graphic.scale.y * globalScale.y;
        const offsetX = -graphic.width * anchor.x + offset.x * scaleX;
        const offsetY = -graphic.height * anchor.y + offset.y * scaleY;
        const oldFlipHorizontal = graphic.flipHorizontal;
        const oldFlipVertical = graphic.flipVertical;
        if (flipHorizontal || flipVertical) {
          graphic.flipHorizontal = flipHorizontal ? !oldFlipHorizontal : oldFlipHorizontal;
          graphic.flipVertical = flipVertical ? !oldFlipVertical : oldFlipVertical;
        }
        graphic == null ? void 0 : graphic.draw(this._graphicsContext, offsetX, offsetY);
        if (flipHorizontal || flipVertical) {
          graphic.flipHorizontal = oldFlipHorizontal;
          graphic.flipVertical = oldFlipVertical;
        }
        if (((_b = this._engine) == null ? void 0 : _b.isDebug) && this._engine.debug.graphics.showBounds) {
          const offset2 = vec(offsetX, offsetY);
          if (graphic instanceof GraphicsGroup) {
            for (const member of graphic.members) {
              let g;
              let pos = Vector.Zero;
              if (member instanceof Graphic) {
                g = member;
              } else {
                g = member.graphic;
                pos = member.offset;
              }
              if (graphic.useAnchor) {
                g == null ? void 0 : g.localBounds.translate(offset2.add(pos)).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
              } else {
                g == null ? void 0 : g.localBounds.translate(pos).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
              }
            }
          } else {
            graphic == null ? void 0 : graphic.localBounds.translate(offset2).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
          }
        }
      }
    }
  }
  /**
   * This applies the current entity transform to the graphics context
   * @param entity
   */
  _applyTransform(entity) {
    const ancestors = entity.getAncestors();
    for (let i = 0; i < ancestors.length; i++) {
      const ancestor = ancestors[i];
      const transform = ancestor == null ? void 0 : ancestor.get(TransformComponent);
      const optionalBody = ancestor == null ? void 0 : ancestor.get(BodyComponent);
      if (transform) {
        let tx = transform.get();
        if (optionalBody) {
          if (this._engine.fixedUpdateTimestep && optionalBody.__oldTransformCaptured && optionalBody.enableFixedUpdateInterpolate) {
            const blend = this._engine.currentFrameLagMs / this._engine.fixedUpdateTimestep;
            tx = blendTransform(optionalBody.oldTransform, transform.get(), blend, this._targetInterpolationTransform);
          }
        }
        this._graphicsContext.z = transform.globalZ;
        this._graphicsContext.translate(tx.pos.x, tx.pos.y);
        this._graphicsContext.scale(tx.scale.x, tx.scale.y);
        this._graphicsContext.rotate(tx.rotation);
      }
    }
  }
  _applyOpacity(entity) {
    var _a;
    const ancestors = entity.getAncestors();
    for (let i = 0; i < ancestors.length; i++) {
      const ancestor = ancestors[i];
      const maybeGraphics = ancestor == null ? void 0 : ancestor.get(GraphicsComponent);
      this._graphicsContext.opacity *= (_a = maybeGraphics == null ? void 0 : maybeGraphics.opacity) != null ? _a : 1;
    }
  }
}
GraphicsSystem.priority = SystemPriority.Average;
class OffscreenSystem extends System {
  constructor(world) {
    super();
    this.world = world;
    this.systemType = SystemType.Draw;
    this.query = this.world.query([TransformComponent, GraphicsComponent]);
  }
  initialize(world, scene) {
    this._camera = scene.camera;
    this._screen = scene.engine.screen;
  }
  update() {
    this._worldBounds = this._screen.getWorldBounds();
    let transform;
    let graphics;
    let maybeParallax;
    for (let i = 0; i < this.query.entities.length; i++) {
      const entity = this.query.entities[i];
      graphics = entity.get(GraphicsComponent);
      transform = entity.get(TransformComponent);
      maybeParallax = entity.get(ParallaxComponent);
      let parallaxOffset;
      if (maybeParallax) {
        const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);
        parallaxOffset = this._camera.pos.scale(oneMinusFactor);
      }
      const entityOffscreen = this._isOffscreen(transform, graphics, parallaxOffset);
      if (entityOffscreen && !entity.hasTag("ex.offscreen")) {
        entity.events.emit("exitviewport", new ExitViewPortEvent(entity));
        entity.addTag("ex.offscreen");
      }
      if (!entityOffscreen && entity.hasTag("ex.offscreen")) {
        entity.events.emit("enterviewport", new EnterViewPortEvent(entity));
        entity.removeTag("ex.offscreen");
      }
    }
  }
  _isOffscreen(transform, graphics, parallaxOffset) {
    if (graphics.forceOnScreen) {
      return false;
    }
    if (transform.coordPlane === CoordPlane.World) {
      let bounds = graphics.localBounds;
      if (parallaxOffset) {
        bounds = bounds.translate(parallaxOffset);
      }
      const transformedBounds = bounds.transform(transform.get().matrix);
      const graphicsOffscreen = !this._worldBounds.overlaps(transformedBounds);
      return graphicsOffscreen;
    } else {
      return false;
    }
  }
}
OffscreenSystem.priority = SystemPriority.Higher;
class Circle extends Raster {
  constructor(options) {
    var _a, _b, _c;
    super(options);
    this._radius = 0;
    const lineWidth = (_a = options.lineWidth) != null ? _a : options.strokeColor ? 1 : 0;
    this.padding = (_b = options.padding) != null ? _b : 2 + lineWidth / 2;
    this.radius = options.radius;
    this.filtering = (_c = options.filtering) != null ? _c : ImageFiltering.Blended;
    this.rasterize();
  }
  get radius() {
    return this._radius;
  }
  set radius(value) {
    this._radius = value;
    this.width = this._radius * 2;
    this.height = this._radius * 2;
    this.flagDirty();
  }
  clone() {
    return new Circle({
      radius: this.radius,
      ...this.cloneGraphicOptions(),
      ...this.cloneRasterOptions()
    });
  }
  execute(ctx) {
    if (this.radius > 0) {
      ctx.beginPath();
      ctx.arc(this.radius, this.radius, this.radius, 0, Math.PI * 2);
      if (this.color) {
        ctx.fill();
      }
      if (this.strokeColor) {
        ctx.stroke();
      }
    }
  }
}
class Rectangle extends Raster {
  constructor(options) {
    super(options);
    this.width = options.width;
    this.height = options.height;
    this.rasterize();
  }
  clone() {
    return new Rectangle({
      width: this.width,
      height: this.height,
      ...this.cloneGraphicOptions(),
      ...this.cloneRasterOptions()
    });
  }
  execute(ctx) {
    if (this.color) {
      ctx.fillRect(0, 0, this.width, this.height);
    }
    if (this.strokeColor) {
      ctx.strokeRect(0, 0, this.width, this.height);
    }
  }
}
class Polygon extends Raster {
  constructor(options) {
    super(options);
    this._points = [];
    this.points = options.points;
    this.filtering = ImageFiltering.Blended;
    this.rasterize();
  }
  get points() {
    return this._points;
  }
  set points(points) {
    this._points = points;
    const min = this.minPoint;
    this.width = this._points.reduce((max, p) => Math.max(p.x, max), 0) - min.x;
    this.height = this._points.reduce((max, p) => Math.max(p.y, max), 0) - min.y;
    this.flagDirty();
  }
  get minPoint() {
    const minX = this._points.reduce((min, p) => Math.min(p.x, min), Infinity);
    const minY = this._points.reduce((min, p) => Math.min(p.y, min), Infinity);
    return vec(minX, minY);
  }
  clone() {
    return new Polygon({
      points: this.points.map((p) => p.clone()),
      ...this.cloneGraphicOptions(),
      ...this.cloneRasterOptions()
    });
  }
  execute(ctx) {
    if (this.points && this.points.length) {
      ctx.beginPath();
      const min = this.minPoint.negate();
      const firstPoint = this.points[0].add(min);
      ctx.moveTo(firstPoint.x, firstPoint.y);
      this.points.forEach((point2) => {
        ctx.lineTo(point2.x + min.x, point2.y + min.y);
      });
      ctx.lineTo(firstPoint.x, firstPoint.y);
      ctx.closePath();
      if (this.color) {
        ctx.fill();
      }
      if (this.strokeColor) {
        ctx.stroke();
      }
    }
  }
}
class Canvas extends Raster {
  constructor(_options = {}) {
    super(_options);
    this._options = _options;
  }
  /**
   * Return the 2D graphics context of this canvas
   */
  get ctx() {
    return this._ctx;
  }
  clone() {
    return new Canvas({
      ...this._options,
      ...this.cloneGraphicOptions(),
      ...this.cloneRasterOptions()
    });
  }
  execute(ctx) {
    var _a, _b;
    if ((_a = this._options) == null ? void 0 : _a.draw) {
      (_b = this._options) == null ? void 0 : _b.draw(ctx);
    }
    if (!this._options.cache) {
      this.flagDirty();
    }
  }
}
var NineSliceStretch = /* @__PURE__ */ ((NineSliceStretch2) => {
  NineSliceStretch2["Stretch"] = "stretch";
  NineSliceStretch2["Tile"] = "tile";
  NineSliceStretch2["TileFit"] = "tile-fit";
  return NineSliceStretch2;
})(NineSliceStretch || {});
class NineSlice extends Graphic {
  constructor(config) {
    super(config);
    this._logger = Logger.getInstance();
    this._config = config;
    this._imgSource = config.source;
    this._canvasA = document.createElement("canvas");
    this._canvasB = document.createElement("canvas");
    this._canvasC = document.createElement("canvas");
    this._canvasD = document.createElement("canvas");
    this._canvasE = document.createElement("canvas");
    this._canvasF = document.createElement("canvas");
    this._canvasG = document.createElement("canvas");
    this._canvasH = document.createElement("canvas");
    this._canvasI = document.createElement("canvas");
    this._initialize();
    this._imgSource.ready.then(() => {
      this._initialize();
    });
  }
  /**
   * Sets the target width of the 9 slice (pixels), and recalculates the 9 slice if desired (auto)
   * @param newWidth
   * @param auto
   */
  setTargetWidth(newWidth, auto = false) {
    this._config.width = newWidth;
    if (auto) {
      this._initialize();
    }
  }
  /**
   * Sets the target height of the 9 slice (pixels), and recalculates the 9 slice if desired (auto)
   * @param newHeight
   * @param auto
   */
  setTargetHeight(newHeight, auto = false) {
    this._config.height = newHeight;
    if (auto) {
      this._initialize();
    }
  }
  /**
   *  Sets the 9 slice margins (pixels), and recalculates the 9 slice if desired (auto)
   */
  setMargins(left, top, right, bottom, auto = false) {
    this._config.sourceConfig.leftMargin = left;
    this._config.sourceConfig.topMargin = top;
    this._config.sourceConfig.rightMargin = right;
    this._config.sourceConfig.bottomMargin = bottom;
    if (auto) {
      this._initialize();
    }
  }
  /**
   *  Sets the stretching strategy for the 9 slice, and recalculates the 9 slice if desired (auto)
   *
   */
  setStretch(type, stretch, auto = false) {
    if (type === "horizontal") {
      this._config.destinationConfig.horizontalStretch = stretch;
    } else if (type === "vertical") {
      this._config.destinationConfig.verticalStretch = stretch;
    } else {
      this._config.destinationConfig.horizontalStretch = stretch;
      this._config.destinationConfig.verticalStretch = stretch;
    }
    if (auto) {
      this._initialize();
    }
  }
  /**
   *  Returns the config of the 9 slice
   */
  getConfig() {
    return this._config;
  }
  /**
   * Draws 1 of the 9 tiles based on parameters passed in
   * context is the ExcaliburGraphicsContext from the _drawImage function
   * destinationSize is the size of the destination image as a vector (width,height)
   * targetCanvas is the canvas to draw to
   * horizontalStretch and verticalStretch are the horizontal and vertical stretching strategies
   * marginW and marginH are optional margins for the 9 slice for positioning
   * @param context
   * @param targetCanvas
   * @param destinationSize
   * @param horizontalStretch
   * @param verticalStretch
   * @param marginWidth
   * @param marginHeight
   */
  _drawTile(context, targetCanvas, destinationSize, horizontalStretch, verticalStretch, marginWidth, marginHeight) {
    const tempMarginW = marginWidth || 0;
    const tempMarginH = marginHeight || 0;
    let tempSizeX, tempPositionX, tempSizeY, tempPositionY;
    const numTilesX = this._getNumberOfTiles(targetCanvas.width, destinationSize.x, horizontalStretch);
    const numTilesY = this._getNumberOfTiles(targetCanvas.height, destinationSize.y, verticalStretch);
    for (let i = 0; i < numTilesX; i++) {
      for (let j = 0; j < numTilesY; j++) {
        let { tempSize, tempPosition } = this._calculateParams(
          i,
          numTilesX,
          targetCanvas.width,
          destinationSize.x,
          this._config.destinationConfig.horizontalStretch
        );
        tempSizeX = tempSize;
        tempPositionX = tempPosition;
        ({ tempSize, tempPosition } = this._calculateParams(
          j,
          numTilesY,
          targetCanvas.height,
          destinationSize.y,
          this._config.destinationConfig.verticalStretch
        ));
        tempSizeY = tempSize;
        tempPositionY = tempPosition;
        context.drawImage(
          targetCanvas,
          0,
          0,
          targetCanvas.width,
          targetCanvas.height,
          tempMarginW + tempPositionX,
          tempMarginH + tempPositionY,
          tempSizeX,
          tempSizeY
        );
      }
    }
  }
  /**
   *  Draws the 9 slices to the canvas
   */
  _drawImage(ex, x, y) {
    if (this._imgSource.isLoaded()) {
      this._drawTile(
        ex,
        this._canvasA,
        new Vector(this._config.sourceConfig.leftMargin, this._config.sourceConfig.topMargin),
        this._config.destinationConfig.horizontalStretch,
        this._config.destinationConfig.verticalStretch
      );
      this._drawTile(
        ex,
        this._canvasB,
        new Vector(
          this._config.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin,
          this._config.sourceConfig.topMargin
        ),
        this._config.destinationConfig.horizontalStretch,
        this._config.destinationConfig.verticalStretch,
        this._config.sourceConfig.leftMargin,
        0
      );
      this._drawTile(
        ex,
        this._canvasC,
        new Vector(this._config.sourceConfig.rightMargin, this._config.sourceConfig.topMargin),
        this._config.destinationConfig.horizontalStretch,
        this._config.destinationConfig.verticalStretch,
        this._config.width - this._config.sourceConfig.rightMargin,
        0
      );
      this._drawTile(
        ex,
        this._canvasD,
        new Vector(
          this._config.sourceConfig.leftMargin,
          this._config.height - this._config.sourceConfig.bottomMargin - this._config.sourceConfig.topMargin
        ),
        this._config.destinationConfig.horizontalStretch,
        this._config.destinationConfig.verticalStretch,
        0,
        this._config.sourceConfig.topMargin
      );
      if (this._config.destinationConfig.drawCenter) {
        this._drawTile(
          ex,
          this._canvasE,
          new Vector(
            this._config.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin,
            this._config.height - this._config.sourceConfig.bottomMargin - this._config.sourceConfig.topMargin
          ),
          this._config.destinationConfig.horizontalStretch,
          this._config.destinationConfig.verticalStretch,
          this._config.sourceConfig.leftMargin,
          this._config.sourceConfig.topMargin
        );
      }
      this._drawTile(
        ex,
        this._canvasF,
        new Vector(
          this._config.sourceConfig.rightMargin,
          this._config.height - this._config.sourceConfig.bottomMargin - this._config.sourceConfig.topMargin
        ),
        this._config.destinationConfig.horizontalStretch,
        this._config.destinationConfig.verticalStretch,
        this._config.width - this._config.sourceConfig.rightMargin,
        this._config.sourceConfig.topMargin
      );
      this._drawTile(
        ex,
        this._canvasG,
        new Vector(this._config.sourceConfig.leftMargin, this._config.sourceConfig.bottomMargin),
        this._config.destinationConfig.horizontalStretch,
        this._config.destinationConfig.verticalStretch,
        0,
        this._config.height - this._config.sourceConfig.bottomMargin
      );
      this._drawTile(
        ex,
        this._canvasH,
        new Vector(
          this._config.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin,
          this._config.sourceConfig.bottomMargin
        ),
        this._config.destinationConfig.horizontalStretch,
        this._config.destinationConfig.verticalStretch,
        this._config.sourceConfig.leftMargin,
        this._config.height - this._config.sourceConfig.bottomMargin
      );
      this._drawTile(
        ex,
        this._canvasI,
        new Vector(this._config.sourceConfig.rightMargin, this._config.sourceConfig.bottomMargin),
        this._config.destinationConfig.horizontalStretch,
        this._config.destinationConfig.verticalStretch,
        this._config.width - this._config.sourceConfig.rightMargin,
        this._config.height - this._config.sourceConfig.bottomMargin
      );
    } else {
      this._logger.warnOnce(
        `NineSlice ImageSource ${this._imgSource.path} is not yet loaded and won't be drawn. Please call .load() or include in a Loader.

Read https://excaliburjs.com/docs/imagesource for more information.`
      );
    }
  }
  /**
   * Slices the source sprite into the 9 slice canvases internally
   */
  _initialize() {
    this._sourceSprite = this._imgSource.image;
    this._canvasA.width = this._config.sourceConfig.leftMargin;
    this._canvasA.height = this._config.sourceConfig.topMargin;
    const aCtx = this._canvasA.getContext("2d");
    aCtx == null ? void 0 : aCtx.drawImage(this._sourceSprite, 0, 0, this._canvasA.width, this._canvasA.height, 0, 0, this._canvasA.width, this._canvasA.height);
    this._canvasB.width = this._config.sourceConfig.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin;
    this._canvasB.height = this._config.sourceConfig.topMargin;
    const bCtx = this._canvasB.getContext("2d");
    bCtx == null ? void 0 : bCtx.drawImage(
      this._sourceSprite,
      this._config.sourceConfig.leftMargin,
      0,
      this._canvasB.width,
      this._canvasB.height,
      0,
      0,
      this._canvasB.width,
      this._canvasB.height
    );
    this._canvasC.width = this._config.sourceConfig.rightMargin;
    this._canvasC.height = this._config.sourceConfig.topMargin;
    const cCtx = this._canvasC.getContext("2d");
    cCtx == null ? void 0 : cCtx.drawImage(
      this._sourceSprite,
      this._sourceSprite.width - this._config.sourceConfig.rightMargin,
      0,
      this._canvasC.width,
      this._canvasC.height,
      0,
      0,
      this._canvasC.width,
      this._canvasC.height
    );
    this._canvasD.width = this._config.sourceConfig.leftMargin;
    this._canvasD.height = this._config.sourceConfig.height - this._config.sourceConfig.topMargin - this._config.sourceConfig.bottomMargin;
    const dCtx = this._canvasD.getContext("2d");
    dCtx == null ? void 0 : dCtx.drawImage(
      this._sourceSprite,
      0,
      this._config.sourceConfig.topMargin,
      this._canvasD.width,
      this._canvasD.height,
      0,
      0,
      this._canvasD.width,
      this._canvasD.height
    );
    this._canvasE.width = this._config.sourceConfig.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin;
    this._canvasE.height = this._config.sourceConfig.height - this._config.sourceConfig.topMargin - this._config.sourceConfig.bottomMargin;
    const eCtx = this._canvasE.getContext("2d");
    eCtx == null ? void 0 : eCtx.drawImage(
      this._sourceSprite,
      this._config.sourceConfig.leftMargin,
      this._config.sourceConfig.topMargin,
      this._canvasE.width,
      this._canvasE.height,
      0,
      0,
      this._canvasE.width,
      this._canvasE.height
    );
    this._canvasF.width = this._config.sourceConfig.rightMargin;
    this._canvasF.height = this._config.sourceConfig.height - this._config.sourceConfig.topMargin - this._config.sourceConfig.bottomMargin;
    const fCtx = this._canvasF.getContext("2d");
    fCtx == null ? void 0 : fCtx.drawImage(
      this._sourceSprite,
      this._config.sourceConfig.width - this._config.sourceConfig.rightMargin,
      this._config.sourceConfig.topMargin,
      this._canvasF.width,
      this._canvasF.height,
      0,
      0,
      this._canvasF.width,
      this._canvasF.height
    );
    this._canvasG.width = this._config.sourceConfig.leftMargin;
    this._canvasG.height = this._config.sourceConfig.bottomMargin;
    const gCtx = this._canvasG.getContext("2d");
    gCtx == null ? void 0 : gCtx.drawImage(
      this._sourceSprite,
      0,
      this._config.sourceConfig.height - this._config.sourceConfig.bottomMargin,
      this._canvasG.width,
      this._canvasG.height,
      0,
      0,
      this._canvasG.width,
      this._canvasG.height
    );
    this._canvasH.width = this._config.sourceConfig.width - this._config.sourceConfig.leftMargin - this._config.sourceConfig.rightMargin;
    this._canvasH.height = this._config.sourceConfig.bottomMargin;
    const hCtx = this._canvasH.getContext("2d");
    hCtx == null ? void 0 : hCtx.drawImage(
      this._sourceSprite,
      this._config.sourceConfig.leftMargin,
      this._config.sourceConfig.height - this._config.sourceConfig.bottomMargin,
      this._canvasH.width,
      this._canvasH.height,
      0,
      0,
      this._canvasH.width,
      this._canvasH.height
    );
    this._canvasI.width = this._config.sourceConfig.rightMargin;
    this._canvasI.height = this._config.sourceConfig.bottomMargin;
    const iCtx = this._canvasI.getContext("2d");
    iCtx == null ? void 0 : iCtx.drawImage(
      this._sourceSprite,
      this._sourceSprite.width - this._config.sourceConfig.rightMargin,
      this._config.sourceConfig.height - this._config.sourceConfig.bottomMargin,
      this._canvasI.width,
      this._canvasI.height,
      0,
      0,
      this._canvasI.width,
      this._canvasI.height
    );
  }
  /**
   * Clones the 9 slice
   */
  clone() {
    return new NineSlice(this._config);
  }
  /**
   * Returns the number of tiles
   */
  _getNumberOfTiles(tileSize, destinationSize, strategy) {
    switch (strategy) {
      case "stretch":
        return 1;
      case "tile":
        return Math.ceil(destinationSize / tileSize);
      case "tile-fit":
        return Math.ceil(destinationSize / tileSize);
    }
  }
  /**
   * Returns the position and size of the tile
   */
  _calculateParams(tileNum, numTiles, tileSize, destinationSize, strategy) {
    switch (strategy) {
      case "stretch":
        return {
          tempPosition: 0,
          tempSize: destinationSize
        };
      case "tile":
        if (tileNum === numTiles - 1) {
          return {
            tempPosition: tileNum * tileSize,
            tempSize: tileSize - (numTiles * tileSize - destinationSize)
          };
        } else {
          return {
            tempPosition: tileNum * tileSize,
            tempSize: tileSize
          };
        }
      case "tile-fit":
        const reducedTileSize = destinationSize / numTiles;
        const position = tileNum * reducedTileSize;
        return {
          tempPosition: position,
          tempSize: reducedTileSize
        };
    }
  }
}
class TiledAnimation extends Animation {
  constructor(options) {
    super({
      ...options,
      frames: options.animation.frames.slice(),
      strategy: options.animation.strategy,
      frameDuration: options.animation.frameDuration,
      speed: options.animation.speed,
      reverse: options.animation.isReversed
    });
    this._ready = new Future();
    this.ready = this._ready.promise;
    this._tiledWidth = 0;
    this._tiledHeight = 0;
    this._sourceView = {};
    this._sourceView = { ...options.sourceView };
    this._tiledWidth = options.width;
    this._tiledHeight = options.height;
    const promises = [];
    for (let i = 0; i < this.frames.length; i++) {
      const graphic = this.frames[i].graphic;
      if (graphic && graphic instanceof Sprite) {
        const tiledSprite = new TiledSprite({
          image: graphic.image,
          width: options.width,
          height: options.height,
          sourceView: { ...graphic.sourceView },
          wrapping: options.wrapping,
          filtering: options.filtering
        });
        this.frames[i].graphic = tiledSprite;
        tiledSprite.ready.then(() => {
          tiledSprite.sourceView = { ...tiledSprite.sourceView, ...this._sourceView };
        });
        promises.push(tiledSprite.ready);
      }
    }
    Promise.all(promises).then(() => this._ready.resolve());
  }
  static fromAnimation(animation, options) {
    return new TiledAnimation({
      width: animation.width,
      height: animation.height,
      ...options,
      animation
    });
  }
  _updateSourceView() {
    for (let i = 0; i < this.frames.length; i++) {
      const graphic = this.frames[i].graphic;
      if (graphic && graphic instanceof Sprite) {
        graphic.sourceView = { ...graphic.sourceView, ...this._sourceView };
      }
    }
  }
  get sourceView() {
    return watch(this._sourceView, () => this._updateSourceView());
  }
  set sourceView(sourceView) {
    this._sourceView = watch(sourceView, () => this._updateSourceView());
    this._updateSourceView();
  }
  _updateWidthHeight() {
    for (let i = 0; i < this.frames.length; i++) {
      const graphic = this.frames[i].graphic;
      if (graphic && graphic instanceof Sprite) {
        graphic.sourceView.height = this._tiledHeight || graphic.height;
        graphic.destSize.height = this._tiledHeight || graphic.height;
        graphic.sourceView.width = this._tiledWidth || graphic.width;
        graphic.destSize.width = this._tiledWidth || graphic.width;
      }
    }
  }
  get width() {
    return this._tiledWidth;
  }
  get height() {
    return this._tiledHeight;
  }
  set width(width) {
    this._tiledWidth = width;
    this._updateWidthHeight();
  }
  set height(height) {
    this._tiledHeight = height;
    this._updateWidthHeight();
  }
}
const DefaultAntialiasOptions = {
  pixelArtSampler: false,
  nativeContextAntialiasing: false,
  multiSampleAntialiasing: true,
  filtering: ImageFiltering.Blended,
  canvasImageRendering: "auto"
};
const DefaultPixelArtOptions = {
  pixelArtSampler: true,
  nativeContextAntialiasing: false,
  multiSampleAntialiasing: true,
  filtering: ImageFiltering.Blended,
  canvasImageRendering: "auto"
};
const _GraphicsDiagnostics = class _GraphicsDiagnostics2 {
  static clear() {
    _GraphicsDiagnostics2.DrawCallCount = 0;
    _GraphicsDiagnostics2.DrawnImagesCount = 0;
  }
};
_GraphicsDiagnostics.DrawCallCount = 0;
_GraphicsDiagnostics.DrawnImagesCount = 0;
let GraphicsDiagnostics = _GraphicsDiagnostics;
const pixelSnapEpsilon$1 = 1e-4;
class ExcaliburGraphicsContext2DCanvasDebug {
  constructor(_ex) {
    this._ex = _ex;
    this._debugText = new DebugText();
  }
  /**
   * Draw a debug rectangle to the context
   * @param x
   * @param y
   * @param width
   * @param height
   */
  drawRect(x, y, width, height) {
    this._ex.__ctx.save();
    this._ex.__ctx.strokeStyle = "red";
    this._ex.__ctx.strokeRect(
      this._ex.snapToPixel ? ~~(x + pixelSnapEpsilon$1) : x,
      this._ex.snapToPixel ? ~~(y + pixelSnapEpsilon$1) : y,
      this._ex.snapToPixel ? ~~(width + pixelSnapEpsilon$1) : width,
      this._ex.snapToPixel ? ~~(height + pixelSnapEpsilon$1) : height
    );
    this._ex.__ctx.restore();
  }
  drawLine(start, end, lineOptions = { color: Color.Black }) {
    var _a, _b;
    this._ex.__ctx.save();
    this._ex.__ctx.beginPath();
    this._ex.__ctx.strokeStyle = (_b = (_a = lineOptions.color) == null ? void 0 : _a.toString()) != null ? _b : "";
    this._ex.__ctx.moveTo(
      this._ex.snapToPixel ? ~~(start.x + pixelSnapEpsilon$1) : start.x,
      this._ex.snapToPixel ? ~~(start.y + pixelSnapEpsilon$1) : start.y
    );
    this._ex.__ctx.lineTo(
      this._ex.snapToPixel ? ~~(end.x + pixelSnapEpsilon$1) : end.x,
      this._ex.snapToPixel ? ~~(end.y + pixelSnapEpsilon$1) : end.y
    );
    this._ex.__ctx.lineWidth = 2;
    this._ex.__ctx.stroke();
    this._ex.__ctx.closePath();
    this._ex.__ctx.restore();
  }
  drawPoint(point2, pointOptions = { color: Color.Black, size: 5 }) {
    this._ex.__ctx.save();
    this._ex.__ctx.beginPath();
    this._ex.__ctx.fillStyle = pointOptions.color.toString();
    this._ex.__ctx.arc(
      this._ex.snapToPixel ? ~~(point2.x + pixelSnapEpsilon$1) : point2.x,
      this._ex.snapToPixel ? ~~(point2.y + pixelSnapEpsilon$1) : point2.y,
      pointOptions.size,
      0,
      Math.PI * 2
    );
    this._ex.__ctx.fill();
    this._ex.__ctx.closePath();
    this._ex.__ctx.restore();
  }
  drawText(text, pos) {
    this._debugText.write(this._ex, text, pos);
  }
}
class ExcaliburGraphicsContext2DCanvas {
  constructor(options) {
    this.useDrawSorting = false;
    this.z = 0;
    this.backgroundColor = Color.ExcaliburBlue;
    this._state = new StateStack();
    this.snapToPixel = false;
    this.debug = new ExcaliburGraphicsContext2DCanvasDebug(this);
    const { canvasElement, context, enableTransparency, snapToPixel, antialiasing: smoothing, backgroundColor } = options;
    this.__ctx = context != null ? context : canvasElement.getContext("2d", {
      alpha: enableTransparency != null ? enableTransparency : true
    });
    if (!this.__ctx) {
      throw new Error("Cannot build new ExcaliburGraphicsContext2D for some reason!");
    }
    this.backgroundColor = backgroundColor != null ? backgroundColor : this.backgroundColor;
    this.snapToPixel = snapToPixel != null ? snapToPixel : this.snapToPixel;
    this.smoothing = smoothing != null ? smoothing : this.smoothing;
  }
  get width() {
    return this.__ctx.canvas.width;
  }
  get height() {
    return this.__ctx.canvas.height;
  }
  get opacity() {
    return this._state.current.opacity;
  }
  set opacity(value) {
    this._state.current.opacity = value;
  }
  get tint() {
    return this._state.current.tint;
  }
  set tint(color) {
    this._state.current.tint = color;
  }
  get smoothing() {
    return this.__ctx.imageSmoothingEnabled;
  }
  set smoothing(value) {
    this.__ctx.imageSmoothingEnabled = value;
  }
  resetTransform() {
    this.__ctx.resetTransform();
  }
  updateViewport(_resolution) {
  }
  drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
    if (swidth === 0 || sheight === 0) {
      return;
    } else if (dwidth === 0 || dheight === 0) {
      return;
    } else if (image.width === 0 || image.height === 0) {
      return;
    }
    this.__ctx.globalAlpha = this.opacity;
    const args = [image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight].filter((a) => a !== void 0).map((a) => typeof a === "number" && this.snapToPixel ? ~~a : a);
    this.__ctx.drawImage.apply(this.__ctx, args);
    GraphicsDiagnostics.DrawCallCount++;
    GraphicsDiagnostics.DrawnImagesCount = 1;
  }
  drawLine(start, end, color, thickness = 1) {
    this.__ctx.save();
    this.__ctx.beginPath();
    this.__ctx.strokeStyle = color.toString();
    this.__ctx.moveTo(
      this.snapToPixel ? ~~(start.x + pixelSnapEpsilon$1) : start.x,
      this.snapToPixel ? ~~(start.y + pixelSnapEpsilon$1) : start.y
    );
    this.__ctx.lineTo(this.snapToPixel ? ~~(end.x + pixelSnapEpsilon$1) : end.x, this.snapToPixel ? ~~(end.y + pixelSnapEpsilon$1) : end.y);
    this.__ctx.lineWidth = thickness;
    this.__ctx.stroke();
    this.__ctx.closePath();
    this.__ctx.restore();
  }
  drawRectangle(pos, width, height, color) {
    this.__ctx.save();
    this.__ctx.fillStyle = color.toString();
    this.__ctx.fillRect(
      this.snapToPixel ? ~~(pos.x + pixelSnapEpsilon$1) : pos.x,
      this.snapToPixel ? ~~(pos.y + pixelSnapEpsilon$1) : pos.y,
      this.snapToPixel ? ~~(width + pixelSnapEpsilon$1) : width,
      this.snapToPixel ? ~~(height + pixelSnapEpsilon$1) : height
    );
    this.__ctx.restore();
  }
  drawCircle(pos, radius, color, stroke, thickness) {
    this.__ctx.save();
    this.__ctx.beginPath();
    if (stroke) {
      this.__ctx.strokeStyle = stroke.toString();
    }
    if (thickness) {
      this.__ctx.lineWidth = thickness;
    }
    this.__ctx.fillStyle = color.toString();
    this.__ctx.arc(
      this.snapToPixel ? ~~(pos.x + pixelSnapEpsilon$1) : pos.x,
      this.snapToPixel ? ~~(pos.y + pixelSnapEpsilon$1) : pos.y,
      radius,
      0,
      Math.PI * 2
    );
    this.__ctx.fill();
    if (stroke) {
      this.__ctx.stroke();
    }
    this.__ctx.closePath();
    this.__ctx.restore();
  }
  /**
   * Save the current state of the canvas to the stack (transforms and opacity)
   */
  save() {
    this.__ctx.save();
    this._state.save();
  }
  /**
   * Restore the state of the canvas from the stack
   */
  restore() {
    this.__ctx.restore();
    this._state.restore();
  }
  /**
   * Translate the origin of the context by an x and y
   * @param x
   * @param y
   */
  translate(x, y) {
    this.__ctx.translate(this.snapToPixel ? ~~(x + pixelSnapEpsilon$1) : x, this.snapToPixel ? ~~(y + pixelSnapEpsilon$1) : y);
  }
  /**
   * Rotate the context about the current origin
   */
  rotate(angle) {
    this.__ctx.rotate(angle);
  }
  /**
   * Scale the context by an x and y factor
   * @param x
   * @param y
   */
  scale(x, y) {
    this.__ctx.scale(x, y);
  }
  getTransform() {
    throw new Error("Not implemented");
  }
  multiply(_m) {
    this.__ctx.setTransform(this.__ctx.getTransform().multiply(_m.toDOMMatrix()));
  }
  addPostProcessor(_postprocessor) {
  }
  removePostProcessor(_postprocessor) {
  }
  clearPostProcessors() {
  }
  updatePostProcessors(elapsed) {
  }
  beginDrawLifecycle() {
  }
  endDrawLifecycle() {
  }
  set material(material) {
    this._state.current.material = material;
  }
  get material() {
    return this._state.current.material;
  }
  createMaterial(options) {
    return null;
  }
  clear() {
    this.__ctx.clearRect(0, 0, this.width, this.height);
    this.__ctx.fillStyle = this.backgroundColor.toString();
    this.__ctx.fillRect(0, 0, this.width, this.height);
    GraphicsDiagnostics.clear();
  }
  /**
   * Flushes the batched draw calls to the screen
   */
  flush() {
  }
  dispose() {
    this.__ctx = void 0;
  }
}
class UniformBuffer {
  constructor(options) {
    this.type = "static";
    const { gl, size, type, data } = options;
    this._gl = gl;
    this.buffer = gl.createBuffer();
    this._maxFloats = gl.getParameter(gl.MAX_UNIFORM_BLOCK_SIZE) / 32;
    if (!data && !size) {
      throw Error("Must either provide data or a size to the UniformBuffer");
    }
    if (!data) {
      this.bufferData = new Float32Array(size);
    } else {
      this.bufferData = data;
    }
    if (this.bufferData.length > this._maxFloats) {
      throw Error(`UniformBuffer exceeds browsers allowed number of floats ${this._maxFloats}`);
    }
    this.type = type != null ? type : this.type;
    gl.bindBuffer(gl.UNIFORM_BUFFER, this.buffer);
    gl.bufferData(gl.UNIFORM_BUFFER, this.bufferData, this.type === "static" ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);
  }
  /**
   * Bind this uniform buffer
   */
  bind() {
    const gl = this._gl;
    gl.bindBuffer(gl.UNIFORM_BUFFER, this.buffer);
  }
  unbind() {
    const gl = this._gl;
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
  }
  upload(count) {
    const gl = this._gl;
    gl.bindBuffer(gl.UNIFORM_BUFFER, this.buffer);
    if (count) {
      gl.bufferSubData(gl.UNIFORM_BUFFER, 0, this.bufferData, 0, count);
    } else {
      gl.bufferData(gl.UNIFORM_BUFFER, this.bufferData, this.type === "static" ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);
    }
  }
  dispose() {
    const gl = this._gl;
    gl.deleteBuffer(this.buffer);
    this._gl = null;
  }
}
function getGlTypeSizeBytes(gl, type) {
  switch (type) {
    case gl.INT:
    case gl.UNSIGNED_INT:
    case gl.FLOAT:
      return 4;
    case gl.SHORT:
      return 2;
    case gl.UNSIGNED_SHORT:
      return 2;
    case gl.BYTE:
      return 1;
    case gl.UNSIGNED_BYTE:
      return 1;
    default:
      return 1;
  }
}
function isAttributeInSource(source, variable) {
  const attributeRegexTemplate = `(?<type>[a-z0-9]+)\\s+${variable};`;
  const regex = new RegExp(attributeRegexTemplate, "g");
  const matches = regex.exec(source);
  return (matches == null ? void 0 : matches.length) > 0;
}
function getGLTypeFromSource(gl, source, variable) {
  var _a;
  const attributeRegexTemplate = `(?<type>[a-z0-9]+)\\s+${variable};`;
  const regex = new RegExp(attributeRegexTemplate, "g");
  const matches = regex.exec(source);
  const type = (_a = matches == null ? void 0 : matches.groups) == null ? void 0 : _a.type;
  switch (type) {
    case "float":
    case "vec2":
    case "vec3":
    case "vec4":
      return gl.FLOAT;
    case "int":
    case "ivec2":
    case "ivec3":
    case "ivec4":
      return gl.INT;
    case "uint":
    case "uvec2":
    case "uvec3":
    case "uvec4":
      return gl.UNSIGNED_INT;
    case "bool":
    case "bvec2":
    case "bvec3":
    case "bvec4":
      return gl.BOOL;
    case "short":
      return gl.SHORT;
    case "ushort":
      return gl.UNSIGNED_SHORT;
    case "ubyte":
      return gl.UNSIGNED_BYTE;
    case "byte":
      return gl.BYTE;
    default:
      return gl.FLOAT;
  }
}
function getAttributeComponentSize(gl, type) {
  switch (type) {
    case gl.LOW_FLOAT:
    case gl.HIGH_FLOAT:
    case gl.FLOAT:
      return 1;
    case gl.FLOAT_VEC2:
      return 2;
    case gl.FLOAT_VEC3:
      return 3;
    case gl.FLOAT_VEC4:
      return 4;
    case gl.BYTE:
      return 1;
    case gl.UNSIGNED_BYTE:
      return 1;
    case gl.UNSIGNED_SHORT:
    case gl.SHORT:
      return 1;
    default:
      return 1;
  }
}
function getAttributePointerType(gl, type) {
  switch (type) {
    case gl.LOW_FLOAT:
    case gl.HIGH_FLOAT:
    case gl.FLOAT:
    case gl.FLOAT_VEC2:
    case gl.FLOAT_VEC3:
    case gl.FLOAT_VEC4:
      return gl.FLOAT;
    case gl.BYTE:
      return gl.BYTE;
    case gl.UNSIGNED_BYTE:
      return gl.UNSIGNED_BYTE;
    case gl.SHORT:
      return gl.SHORT;
    case gl.UNSIGNED_SHORT:
      return gl.UNSIGNED_SHORT;
    default:
      return gl.FLOAT;
  }
}
function getMaxShaderComplexity(gl, numIfs) {
  const assembleTestShader = (numIfs2) => {
    const testShader = `#version 300 es
    precision mediump float;
    out vec4 fragColor;
    void main() {
      float index = 1.01;
      %%complexity%%
    }`;
    let testComplexity = "";
    for (let i = 0; i < numIfs2; i++) {
      if (i === 0) {
        testComplexity += `if (index <= ${i}.5) {
`;
      } else {
        testComplexity += `   else if (index <= ${i}.5) {
`;
      }
      testComplexity += `      fragColor = vec4(1.0);
`;
      testComplexity += `   }
`;
    }
    return testShader.replace("%%complexity%%", testComplexity);
  };
  let canCompile = false;
  do {
    const test = assembleTestShader(numIfs);
    const shader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(shader, test);
    gl.compileShader(shader);
    canCompile = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (!canCompile) {
      numIfs = numIfs / 2 | 0;
    }
  } while (!canCompile);
  return numIfs;
}
const webglUtil = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getAttributeComponentSize,
  getAttributePointerType,
  getGLTypeFromSource,
  getGlTypeSizeBytes,
  getMaxShaderComplexity,
  isAttributeInSource
}, Symbol.toStringTag, { value: "Module" }));
function glTypeToUniformTypeName(gl, glType) {
  switch (glType) {
    case gl.FLOAT: {
      return "uniform1f";
    }
    case gl.FLOAT_VEC2: {
      return "uniform2f";
    }
    case gl.FLOAT_VEC3: {
      return "uniform3f";
    }
    case gl.FLOAT_VEC4: {
      return "uniform4f";
    }
    case gl.INT: {
      return "uniform1i";
    }
    case gl.INT_VEC2: {
      return "uniform2i";
    }
    case gl.INT_VEC3: {
      return "uniform3i";
    }
    case gl.INT_VEC4: {
      return "uniform4i";
    }
    case gl.BOOL: {
      return "uniform1i";
    }
    case gl.BOOL_VEC2: {
      return "uniform2i";
    }
    case gl.BOOL_VEC3: {
      return "uniform3i";
    }
    case gl.BOOL_VEC4: {
      return "uniform4i";
    }
    case gl.FLOAT_MAT2: {
      return "uniform1f";
    }
    case gl.FLOAT_MAT3: {
      return "uniform1f";
    }
    case gl.FLOAT_MAT4: {
      return "uniform1f";
    }
    case gl.SAMPLER_2D: {
      return "uniform1f";
    }
    case gl.SAMPLER_CUBE: {
      return "uniform1f";
    }
    case gl.UNSIGNED_INT: {
      return "uniform1ui";
    }
    case gl.UNSIGNED_INT_VEC2: {
      return "uniform2ui";
    }
    case gl.UNSIGNED_INT_VEC3: {
      return "uniform3ui";
    }
    case gl.UNSIGNED_INT_VEC4: {
      return "uniform4ui";
    }
    case gl.FLOAT_MAT2x3: {
      return "uniformMatrix2x3fv";
    }
    case gl.FLOAT_MAT2x4: {
      return "uniformMatrix2x4fv";
    }
    case gl.FLOAT_MAT3x2: {
      return "uniformMatrix3x2fv";
    }
    case gl.FLOAT_MAT3x4: {
      return "uniformMatrix3x4fv";
    }
    case gl.FLOAT_MAT4x2: {
      return "uniformMatrix4x2fv";
    }
    case gl.FLOAT_MAT4x3: {
      return "uniformMatrix4x3fv";
    }
    case gl.SAMPLER_2D_ARRAY: {
      return "uniform1fv";
    }
    case gl.SAMPLER_2D_ARRAY_SHADOW: {
      return "uniform1f";
    }
    case gl.SAMPLER_CUBE_SHADOW: {
      return "uniform1f";
    }
    case gl.INT_SAMPLER_2D: {
      return "uniform1f";
    }
    case gl.INT_SAMPLER_3D: {
      return "uniform1f";
    }
    case gl.INT_SAMPLER_CUBE: {
      return "uniform1f";
    }
    case gl.INT_SAMPLER_2D_ARRAY: {
      return "uniform1f";
    }
    case gl.UNSIGNED_INT_SAMPLER_2D: {
      return "uniform1ui";
    }
    default: {
      throw new Error(`Unknown uniform type: ${glType}`);
    }
  }
}
const _Shader = class _Shader2 {
  /**
   * Create a shader program in excalibur
   * @param options specify shader vertex and fragment source
   */
  constructor(options) {
    this.name = "anonymous shader";
    this._logger = Logger.getInstance();
    this._textures = /* @__PURE__ */ new Map();
    this.attributes = {};
    this._uniforms = {};
    this._uniformBuffers = {};
    this._compiled = false;
    this._dirtyUniforms = true;
    this._startingTextureSlot = 0;
    this.uniforms = watch({}, () => this.flagUniformsDirty());
    this.images = {};
    const { name, graphicsContext, vertexSource, fragmentSource, onPreLink, onPostCompile, uniforms, images, startingTextureSlot } = options;
    this.name = name != null ? name : this.name;
    if (!(graphicsContext instanceof ExcaliburGraphicsContextWebGL)) {
      throw new Error(`ExcaliburGraphicsContext provided to a shader ${this.name} must be WebGL`);
    }
    this._gl = graphicsContext.__gl;
    this._startingTextureSlot = startingTextureSlot != null ? startingTextureSlot : this._startingTextureSlot;
    this._maxTextureSlots = this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS) - this._startingTextureSlot;
    this.vertexSource = vertexSource;
    this.fragmentSource = fragmentSource;
    this.uniforms = watch(uniforms != null ? uniforms : this.uniforms, () => this.flagUniformsDirty());
    this.images = images != null ? images : this.images;
    const keys = Object.keys(this.images);
    if (keys.length >= this._maxTextureSlots) {
      this._logger.warn(
        `Max number texture slots ${this._maxTextureSlots} have been reached for material "${this.name}", no more textures will be uploaded due to hardware constraints.`
      );
    }
    this._textureLoader = graphicsContext.textureLoader;
    this._onPreLink = onPreLink;
    this._onPostCompile = onPostCompile;
  }
  /**
   * Flags uniforms need to be re-uploaded on the next call to .use()
   */
  flagUniformsDirty() {
    this._dirtyUniforms = true;
  }
  /**
   * Returns whether the shader is compiled
   */
  get compiled() {
    return this._compiled;
  }
  /**
   * Deletes the webgl program from the gpu
   */
  dispose() {
    const gl = this._gl;
    gl.deleteProgram(this.program);
    this._gl = null;
  }
  /**
   * Binds the shader program
   */
  use() {
    const gl = this._gl;
    gl.useProgram(this.program);
    _Shader2._ACTIVE_SHADER_INSTANCE = this;
    if (this._dirtyUniforms) {
      this._setUniforms();
      this._dirtyUniforms = false;
    }
    this._setImages();
  }
  unuse() {
    const gl = this._gl;
    _Shader2._ACTIVE_SHADER_INSTANCE = null;
    gl.useProgram(null);
  }
  isCurrentlyBound() {
    return _Shader2._ACTIVE_SHADER_INSTANCE === this;
  }
  _setUniforms() {
    const gl = this._gl;
    const entries = Object.entries(this.uniforms);
    if (entries.length) {
      const uniforms = this.getUniformDefinitions();
      for (const [key, value] of entries) {
        if (value instanceof Float32Array) {
          this.setUniformBuffer(key, value);
        } else if (Array.isArray(value) && value[0] instanceof Float32Array && typeof value[1] === "number") {
          this.setUniformBuffer(key, value[0], value[1]);
        } else if (typeof value === "number") {
          this.trySetUniformFloat(key, value);
        } else if (typeof value === "boolean") {
          this.trySetUniformBoolean(key, value);
        } else if (value instanceof Vector) {
          this.trySetUniformFloatVector(key, value);
        } else if (value instanceof Color) {
          this.trySetUniformFloatColor(key, value);
        } else if (value instanceof AffineMatrix) {
          this.setUniformAffineMatrix(key, value);
        } else {
          const uniform = uniforms.find((u) => u.name === key);
          if (uniform) {
            const typeName = glTypeToUniformTypeName(gl, uniform.glType);
            this.trySetUniform(typeName, key, value);
          } else {
            this._logger.warnOnce(
              `Could not locate uniform named ${key}, this can happen if the uniform is unused in the shader code some GPUs will remove this as an optimization.`
            );
          }
        }
      }
    }
  }
  _loadImageSource(image) {
    const imageElement = image.image;
    const maybeFiltering = imageElement.getAttribute(ImageSourceAttributeConstants.Filtering);
    const filtering = maybeFiltering ? parseImageFiltering(maybeFiltering) : void 0;
    const wrapX = parseImageWrapping(imageElement.getAttribute(ImageSourceAttributeConstants.WrappingX));
    const wrapY = parseImageWrapping(imageElement.getAttribute(ImageSourceAttributeConstants.WrappingY));
    const force = imageElement.getAttribute("forceUpload") === "true" ? true : false;
    const texture = this._textureLoader.load(
      imageElement,
      {
        filtering,
        wrapping: { x: wrapX, y: wrapY }
      },
      force
    );
    imageElement.removeAttribute("forceUpload");
    if (!this._textures.has(image)) {
      this._textures.set(image, texture);
    }
    return texture;
  }
  _setImages(suppressWarning = false) {
    const gl = this._gl;
    let textureSlot = this._startingTextureSlot;
    for (const [textureName, image] of Object.entries(this.images)) {
      if (!image.isLoaded()) {
        if (!suppressWarning) {
          this._logger.warnOnce(
            `Image named ${textureName} in not loaded, nothing will be uploaded to the shader. Did you forget to add this to a loader? https://excaliburjs.com/docs/loaders/`
          );
        }
        continue;
      }
      const texture = this._loadImageSource(image);
      if (!texture) {
        if (!suppressWarning) {
          this._logger.warnOnce(`Image ${textureName} (${image.image.src}) could not be loaded for some reason in shader ${this.name}`);
        }
      }
      gl.activeTexture(gl.TEXTURE0 + textureSlot);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      this.trySetUniformInt(textureName, textureSlot);
      textureSlot++;
    }
  }
  /**
   * Compile the current shader against a webgl context
   */
  compile() {
    if (this._compiled) {
      return this.program;
    }
    const gl = this._gl;
    const vertexShader = this._compileShader(gl, this.vertexSource, gl.VERTEX_SHADER);
    const fragmentShader = this._compileShader(gl, this.fragmentSource, gl.FRAGMENT_SHADER);
    this.program = this._createProgram(gl, vertexShader, fragmentShader);
    const attributes = this.getAttributeDefinitions();
    for (const attribute of attributes) {
      this.attributes[attribute.name] = attribute;
    }
    const uniforms = this.getUniformDefinitions();
    for (const uniform of uniforms) {
      this._uniforms[uniform.name] = uniform;
    }
    this._compiled = true;
    if (this._onPostCompile) {
      this._onPostCompile(this);
    }
    gl.useProgram(this.program);
    _Shader2._ACTIVE_SHADER_INSTANCE = this;
    if (this._dirtyUniforms) {
      this._setUniforms();
      this._dirtyUniforms = false;
    }
    this._setImages(true);
    this.unuse();
    return this.program;
  }
  /**
   * Get's the uniform definitons
   */
  getUniformDefinitions() {
    const gl = this._gl;
    const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
    const uniforms = [];
    for (let i = 0; i < uniformCount; i++) {
      const uniform = gl.getActiveUniform(this.program, i);
      const uniformLocation = gl.getUniformLocation(this.program, uniform.name);
      uniforms.push({
        name: uniform.name,
        glType: uniform.type,
        location: uniformLocation
      });
    }
    return uniforms;
  }
  getAttributeDefinitions() {
    const gl = this._gl;
    const attributeCount = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);
    const attributes = [];
    for (let i = 0; i < attributeCount; i++) {
      const attribute = gl.getActiveAttrib(this.program, i);
      const attributeLocation = gl.getAttribLocation(this.program, attribute.name);
      attributes.push({
        name: attribute.name,
        glType: getAttributePointerType(gl, attribute.type),
        size: getAttributeComponentSize(gl, attribute.type),
        location: attributeLocation,
        normalized: false
      });
    }
    return attributes;
  }
  addImageSource(samplerName, image) {
    const keys = Object.keys(this.images);
    if (keys.length < this._maxTextureSlots) {
      this.images[samplerName] = image;
    } else {
      this._logger.warn(
        `Max number texture slots ${this._maxTextureSlots} have been reached for material "${this.name}", no more textures will be uploaded due to hardware constraints.`
      );
    }
  }
  removeImageSource(samplerName) {
    const image = this.images[samplerName];
    if (image) {
      this._textureLoader.delete(image.image);
      delete this.images[samplerName];
    }
  }
  /**
   * Set a texture in a gpu texture slot
   * @param slotNumber
   * @param texture
   */
  setTexture(slotNumber, texture) {
    const gl = this._gl;
    gl.activeTexture(gl.TEXTURE0 + slotNumber);
    gl.bindTexture(gl.TEXTURE_2D, texture);
  }
  /**
   * Set a uniform buffer block with a Float32Array
   * @param name The of the binding block
   * @param data Float32Array
   * @param [bindingPoint]
   */
  setUniformBuffer(name, data, bindingPoint = 0) {
    const gl = this._gl;
    const index = gl.getUniformBlockIndex(this.program, name);
    if (index === gl.INVALID_INDEX) {
      this._logger.warnOnce(`Invalid block name ${name}`);
    }
    let uniformBuffer;
    if (this._uniformBuffers[name]) {
      uniformBuffer = this._uniformBuffers[name];
      uniformBuffer.bufferData.set(data);
      uniformBuffer.upload();
    } else {
      uniformBuffer = new UniformBuffer({
        gl,
        data
      });
      this._uniformBuffers[name] = uniformBuffer;
    }
    gl.uniformBlockBinding(this.program, index, bindingPoint);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPoint, uniformBuffer.buffer);
  }
  trySetUniformBuffer(name, data, bindingPoint = 0) {
    if (!this._compiled) {
      this._logger.warn(`Must compile shader before setting a uniform block ${name} at binding point ${bindingPoint}`);
      return false;
    }
    if (!this.isCurrentlyBound()) {
      this._logger.warn(
        "Currently accessed shader instance is not the current active shader in WebGL, must call `shader.use()` before setting uniforms"
      );
      return false;
    }
    const gl = this._gl;
    const index = gl.getUniformBlockIndex(this.program, name);
    if (index) {
      this.setUniformBuffer(name, data, bindingPoint);
      return true;
    }
    return false;
  }
  /**
   * Set an integer uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformInt(name, value) {
    this.setUniform("uniform1i", name, ~~value);
  }
  /**
   * Set an integer uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformInt(name, value) {
    return this.trySetUniform("uniform1i", name, ~~value);
  }
  /**
   * Set an integer array uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformIntArray(name, value) {
    this.setUniform("uniform1iv", name, value);
  }
  /**
   * Set an integer array uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformIntArray(name, value) {
    return this.trySetUniform("uniform1iv", name, value);
  }
  /**
   * Set a boolean uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformBoolean(name, value) {
    this.setUniform("uniform1i", name, value ? 1 : 0);
  }
  /**
   * Set a boolean uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformBoolean(name, value) {
    return this.trySetUniform("uniform1i", name, value ? 1 : 0);
  }
  /**
   * Set a float uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformFloat(name, value) {
    this.setUniform("uniform1f", name, value);
  }
  /**
   * Set a float uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformFloat(name, value) {
    return this.trySetUniform("uniform1f", name, value);
  }
  /**
   * Set a float array uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformFloatArray(name, value) {
    this.setUniform("uniform1fv", name, value);
  }
  /**
   * Set a float array uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformFloatArray(name, value) {
    return this.trySetUniform("uniform1fv", name, value);
  }
  /**
   * Set a {@apilink Vector} uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformFloatVector(name, value) {
    this.setUniform("uniform2f", name, value.x, value.y);
  }
  /**
   * Set a {@apilink Vector} uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformFloatVector(name, value) {
    return this.trySetUniform("uniform2f", name, value.x, value.y);
  }
  /**
   * Set a {@apilink Color} uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformFloatColor(name, value) {
    this.setUniform("uniform4f", name, value.r / 255, value.g / 255, value.b / 255, value.a);
  }
  /**
   * Set a {@apilink Color} uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformFloatColor(name, value) {
    return this.trySetUniform("uniform4f", name, value.r / 255, value.g / 255, value.b / 255, value.a);
  }
  /**
   * Set an {@apilink Matrix} uniform for the current shader
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  setUniformMatrix(name, value) {
    this.setUniform("uniformMatrix4fv", name, false, value.data);
  }
  setUniformAffineMatrix(name, value) {
    this.setUniform("uniformMatrix4fv", name, false, [
      value.data[0],
      value.data[1],
      0,
      0,
      value.data[2],
      value.data[3],
      0,
      0,
      0,
      0,
      1,
      0,
      value.data[4],
      value.data[5],
      0,
      1
    ]);
  }
  /**
   * Set an {@apilink Matrix} uniform for the current shader, WILL NOT THROW on error.
   *
   * **Important** Must call ex.Shader.use() before setting a uniform!
   * @param name
   * @param value
   */
  trySetUniformMatrix(name, value) {
    return this.trySetUniform("uniformMatrix4fv", name, false, value.data);
  }
  /**
   * Set any available uniform type in webgl
   *
   * For example setUniform('uniformMatrix2fv', 'u_my2x2_mat`, ...);
   */
  setUniform(uniformType, name, ...value) {
    if (!this._compiled) {
      throw Error(`Must compile shader before setting a uniform ${uniformType}:${name}`);
    }
    if (!this.isCurrentlyBound()) {
      throw Error(
        "Currently accessed shader instance is not the current active shader in WebGL, must call `shader.use()` before setting uniforms"
      );
    }
    const gl = this._gl;
    const location2 = gl.getUniformLocation(this.program, name);
    if (location2) {
      const args = [location2, ...value];
      this._gl[uniformType].apply(this._gl, args);
    } else {
      throw Error(
        `Uniform ${uniformType}:${name} doesn't exist or is not used in the shader source code, unused uniforms are optimized away by most browsers`
      );
    }
  }
  /**
   * Set any available uniform type in webgl. Will try to set the uniform, will return false if the uniform didn't exist,
   * true if it was set.
   *
   * WILL NOT THROW on error
   *
   * For example setUniform('uniformMatrix2fv', 'u_my2x2_mat`, ...);
   *
   */
  trySetUniform(uniformType, name, ...value) {
    if (!this._compiled) {
      this._logger.warn(`Must compile shader before setting a uniform ${uniformType}:${name}`);
      return false;
    }
    if (!this.isCurrentlyBound()) {
      this._logger.warn(
        "Currently accessed shader instance is not the current active shader in WebGL, must call `shader.use()` before setting uniforms"
      );
      return false;
    }
    const gl = this._gl;
    const location2 = gl.getUniformLocation(this.program, name);
    if (location2) {
      const args = [location2, ...value];
      this._gl[uniformType].apply(this._gl, args);
    } else {
      return false;
    }
    return true;
  }
  _createProgram(gl, vertexShader, fragmentShader) {
    const program = gl.createProgram();
    if (program === null) {
      throw Error("Could not create graphics shader program");
    }
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    if (this._onPreLink) {
      this._onPreLink(program);
    }
    gl.linkProgram(program);
    const success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!success) {
      throw Error(`Could not link the program: [${gl.getProgramInfoLog(program)}]`);
    }
    return program;
  }
  _compileShader(gl, source, type) {
    const typeName = gl.VERTEX_SHADER === type ? "vertex" : "fragment";
    const shader = gl.createShader(type);
    if (shader === null) {
      throw Error(`Could not build shader: [${source}]`);
    }
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (!success) {
      const errorInfo = gl.getShaderInfoLog(shader);
      throw Error(`Could not compile ${typeName} shader:

${errorInfo}${this._processSourceForError(source, errorInfo)}`);
    }
    return shader;
  }
  _processSourceForError(source, errorInfo) {
    if (!source) {
      return errorInfo;
    }
    const lines = source.split("\n");
    const errorLineStart = errorInfo.search(/\d:\d/);
    const errorLineEnd = errorInfo.indexOf(" ", errorLineStart);
    const [_, error2] = errorInfo.slice(errorLineStart, errorLineEnd).split(":").map((v) => Number(v));
    for (let i = 0; i < lines.length; i++) {
      lines[i] = `${i + 1}: ${lines[i]}${error2 === i + 1 ? " <----- ERROR!" : ""}`;
    }
    return "\n\nSource:\n" + lines.join("\n");
  }
};
_Shader._ACTIVE_SHADER_INSTANCE = null;
let Shader = _Shader;
const particleVertexSource = "#version 300 es\nprecision mediump float;\n\nuniform float deltaMs;\nuniform float maxLifeMs;\nuniform vec2 gravity;\nuniform vec2 focus;\nuniform float focusAccel;\nuniform mat4 u_matrix;\nuniform mat4 u_transform;\nuniform float startSize;\nuniform float endSize;\n// uniform sampler2D obstacle;\n\nlayout(location=0)in vec2 position;\nlayout(location=1)in vec2 velocity;\nlayout(location=2)in float rotation;\nlayout(location=3)in float angularVelocity;\nlayout(location=4)in float lifeMs;\n\n// TODO z index to handle buffer wrapping?\n\n// DO NOT RE-ORDER\nout vec2 finalPosition;\nout vec2 finalVelocity;\nout float finalRotation;\nout float finalAngularVelocity;\nout float finalLifeMs;\nvoid main(){\n  // Evolve particle\n  float seconds = deltaMs / 1000.;\n  // euler integration\n  // Weird artifact of re-using the same buffer layout for update/draw\n  // we need differently named variables\n  vec2 finalGravity = gravity + normalize(focus - position) * focusAccel;\n  finalVelocity = velocity + finalGravity * seconds;\n  finalPosition = position + velocity * seconds + finalGravity * .5 * seconds * seconds;\n  finalRotation = rotation + angularVelocity * seconds;\n  finalAngularVelocity = angularVelocity;\n  finalLifeMs = clamp(lifeMs - deltaMs, 0., maxLifeMs);\n\n  // Collision mask sampling\n  // vec2 samplePoint = finalPosition / vec2(width, height);\n  // vec4 collides = texture(obstacle, samplePoint);\n  // if (distance(collides,vec4(0.)) > .01) {\n  //   // non opaque means we collide! recalc final pos/vel\n  //   vec2 newVelocity = velocity * -.1;// lose energy\n  //   finalVelocity = newVelocity + gravity * seconds;\n  //   finalPosition = position + newVelocity * seconds + gravity * .5 * seconds * seconds;\n  // }\n\n  float lifePercent = finalLifeMs / maxLifeMs;\n  vec2 transformedPos = (u_matrix * u_transform * vec4(finalPosition,0.,1.)).xy;\n  float scale = sqrt(u_transform[0][0] * u_transform[0][0] + u_transform[1][1] * u_transform[1][1]);\n  gl_Position = vec4(transformedPos, 1.0 - lifePercent, 1.); // use life percent to sort z\n  gl_PointSize = mix(startSize, endSize, 1.0 - lifePercent) * scale;\n}";
const particleFragmentSource = "#version 300 es\nprecision mediump float;\n\nuniform sampler2D graphic;\nuniform bool useTexture;\nuniform float maxLifeMs;\n\nuniform vec4 beginColor;\nuniform vec4 endColor;\nuniform bool fade;\nuniform float startOpacity;\n\nin float finalRotation;\nin float finalLifeMs;\nout vec4 fragColor;\n\nvoid main(){\n\n  float lifePct = finalLifeMs / maxLifeMs;\n\n  if (useTexture) {\n    /** Draw texture */\n    if (lifePct <= 0.) discard;\n    float mid = .5;\n    float cosine = cos(finalRotation);\n    float sine = sin(finalRotation);\n    vec2 rotated = vec2(cosine * (gl_PointCoord.x - mid) + sine * (gl_PointCoord.y - mid) + mid,\n                        cosine * (gl_PointCoord.y - mid) - sine * (gl_PointCoord.x - mid) + mid);\n    vec4 color = texture(graphic, rotated);\n    fragColor = color * (fade ? lifePct : 1.0);\n  } else {\n    /** Draw circle */\n    if (lifePct <= 0.) discard;\n    vec2 uv = gl_PointCoord.xy * 2.0 - 1.0;\n    float dist = 1.0 - length(uv);\n    float edge = fwidth(dot(uv, uv));\n    float circle = smoothstep(-edge/2.0, edge/2.0, dist);\n    vec3 color = mix(beginColor.rgb, endColor.rgb, 1.0 - lifePct);\n    fragColor.rgb = color;\n    fragColor.a = startOpacity * circle * (fade ? lifePct : 1.0);// * mix(beginColor.a, endColor.a, 1.0 - lifePct);\n    fragColor.rgb *= fragColor.a;\n  }\n}";
class GlobalCoordinates {
  constructor(worldPos, pagePos, screenPos) {
    this.worldPos = worldPos;
    this.pagePos = pagePos;
    this.screenPos = screenPos;
  }
  static fromPagePosition(xOrPos, yOrEngine, engineOrUndefined) {
    let pageX;
    let pageY;
    let pagePos;
    let engine;
    if (arguments.length === 3) {
      pageX = xOrPos;
      pageY = yOrEngine;
      pagePos = new Vector(pageX, pageY);
      engine = engineOrUndefined;
    } else {
      pagePos = xOrPos;
      pageX = pagePos.x;
      pageY = pagePos.y;
      engine = yOrEngine;
    }
    const screenPos = engine.screen.pageToScreenCoordinates(pagePos);
    const worldPos = engine.screen.screenToWorldCoordinates(screenPos);
    return new GlobalCoordinates(worldPos, pagePos, screenPos);
  }
}
function lerp(a, b, time) {
  return (1 - time) * a + b * time;
}
function lerpAngle(startAngle, endAngle, rotationType, time) {
  const shortestPathIsPositive = (startAngle - endAngle + TwoPI) % TwoPI >= Math.PI;
  const distance1 = Math.abs(endAngle - startAngle);
  const distance2 = TwoPI - distance1;
  let shortDistance = 0;
  let longDistance = 0;
  if (distance1 > distance2) {
    shortDistance = distance2;
    longDistance = distance1;
  } else {
    shortDistance = distance1;
    longDistance = distance2;
  }
  let distance = 0;
  let direction = 1;
  switch (rotationType) {
    case RotationType.ShortestPath:
      distance = shortDistance;
      direction = shortestPathIsPositive ? 1 : -1;
      break;
    case RotationType.LongestPath:
      distance = longDistance;
      direction = shortestPathIsPositive ? -1 : 1;
      break;
    case RotationType.Clockwise:
      direction = 1;
      distance = shortestPathIsPositive ? shortDistance : longDistance;
      break;
    case RotationType.CounterClockwise:
      direction = -1;
      distance = shortestPathIsPositive ? longDistance : shortDistance;
      break;
  }
  return startAngle + direction * (distance * time);
}
function lerpVector(a, b, time) {
  return a.scale(1 - time).add(b.scale(time));
}
function inverseLerp(a, b, value) {
  return (value - a) / (b - a);
}
function inverseLerpVector(a, b, value) {
  const numerator = value.sub(a);
  const denominator = b.sub(a);
  const x = numerator.x / denominator.x;
  const y = numerator.y / denominator.y;
  return Math.min(x, y);
}
function remap(minSource, maxSource, minDestination, maxDestination, value) {
  const time = inverseLerp(minSource, maxSource, value);
  return lerp(minDestination, maxDestination, time);
}
function remapVector(minSource, maxSource, minDestination, maxDestination, value) {
  const time = inverseLerpVector(minSource, maxSource, value);
  return lerpVector(minDestination, maxDestination, time);
}
class BezierCurve {
  constructor(options) {
    this._distLookup = [];
    this.quality = 4;
    var _a;
    if (options.controlPoints.length !== 4) {
      throw new Error("Only cubic bezier curves are supported");
    }
    this._controlPoints = [...options.controlPoints];
    this.quality = (_a = options.quality) != null ? _a : this.quality;
    this._calculateLookup();
  }
  get arcLength() {
    return this._arcLength;
  }
  get controlPoints() {
    return this._controlPoints;
  }
  set controlPoints(points) {
    this._controlPoints = [...points];
    this._calculateLookup();
  }
  setControlPoint(index, point2) {
    this._controlPoints[index] = point2;
    this._calculateLookup();
  }
  _calculateLookup() {
    let totalLength = 0;
    this._distLookup.length = 0;
    let prev = this.controlPoints[0];
    const n = this.controlPoints.length * this.quality;
    for (let i = 0; i < n; i++) {
      const t = i / (n - 1);
      const pt = this.getPoint(t);
      const diff = prev.distance(pt);
      totalLength += diff;
      this._distLookup.push(totalLength);
      prev = pt;
    }
    this._arcLength = totalLength;
  }
  _getTimeGivenDistance(distance) {
    const n = this._distLookup.length;
    const arcLength = this.arcLength;
    if (distance >= 0 && distance < arcLength) {
      for (let i = 0; i < n - 1; i++) {
        if (this._distLookup[i] <= distance && distance < this._distLookup[i + 1]) {
          return remap(this._distLookup[i], this._distLookup[i + 1], i / (n - 1), (i + 1) / (n - 1), distance);
        }
      }
    }
    return distance / arcLength;
  }
  /**
   * Get the point on the Bezier curve at a certain time
   * @param time Between 0-1
   */
  getPoint(time) {
    const points = [...this.controlPoints];
    for (let r = 1; r < points.length; r++) {
      for (let i = 0; i < points.length - r; i++) {
        points[i] = lerpVector(points[i], points[i + 1], time);
      }
    }
    return points[0];
  }
  /**
   * Get the tangent of the Bezier curve at a certain time
   * @param time Between 0-1
   */
  getTangent(time) {
    const timeSquared = time * time;
    const p0 = this.controlPoints[0];
    const p1 = this.controlPoints[1];
    const p2 = this.controlPoints[2];
    const p3 = this.controlPoints[3];
    const pPrime = p0.scale(-3 * timeSquared + 6 * time - 3).add(p1.scale(9 * timeSquared - 12 * time + 3).add(p2.scale(-9 * timeSquared + 6 * time).add(p3.scale(3 * timeSquared))));
    return pPrime.normalize();
  }
  /**
   * Get the tangent of the Bezier curve where the distance is uniformly distributed over time
   * @param time
   */
  getUniformTangent(time) {
    const desiredDistance = time * this.arcLength;
    const uniformTime = this._getTimeGivenDistance(desiredDistance);
    return this.getTangent(uniformTime);
  }
  /**
   * Get the normal of the Bezier curve at a certain time
   * @param time Between 0-1
   */
  getNormal(time) {
    return this.getTangent(time).normal();
  }
  /**
   * Get the normal of the Bezier curve where the distance is uniformly distributed over time
   * @param time
   */
  getUniformNormal(time) {
    return this.getUniformTangent(time).normal();
  }
  /**
   * Points are spaced uniformly across the length of the curve over time
   * @param time
   */
  getUniformPoint(time) {
    const desiredDistance = time * this.arcLength;
    const uniformTime = this._getTimeGivenDistance(desiredDistance);
    return this.getPoint(uniformTime);
  }
  clone() {
    return new BezierCurve({
      controlPoints: [...this.controlPoints],
      quality: this.quality
    });
  }
}
class Graph {
  /**
   * Constructs a new graph data structure.
   *
   * This constructor initializes an empty graph with no nodes or edges.
   */
  constructor() {
    this.id = GraphUUId.generateUUID();
    this._nodes = /* @__PURE__ */ new Map();
    this._edges = /* @__PURE__ */ new Set();
    this.adjacencyList = /* @__PURE__ */ new Map();
  }
  /**
   * Adds a new node to the graph with the given data.
   * @returns The newly created node.
   */
  addNode(data, position) {
    let newNode;
    if (position) {
      newNode = new PositionNode(data, position);
    } else {
      newNode = new Node(data);
    }
    this._nodes.set(newNode.id, newNode);
    this.adjacencyList.set(newNode.id, /* @__PURE__ */ new Set());
    return newNode;
  }
  /**
   * Adds multiple new nodes to the graph with the given data.
   * @returns A map of all nodes in the graph, including the newly created ones.
   */
  addNodes(nodes) {
    for (const node of nodes) {
      const thisNewNode = new Node(node);
      this._nodes.set(thisNewNode.id, thisNewNode);
      this.adjacencyList.set(thisNewNode.id, /* @__PURE__ */ new Set());
    }
    return this._nodes;
  }
  /**
   * Deletes a node from the graph along with all its associated edges.
   * This method removes the specified node and any edges connected to it
   * from the graph. It updates the internal structures to reflect these
   * changes.
   * @param node - The node to be deleted from the graph.
   * @returns A map of all remaining nodes in the graph.
   */
  deleteNode(node) {
    const nodeEdges = node.edges;
    for (const edge of nodeEdges) {
      this.deleteEdge(edge);
    }
    this.adjacencyList.forEach((value, key) => {
      value.delete(node.id);
    });
    this._nodes.delete(node.id);
    this.adjacencyList.delete(node.id);
    return this._nodes;
  }
  /**
   * Adds a new edge between two nodes in the graph. If the edge already exists, it does not add a duplicate.
   * The function allows specifying edge options such as weight and directionality. For undirected edges,
   * it creates a duplicate edge in the reverse direction and links both edges as partners.
   * @param from - The source node of the edge.
   * @param to - The target node of the edge.
   * @param options - Optional settings for the edge, including weight and directionality.
   * @returns An array containing the created edge(s). If the edge is directed, the array contains one edge;
   *          if undirected, it contains both the original and the duplicate edge.
   */
  addEdge(from, to, options) {
    var _a, _b;
    const existingEdges = Array.from(this._edges).find((edge) => edge.source.id === from.id && edge.target.id === to.id);
    if (existingEdges) {
      return [];
    }
    let directed;
    if (options) {
      directed = "directed" in options ? options.directed : false;
    } else {
      directed = false;
    }
    const newEdge = new Edge(from, to, options);
    this._edges.add(newEdge);
    from.registerNewEdge(newEdge);
    to.registerNewEdge(newEdge);
    (_a = this.adjacencyList.get(from.id)) == null ? void 0 : _a.add(to.id);
    if (!directed) {
      const duplicateEdge = new Edge(to, from, options);
      (_b = this.adjacencyList.get(to.id)) == null ? void 0 : _b.add(from.id);
      this._edges.add(duplicateEdge);
      to.registerNewEdge(duplicateEdge);
      from.registerNewEdge(duplicateEdge);
      newEdge.linkWithPartner(duplicateEdge);
      duplicateEdge.linkWithPartner(newEdge);
      return [newEdge, duplicateEdge];
    }
    return [newEdge];
  }
  /**
   * Deletes an edge from the graph.
   *
   * This method removes the specified edge and its partner edge (if any) from the graph.
   * It updates the internal edge set and edge list accordingly. The source and target
   * nodes of the edge are also updated to reflect the removal of the edge.
   * @param edge - The edge to be deleted from the graph.
   */
  deleteEdge(edge) {
    edge.source.breakEdge(edge);
    edge.target.breakEdge(edge);
    this._edges.delete(edge);
    const partnerEdge = edge.partnerEdge;
    if (partnerEdge) {
      partnerEdge.source.breakEdge(partnerEdge);
      partnerEdge.target.breakEdge(partnerEdge);
      this._edges.delete(partnerEdge);
    }
  }
  /**
   * The set of nodes in the graph, keyed by their UUID.
   *
   * The map returned by this property is a shallow copy of the internal map.
   * The nodes in this map are not frozen, and may be modified by the caller.
   * @returns A shallow copy of the graph's internal node map.
   */
  get nodes() {
    return this._nodes;
  }
  /**
   * Gets a node by its UUID.
   * @param id - The UUID of the node to be retrieved.
   * @returns The node with the specified UUID, or undefined if no such node exists.
   */
  getNode(id) {
    return this._nodes.get(id);
  }
  /**
   * Retrieves the set of edges in the graph.
   *
   * The returned set is a shallow copy of the internal edge set.
   * Modifications to this set do not affect the graph's internal state.
   * @returns A set containing all edges in the graph.
   */
  get edges() {
    return this._edges;
  }
  /**
   * Gets the neighbors of the given node.
   *
   * The returned array contains all of the nodes that are directly connected to the given node.
   * @param node - The node whose neighbors should be retrieved.
   * @returns An array of nodes that are directly connected to the given node.
   */
  getNeighbors(node) {
    var _a;
    return Array.from((_a = this.adjacencyList.get(node.id)) != null ? _a : []).map((nid) => this.nodes.get(nid));
  }
  /**
   * Checks if two nodes are connected by an edge.
   * @param node1 - The first node to check.
   * @param node2 - The second node to check.
   * @returns true if the nodes are connected, false if not.
   */
  areNodesConnected(node1, node2) {
    var _a, _b;
    return (_b = (_a = this.adjacencyList.get(node1.id)) == null ? void 0 : _a.has(node2.id)) != null ? _b : false;
  }
  /**
   * Performs a breadth-first search (BFS) on the graph starting from the given node.
   *
   * This method explores the graph layer by layer, starting from the specified node.
   * It visits all nodes that are directly connected to the start node before moving
   * on to the nodes at the next level of the graph.
   * @param startNode - The node to start the BFS from.
   * @returns An array of UUIDs representing the nodes that were visited during the search.
   *          The order of the nodes in the array corresponds to the order in which they
   *          were visited.
   */
  bfs(startNode) {
    if (!this._nodes.has(startNode.id)) {
      return [];
    }
    const queue = [startNode.id];
    const visited = /* @__PURE__ */ new Set([startNode.id]);
    while (queue.length > 0) {
      const nodeId = queue.shift();
      const neighbors = this.adjacencyList.get(nodeId) || /* @__PURE__ */ new Set();
      for (const neighborId of neighbors) {
        if (!visited.has(neighborId)) {
          visited.add(neighborId);
          queue.push(neighborId);
        }
      }
    }
    return Array.from(visited);
  }
  /**
   * Performs a depth-first search (DFS) on the graph starting from the given node.
   *
   * This method explores the graph by traversing as far as possible along each
   * branch before backtracking. It visits all nodes that are reachable from the
   * start node.
   * @param startNode - The node to start the DFS from.
   * @param [visited] - A set of node IDs that have already been visited during
   *                    the search. This parameter is optional, and defaults to an
   *                    empty set.
   * @returns An array of UUIDs representing the nodes that were visited during the
   *          search. The order of the nodes in the array corresponds to the order
   *          in which they were visited.
   */
  dfs(startNode, visited = /* @__PURE__ */ new Set()) {
    var _a;
    const startId = startNode.id;
    if (!this._nodes.has(startId)) {
      return [];
    }
    visited.add(startId);
    let result = [startId];
    for (const neighbor of (_a = this.adjacencyList.get(startId)) != null ? _a : []) {
      if (!visited.has(neighbor)) {
        result = result.concat(this.dfs(this._nodes.get(neighbor), visited));
      }
    }
    return result;
  }
  /**
   * Creates a new graph from an array of nodes, and adds them all to the graph.
   * @param nodes - The array of nodes to add to the graph.
   * @returns The newly created graph.
   */
  static createGraphFromNodes(nodes) {
    const graph = new Graph();
    graph.addNodes(nodes);
    return graph;
  }
  /**
   * Finds the shortest path between two nodes in the graph using Dijkstra's algorithm.
   *
   * This method calculates the shortest path from the specified start node to the
   * specified end node in the graph. It returns an object containing the path and
   * the total distance of the path.
   * @param startNode - The node from which the search for the shortest path begins.
   * @param endNode - The node where the search for the shortest path ends.
   * @returns An object containing:
   *   - `path`: An array of nodes representing the shortest path from startNode to endNode.
   *     If no path is found, this will be `null`.
   *   - `distance`: The total distance of the shortest path. If no path is found, this will
   *     be `Infinity`.
   */
  dijkstra(sourcenode) {
    const visited = [];
    const unvisited = [];
    const resultArray = [];
    this.nodes.forEach((node) => unvisited.push(node));
    this.nodes.forEach((node) => resultArray.push({ node, distance: Infinity, previous: null }));
    const startingNodeIndex = resultArray.findIndex((node) => node.node === sourcenode);
    if (startingNodeIndex === -1) {
      return [];
    }
    resultArray[startingNodeIndex].distance = 0;
    visited.push(sourcenode);
    unvisited.splice(unvisited.indexOf(sourcenode), 1);
    let current = sourcenode;
    const currentEdges = current.edges;
    const filteredCurrentEdges = Array.from(currentEdges).filter((edge) => edge.target !== current);
    for (const edge of filteredCurrentEdges) {
      const index = resultArray.findIndex((node) => node.node === edge.target);
      if (index === -1) {
        return [];
      }
      resultArray[index].distance = edge.weight;
      resultArray[index].previous = current;
    }
    while (unvisited.length > 0) {
      let listOfAvailableNodes = [];
      let listofAvailableEntries = [];
      listofAvailableEntries = resultArray.filter((node) => unvisited.includes(node.node));
      listOfAvailableNodes = listofAvailableEntries.map((node) => node.node);
      let lowestDistance = Infinity;
      let lowestDistanceIndex = -1;
      if (listOfAvailableNodes.length > 0) {
        for (let i = 0; i < listOfAvailableNodes.length; i++) {
          const unVisitiedNode = listOfAvailableNodes[i];
          const index = resultArray.findIndex((node) => node.node === unVisitiedNode);
          if (resultArray[index].distance < lowestDistance) {
            lowestDistance = resultArray[index].distance;
            lowestDistanceIndex = index;
          }
        }
      } else {
        lowestDistance = Infinity;
        lowestDistanceIndex = -1;
        for (let i = 0; i < unvisited.length; i++) {
          const unVisitiedNode = unvisited[i];
          const index = resultArray.findIndex((node) => node.node === unVisitiedNode);
          if (resultArray[index].distance < lowestDistance) {
            lowestDistance = resultArray[index].distance;
            lowestDistanceIndex = index;
          }
        }
      }
      if (lowestDistanceIndex === -1) {
        return [];
      }
      current = resultArray[lowestDistanceIndex].node;
      let currentEdgesArray = Array.from(current.edges);
      currentEdgesArray = currentEdgesArray.filter((edge) => {
        return !visited.includes(edge.source) && !visited.includes(edge.target) && edge.target !== current;
      });
      visited.push(current);
      unvisited.splice(unvisited.indexOf(current), 1);
      for (let i = 0; i < currentEdgesArray.length; i++) {
        const edge = currentEdgesArray[i];
        const index = resultArray.findIndex((node) => node.node === edge.target);
        const previousIndex = resultArray.findIndex((node) => node.node === edge.source);
        const previousDistance = resultArray[previousIndex].distance;
        const cumDistance = previousDistance + edge.weight;
        if (cumDistance < resultArray[index].distance) {
          resultArray[index].distance = cumDistance;
          resultArray[index].previous = current;
        }
      }
    }
    return resultArray;
  }
  /**
   * Finds the shortest path between two nodes in the graph using the Dijkstra method
   *
   * This method calculates the shortest path from the specified start node to the
   * specified end node in the graph. It returns an object containing the path and
   * the total distance of the path.
   * @param startingNode - The node from which the search for the shortest path begins.
   * @param endNode - The node where the search for the shortest path ends.
   * @returns An object containing:
   *   - `path`: An array of nodes representing the shortest path from startNode to endNode.
   *     If no path is found, this will be `null`.
   *   - `distance`: The total distance of the shortest path. If no path is found, this will
   *     be `Infinity`.
   */
  shortestPathDijkstra(startingNode, endNode) {
    var _a, _b;
    const dAnalysis = this.dijkstra(startingNode);
    if (dAnalysis.length === 0) {
      return { path: [], distance: Infinity };
    }
    const path = [];
    let current = endNode;
    const distance = (_a = dAnalysis.find((node) => node.node === endNode)) == null ? void 0 : _a.distance;
    while (current != null) {
      path.push(current);
      current = (_b = dAnalysis.find((node) => node.node === current)) == null ? void 0 : _b.previous;
      if (current == null) {
        break;
      }
    }
    path.reverse();
    return { path, distance };
  }
  /**
   * Finds the shortest path between two nodes in the graph using the A* algorithm.
   *
   * This method calculates the shortest path from the specified start node to the
   * specified end node in the graph. It returns an object containing the path and
   * the total distance of the path.
   * @param startNode - The node from which the search for the shortest path begins.
   * @param endNode - The node where the search for the shortest path ends.
   * @returns An object containing:
   *   - `path`: An array of nodes representing the shortest path from startNode to endNode.
   *     If no path is found, this will be `null`.
   *   - `distance`: The total distance of the shortest path. If no path is found, this will
   *     be `Infinity`.
   *   - `skippedNodes`: A set of all nodes that were skipped during the search (because they
   *     were not `PositionNode`s).
   */
  aStar(startNode, endNode) {
    if (!("pos" in startNode) || !("pos" in endNode)) {
      throw new Error("A* algorithm requires PositionNode with position vectors");
    }
    const openSet = /* @__PURE__ */ new Set([startNode.id]);
    const closedSet = /* @__PURE__ */ new Set();
    const skippedNodes = /* @__PURE__ */ new Set();
    const gScore = /* @__PURE__ */ new Map();
    const hScore = /* @__PURE__ */ new Map();
    const fScore = /* @__PURE__ */ new Map();
    const cameFrom = /* @__PURE__ */ new Map();
    const positionNodes = /* @__PURE__ */ new Map();
    for (const [nodeId, node] of this._nodes) {
      if ("pos" in node) {
        positionNodes.set(nodeId, node);
      } else {
        skippedNodes.add(nodeId);
      }
    }
    for (const [nodeId] of positionNodes) {
      gScore.set(nodeId, this._euclideanDistance(positionNodes.get(nodeId), startNode));
      hScore.set(nodeId, this._euclideanDistance(positionNodes.get(nodeId), endNode));
      fScore.set(nodeId, gScore.get(nodeId) + hScore.get(nodeId));
      cameFrom.set(nodeId, null);
    }
    while (openSet.size > 0) {
      let currentId = null;
      let lowestFScore = Infinity;
      for (const nodeId of openSet) {
        const score = fScore.get(nodeId) || Infinity;
        if (score < lowestFScore) {
          lowestFScore = score;
          currentId = nodeId;
        }
      }
      if (currentId === null) {
        break;
      }
      if (currentId === endNode.id) {
        const path = [];
        let current = endNode.id;
        while (current !== null) {
          const node = this._nodes.get(current);
          path.unshift(node);
          current = cameFrom.get(current);
        }
        return {
          path,
          pathSteps: path.length - 1,
          distance: gScore.get(endNode.id) || Infinity,
          skippedNodes
        };
      }
      openSet.delete(currentId);
      closedSet.add(currentId);
      const currentNode = this._nodes.get(currentId);
      const neighbors = this.getNeighbors(currentNode);
      for (const neighbor of neighbors) {
        const neighborId = neighbor.id;
        if (closedSet.has(neighborId)) {
          continue;
        }
        const positionNeighbor = neighbor;
        if (!("pos" in positionNeighbor)) {
          continue;
        }
        const edge = Array.from(currentNode.edges).find((e) => e.source.id === currentId && e.target.id === neighborId);
        if (!edge) {
          continue;
        }
        cameFrom.set(neighborId, currentId);
        if (!openSet.has(neighborId)) {
          openSet.add(neighborId);
        }
      }
    }
    return { path: [], pathSteps: 0, distance: Infinity, skippedNodes };
  }
  _euclideanDistance(currentNode, testNode) {
    const a = currentNode.pos;
    const b = testNode.pos;
    return Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);
  }
}
class Edge {
  // Reference to the opposite direction edge
  constructor(source, target, config) {
    this._id = GraphUUId.generateUUID();
    this._weight = 0;
    this._partnerEdge = null;
    this._source = source;
    this._target = target;
    if (config && config.weight) {
      this._weight = config.weight;
    } else if (config && config.useEuclidean) {
      this._weight = source.pos.distance(target.pos);
    } else {
      this._weight = 0;
    }
  }
  linkWithPartner(partnerEdge) {
    this._partnerEdge = partnerEdge;
  }
  get id() {
    return this._id;
  }
  get source() {
    return this._source;
  }
  get target() {
    return this._target;
  }
  get weight() {
    return this._weight;
  }
  get partnerEdge() {
    return this._partnerEdge;
  }
}
class Node {
  constructor(data) {
    this._id = GraphUUId.generateUUID();
    this._data = data;
    this._edges = /* @__PURE__ */ new Set();
  }
  get id() {
    return this._id;
  }
  get data() {
    return this._data;
  }
  get edges() {
    return this._edges;
  }
  registerNewEdge(newEdge) {
    this._edges.add(newEdge);
  }
  breakEdge(edge) {
    this._edges.delete(edge);
  }
  getConnectedNodes() {
    return Array.from(this._edges).map((edge) => edge.target);
  }
}
class PositionNode extends Node {
  constructor(data, pos) {
    super(data);
    this.pos = pos;
  }
}
const _GraphUUId = class _GraphUUId2 {
  static generateUUID() {
    const uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
    const generatedUuid = uuid.replace(/[xy]/g, function(c) {
      const r = _GraphUUId2.rng.next() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
    return generatedUuid;
  }
};
_GraphUUId.rng = new Random();
let GraphUUId = _GraphUUId;
const _EulerIntegrator = class _EulerIntegrator2 {
  static integrate(transform, motion, totalAcc, elapsed) {
    const seconds = elapsed / 1e3;
    motion.vel.addEqual(totalAcc.scale(seconds, _EulerIntegrator2._ACC));
    motion.vel.setTo(clamp(motion.vel.x, -motion.maxVel.x, motion.maxVel.x), clamp(motion.vel.y, -motion.maxVel.y, motion.maxVel.y));
    transform.pos.add(motion.vel.scale(seconds, _EulerIntegrator2._VEL), _EulerIntegrator2._POS).addEqual(totalAcc.scale(0.5 * seconds * seconds, _EulerIntegrator2._VEL_ACC));
    motion.angularVelocity += motion.torque * (1 / motion.inertia) * seconds;
    const rotation = transform.rotation + motion.angularVelocity * seconds;
    transform.scale.add(motion.scaleFactor.scale(seconds, this._SCALE_FACTOR), _EulerIntegrator2._SCALE);
    const tx = transform.get();
    tx.setTransform(_EulerIntegrator2._POS, rotation, _EulerIntegrator2._SCALE);
  }
};
_EulerIntegrator._POS = new Vector(0, 0);
_EulerIntegrator._SCALE = new Vector(1, 1);
_EulerIntegrator._ACC = new Vector(0, 0);
_EulerIntegrator._VEL = new Vector(0, 0);
_EulerIntegrator._VEL_ACC = new Vector(0, 0);
_EulerIntegrator._SCALE_FACTOR = new Vector(0, 0);
let EulerIntegrator = _EulerIntegrator;
class Particle extends Entity {
  constructor(options) {
    super();
    this.beginColor = Color.White;
    this.endColor = Color.White;
    this.life = 300;
    this.fade = false;
    this._rRate = 1;
    this._gRate = 1;
    this._bRate = 1;
    this._aRate = 0;
    this._currentColor = Color.White;
    this.size = 5;
    this.sizeRate = 0;
    this.visible = true;
    this.isOffscreen = false;
    this.particleTransform = "global";
    this.name = `Particle#${this.id}`;
    this.addComponent(this.transform = new TransformComponent());
    this.addComponent(this.motion = new MotionComponent());
    this.addComponent(this.graphics = new GraphicsComponent());
    this.configure(options);
  }
  registerEmitter(emitter) {
    this._emitter = emitter;
    if (this.particleTransform === "global") {
      const globalPos = this._emitter.transform.globalPos;
      this.transform.pos = this.transform.pos.add(globalPos);
      this.motion.vel = this.motion.vel.rotate(this._emitter.transform.globalRotation);
    }
  }
  configure(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    this.particleTransform = (_a = options.transform) != null ? _a : this.particleTransform;
    this.life = (_b = options.life) != null ? _b : this.life;
    this.fade = (_c = options.fade) != null ? _c : this.fade;
    this.size = (_d = options.size) != null ? _d : this.size;
    this.endColor = (_e = options.endColor) != null ? _e : this.endColor.clone();
    this.beginColor = (_f = options.beginColor) != null ? _f : this.beginColor.clone();
    this._currentColor = this.beginColor.clone();
    this.graphic = options.graphic;
    this.graphics.opacity = (_g = options.opacity) != null ? _g : this.graphics.opacity;
    this.transform.pos = (_h = options.pos) != null ? _h : this.transform.pos;
    this.transform.rotation = (_i = options.rotation) != null ? _i : 0;
    this.transform.scale = vec(1, 1);
    this.transform.z = (_j = options.z) != null ? _j : 0;
    this.motion.vel = (_k = options.vel) != null ? _k : this.motion.vel;
    this.motion.angularVelocity = (_l = options.angularVelocity) != null ? _l : 0;
    this.motion.acc = (_m = options.acc) != null ? _m : this.motion.acc;
    this._rRate = (this.endColor.r - this.beginColor.r) / this.life;
    this._gRate = (this.endColor.g - this.beginColor.g) / this.life;
    this._bRate = (this.endColor.b - this.beginColor.b) / this.life;
    this._aRate = this.graphics.opacity / this.life;
    this.startSize = (_n = options.startSize) != null ? _n : 0;
    this.endSize = (_o = options.endSize) != null ? _o : 0;
    if (this.endSize > 0 && this.startSize > 0) {
      this.sizeRate = (this.endSize - this.startSize) / this.life;
      this.size = this.startSize;
    }
    if (this.graphic) {
      this.graphics.use(this.graphic);
      this.graphics.onPostDraw = void 0;
    } else {
      this.graphics.localBounds = BoundingBox.fromDimension(this.size, this.size, Vector.Half);
      this.graphics.onPostDraw = (ctx) => {
        ctx.save();
        ctx.debug.drawPoint(vec(0, 0), { color: this._currentColor, size: this.size });
        ctx.restore();
      };
    }
  }
  kill() {
    var _a;
    if ((_a = this._emitter) == null ? void 0 : _a.isActive) {
      this._emitter.removeParticle(this);
    } else {
      super.kill();
    }
  }
  update(engine, elapsed) {
    this.life = this.life - elapsed;
    if (this.life < 0) {
      this.kill();
    }
    if (this.fade) {
      this.graphics.opacity = clamp(this._aRate * this.life, 1e-4, 1);
    }
    if (this.startSize && this.endSize && this.startSize > 0 && this.endSize > 0) {
      this.size = clamp(
        this.sizeRate * elapsed + this.size,
        Math.min(this.startSize, this.endSize),
        Math.max(this.startSize, this.endSize)
      );
    }
    this._currentColor.r = clamp(this._currentColor.r + this._rRate * elapsed, 0, 255);
    this._currentColor.g = clamp(this._currentColor.g + this._gRate * elapsed, 0, 255);
    this._currentColor.b = clamp(this._currentColor.b + this._bRate * elapsed, 0, 255);
    this._currentColor.a = this.graphics.opacity;
    let accel = this.motion.acc;
    if (this.focus) {
      accel = this.focus.sub(this.transform.pos).normalize().scale(this.focusAccel || 0).scale(elapsed / 1e3);
    }
    EulerIntegrator.integrate(this.transform, this.motion, accel, elapsed);
  }
}
Particle.DefaultConfig = {
  beginColor: Color.White,
  endColor: Color.White,
  life: 300,
  fade: false,
  size: 5,
  graphic: void 0,
  startSize: void 0,
  endSize: void 0
};
var ParticleTransform = /* @__PURE__ */ ((ParticleTransform2) => {
  ParticleTransform2["Global"] = "global";
  ParticleTransform2["Local"] = "local";
  return ParticleTransform2;
})(ParticleTransform || {});
class ParticleRenderer {
  constructor() {
    this.type = "ex.particle";
    this.priority = 0;
  }
  initialize(gl, context) {
    this._gl = gl;
    this._context = context;
    this._shader = new Shader({
      graphicsContext: context,
      vertexSource: particleVertexSource,
      fragmentSource: particleFragmentSource,
      onPreLink: (program) => {
        gl.transformFeedbackVaryings(
          program,
          ["finalPosition", "finalVelocity", "finalRotation", "finalAngularVelocity", "finalLifeMs"],
          gl.INTERLEAVED_ATTRIBS
        );
      }
    });
    this._shader.compile();
    this._shader.use();
    this._shader.setUniformMatrix("u_matrix", this._context.ortho);
  }
  _getTexture(image) {
    const maybeFiltering = image.getAttribute(ImageSourceAttributeConstants.Filtering);
    const filtering = maybeFiltering ? parseImageFiltering(maybeFiltering) : void 0;
    const wrapX = parseImageWrapping(image.getAttribute(ImageSourceAttributeConstants.WrappingX));
    const wrapY = parseImageWrapping(image.getAttribute(ImageSourceAttributeConstants.WrappingY));
    const force = image.getAttribute("forceUpload") === "true" ? true : false;
    const texture = this._context.textureLoader.load(
      image,
      {
        filtering,
        wrapping: { x: wrapX, y: wrapY }
      },
      force
    );
    image.removeAttribute("forceUpload");
    return texture;
  }
  draw(renderer, elapsed) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const gl = this._gl;
    this._shader.use();
    this._shader.setUniformMatrix("u_matrix", this._context.ortho);
    const transform = renderer.particle.transform === ParticleTransform.Local ? this._context.getTransform() : this._context.getTransform().multiply(renderer.emitter.transform.get().inverse);
    this._shader.setUniformAffineMatrix("u_transform", transform);
    this._shader.setUniformBoolean("fade", renderer.particle.fade ? true : false);
    this._shader.setUniformBoolean("useTexture", renderer.particle.graphic ? true : false);
    this._shader.setUniformFloat("maxLifeMs", (_a = renderer.particle.life) != null ? _a : 2e3);
    this._shader.setUniformFloat("deltaMs", elapsed);
    this._shader.setUniformFloatVector("gravity", (_b = renderer.particle.acc) != null ? _b : vec(0, 0));
    this._shader.setUniformFloatColor("beginColor", (_c = renderer.particle.beginColor) != null ? _c : Color.Transparent);
    this._shader.setUniformFloatColor("endColor", (_d = renderer.particle.endColor) != null ? _d : Color.Transparent);
    let startSize = (_e = renderer.particle.startSize) != null ? _e : 0;
    let endSize = (_f = renderer.particle.endSize) != null ? _f : 0;
    const size = (_g = renderer.particle.size) != null ? _g : 0;
    if (size > 0) {
      startSize = size;
      endSize = size;
    }
    this._shader.setUniformFloat("startSize", startSize != null ? startSize : 10);
    this._shader.setUniformFloat("endSize", endSize != null ? endSize : 10);
    this._shader.setUniformFloat("startOpacity", (_h = renderer.particle.opacity) != null ? _h : 1);
    if (renderer.particle.focus) {
      this._shader.setUniformFloatVector("focus", renderer.particle.focus);
      this._shader.setUniformFloat("focusAccel", (_i = renderer.particle.focusAccel) != null ? _i : 0);
    }
    if (renderer.particle.graphic) {
      const graphic = renderer.particle.graphic;
      const texture = this._getTexture(graphic.image.image);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      this._shader.setUniformInt("graphic", 0);
    }
    renderer.draw(gl);
  }
  hasPendingDraws() {
    return false;
  }
  flush() {
  }
  dispose() {
  }
}
class VertexBuffer {
  constructor(options) {
    this.type = "dynamic";
    const { gl, size, type, data } = options;
    this._gl = gl;
    this.buffer = this._gl.createBuffer();
    if (!data && !size) {
      throw Error("Must either provide data or a size to the VertexBuffer");
    }
    if (!data) {
      this.bufferData = new Float32Array(size);
    } else {
      this.bufferData = data;
    }
    this.type = type != null ? type : this.type;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === "static" ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);
  }
  /**
   * Bind this vertex buffer
   */
  bind() {
    const gl = this._gl;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
  }
  unbind() {
    const gl = this._gl;
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
  }
  /**
   * Upload vertex buffer geometry to the GPU
   */
  upload(count) {
    const gl = this._gl;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
    if (count) {
      gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bufferData, 0, count);
    } else {
      gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === "static" ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);
    }
  }
  dispose() {
    const gl = this._gl;
    gl.deleteBuffer(this.buffer);
    this._gl = null;
  }
}
class VertexLayout {
  constructor(options) {
    this._logger = Logger.getInstance();
    this._suppressWarnings = false;
    this._layout = [];
    this._attributes = [];
    this._vertexTotalSizeBytes = 0;
    this._initialized = false;
    const { gl, shader, vertexBuffer, attributes, suppressWarnings } = options;
    this._gl = gl;
    this._vertexBuffer = vertexBuffer;
    this._attributes = attributes;
    this._shader = shader;
    this._suppressWarnings = suppressWarnings;
    if (shader) {
      this.initialize();
    }
  }
  get vertexBuffer() {
    return this._vertexBuffer;
  }
  get attributes() {
    return this._attributes;
  }
  /**
   * Total number of bytes that the vertex will take up
   */
  get totalVertexSizeBytes() {
    return this._vertexTotalSizeBytes;
  }
  set shader(shader) {
    if (shader && this._shader !== shader) {
      this._shader = shader;
      this.initialize();
    }
  }
  get shader() {
    return this._shader;
  }
  /**
   * Layouts need shader locations and must be bound to a shader
   */
  initialize() {
    if (this._initialized) {
      return;
    }
    if (!this._shader) {
      return;
    }
    if (!this._shader.compiled) {
      throw Error("Shader not compiled, shader must be compiled before defining a vertex layout");
    }
    this._vertexTotalSizeBytes = 0;
    this._layout.length = 0;
    const shaderAttributes = this._shader.attributes;
    for (const attribute of this._attributes) {
      const attrib = shaderAttributes[attribute[0]];
      if (!attrib) {
        if (!isAttributeInSource(this._shader.vertexSource, attribute[0])) {
          throw Error(
            `The attribute named: ${attribute[0]} size ${attribute[1]} not found in the shader source code:
 ${this._shader.vertexSource}`
          );
        }
        if (!this._suppressWarnings) {
          this._logger.warn(
            `The attribute named: ${attribute[0]} size ${attribute[1]} not found in the compiled shader. This is possibly a bug:
 1. Not a bug, but should remove unused code - attribute "${attribute[0]}" is unused in vertex/fragment and has been automatically removed by glsl compiler.
 2. Definitely a bug, attribute "${attribute[0]}" in layout has been mistyped or is missing in shader, check vertex/fragment source.`
          );
        }
        const glType = getGLTypeFromSource(this._gl, this._shader.vertexSource, attribute[0]);
        this._layout.push({
          name: attribute[0],
          glType,
          size: attribute[1],
          location: -1,
          normalized: false
        });
      }
      if (attrib) {
        if (attrib.size !== attribute[1]) {
          throw Error(
            `VertexLayout size definition for attribute: [${attribute[0]}, ${attribute[1]}], doesn't match shader source size ${attrib.size}:
 ${this._shader.vertexSource}`
          );
        }
        this._layout.push(attrib);
      }
    }
    let componentsPerVertex = 0;
    for (const vertAttribute of this._layout) {
      const typeSize = getGlTypeSizeBytes(this._gl, vertAttribute.glType);
      this._vertexTotalSizeBytes += typeSize * vertAttribute.size;
      componentsPerVertex += vertAttribute.size;
    }
    if (this._vertexBuffer.bufferData.length % componentsPerVertex !== 0) {
      this._logger.warn(
        `The vertex component size (${componentsPerVertex})  does NOT divide evenly into the specified vertex buffer (${this._vertexBuffer.bufferData.length})`
      );
    }
    const gl = this._gl;
    this._vao = gl.createVertexArray();
    gl.bindVertexArray(this._vao);
    this._vertexBuffer.bind();
    let offset = 0;
    for (const vert2 of this._layout) {
      if (vert2.location !== -1) {
        if (vert2.glType === gl.INT) {
          gl.vertexAttribIPointer(vert2.location, vert2.size, vert2.glType, this.totalVertexSizeBytes, offset);
        } else {
          gl.vertexAttribPointer(vert2.location, vert2.size, vert2.glType, vert2.normalized, this.totalVertexSizeBytes, offset);
        }
        gl.enableVertexAttribArray(vert2.location);
      }
      offset += getGlTypeSizeBytes(gl, vert2.glType) * vert2.size;
    }
    gl.bindVertexArray(null);
    this._vertexBuffer.unbind();
    this._initialized = true;
  }
  /**
   * Bind this layout with it's associated vertex buffer
   * @param uploadBuffer Optionally indicate you wish to upload the buffer to the GPU associated with this layout
   */
  use(uploadBuffer = false, count) {
    if (!this._shader) {
      throw Error("No shader is associated with this vertex layout, a shader must be set");
    }
    const gl = this._gl;
    if (!this._shader.isCurrentlyBound()) {
      throw Error("Shader associated with this vertex layout is not active! Call shader.use() before layout.use()");
    }
    this._vertexBuffer.bind();
    if (uploadBuffer) {
      this._vertexBuffer.upload(count);
    }
    gl.bindVertexArray(this._vao);
  }
}
class ScreenShader {
  constructor(context, fragmentSource) {
    {
      if (fragmentSource.includes("v_texcoord")) {
        Logger.getInstance().warn(
          `ScreenShader: "v_texcoord" is deprecated in postprocessing fragment shaders will be removed in v1.0, use "v_uv" instead. Source [${fragmentSource}]`
        );
      }
    }
    const gl = context.__gl;
    this._shader = new Shader({
      graphicsContext: context,
      vertexSource: `#version 300 es
      in vec2 a_position;
      in vec2 a_uv;
      out vec2 v_texcoord;
      out vec2 v_uv;

      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        // Pass the texcoord to the fragment shader.
        v_texcoord = a_uv;
        v_uv = a_uv;
      }`,
      fragmentSource
    });
    this._shader.compile();
    this._buffer = new VertexBuffer({
      gl,
      type: "static",
      // clip space quad + uv since we don't need a camera
      data: new Float32Array([
        -1,
        -1,
        0,
        0,
        -1,
        1,
        0,
        1,
        1,
        -1,
        1,
        0,
        1,
        -1,
        1,
        0,
        -1,
        1,
        0,
        1,
        1,
        1,
        1,
        1
      ])
    });
    this._layout = new VertexLayout({
      gl,
      shader: this._shader,
      vertexBuffer: this._buffer,
      attributes: [
        ["a_position", 2],
        ["a_uv", 2]
      ]
    });
    this._buffer.upload();
  }
  getShader() {
    return this._shader;
  }
  getLayout() {
    return this._layout;
  }
}
var ColorBlindnessMode = /* @__PURE__ */ ((ColorBlindnessMode2) => {
  ColorBlindnessMode2["Protanope"] = "Protanope";
  ColorBlindnessMode2["Deuteranope"] = "Deuteranope";
  ColorBlindnessMode2["Tritanope"] = "Tritanope";
  return ColorBlindnessMode2;
})(ColorBlindnessMode || {});
const colorBlindCorrectSource = "#version 300 es\nprecision mediump float;\n// our texture\nuniform sampler2D u_image;\n// the texCoords passed in from the vertex shader.\nin vec2 v_texcoord;\n\n// color blind type\nuniform int u_type;\n\n// simulation?\nuniform bool u_simulate;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec4 o =  texture(u_image, v_texcoord);\n  // RGB to LMS matrix conversion\n  float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);\n  float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);\n  float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);\n  // Simulate color blindness\n  float l;\n  float m;\n  float s;\n  //MODE CODE//\n  if (u_type == 0) {\n    // Protanope\n    l = 0.0 * L + 2.02344 * M + -2.52581 * S;\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\n    s = 0.0 * L + 0.0 * M + 1.0 * S;;\n  } else if (u_type == 1) {\n    // Deuteranope\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\n    m = 0.494207 * L + 0.0 * M + 1.24827 * S;\n    s = 0.0 * L + 0.0 * M + 1.0 * S;\n  } else if (u_type == 2) {\n    // Tritanope\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\n    s = -0.395913 * L + 0.801109 * M + 0.0 * S;\n  }\n\n  // LMS to RGB matrix conversion\n  vec4 error; // simulate the colors\n  error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);\n  error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);\n  error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);\n  error.a = 1.0;\n  vec4 diff = o - error;\n  vec4 correction; // correct the colors\n  correction.r = 0.0;\n  correction.g =  (diff.r * 0.7) + (diff.g * 1.0);\n  correction.b =  (diff.r * 0.7) + (diff.b * 1.0);\n  correction = o + correction;\n  correction.a = o.a;\n  //SIMULATE//\n\n  // sim \n  if (u_simulate) {\n    fragColor = error.rgba;\n  } else {\n    fragColor = correction.rgba;\n  }\n}";
class ColorBlindnessPostProcessor {
  constructor(_colorBlindnessMode, simulate = false) {
    this._colorBlindnessMode = _colorBlindnessMode;
    this._simulate = false;
    this._simulate = simulate;
  }
  initialize(graphicsContext) {
    this._shader = new ScreenShader(graphicsContext, colorBlindCorrectSource);
    this.simulate = this._simulate;
    this.colorBlindnessMode = this._colorBlindnessMode;
  }
  getShader() {
    return this._shader.getShader();
  }
  getLayout() {
    return this._shader.getLayout();
  }
  set colorBlindnessMode(colorBlindMode) {
    this._colorBlindnessMode = colorBlindMode;
    if (this._shader) {
      const shader = this._shader.getShader();
      shader.use();
      if (this._colorBlindnessMode === ColorBlindnessMode.Protanope) {
        shader.setUniformInt("u_type", 0);
      } else if (this._colorBlindnessMode === ColorBlindnessMode.Deuteranope) {
        shader.setUniformInt("u_type", 1);
      } else if (this._colorBlindnessMode === ColorBlindnessMode.Tritanope) {
        shader.setUniformInt("u_type", 2);
      }
    }
  }
  get colorBlindnessMode() {
    return this._colorBlindnessMode;
  }
  set simulate(value) {
    this._simulate = value;
    if (this._shader) {
      const shader = this._shader.getShader();
      shader.use();
      shader.setUniformBoolean("u_simulate", value);
    }
  }
  get simulate() {
    return this._simulate;
  }
}
class QuadIndexBuffer {
  /**
   * @param gl WebGL2RenderingContext this layout will be attached to, these cannot be reused across contexts.
   * @param numberOfQuads Specify the max number of quads you want to draw
   * @param useUint16 Optionally force a uint16 buffer
   */
  constructor(gl, numberOfQuads, useUint16) {
    this._logger = Logger.getInstance();
    this._gl = gl;
    this.buffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
    const totalVertices = numberOfQuads * 6;
    if (!useUint16) {
      this.bufferData = new Uint32Array(totalVertices);
    } else {
      const maxUint16 = 65535;
      const maxUint16Index = Math.floor((maxUint16 - 1) / 4);
      this.bufferGlType = gl.UNSIGNED_SHORT;
      this.bufferData = new Uint16Array(totalVertices);
      if (numberOfQuads > maxUint16Index) {
        this._logger.warn(
          `Total quads exceeds hardware index buffer limit (uint16), max(${maxUint16Index}) requested quads(${numberOfQuads})`
        );
      }
    }
    let currentQuad = 0;
    for (let i = 0; i < totalVertices; i += 6) {
      this.bufferData[i + 0] = currentQuad + 0;
      this.bufferData[i + 1] = currentQuad + 1;
      this.bufferData[i + 2] = currentQuad + 2;
      this.bufferData[i + 3] = currentQuad + 2;
      this.bufferData[i + 4] = currentQuad + 1;
      this.bufferData[i + 5] = currentQuad + 3;
      currentQuad += 4;
    }
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);
  }
  get size() {
    return this.bufferData.length;
  }
  /**
   * Upload data to the GPU
   */
  upload() {
    const gl = this._gl;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);
  }
  /**
   * Bind this index buffer
   */
  bind() {
    const gl = this._gl;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
  }
  dispose() {
    const gl = this._gl;
    gl.deleteBuffer(this.buffer);
    this._gl = null;
  }
}
const defaultVertexSource = `#version 300 es
in vec2 a_position;

in vec2 a_uv;
out vec2 v_uv;

in vec2 a_screenuv;
out vec2 v_screenuv;

uniform mat4 u_matrix;
uniform mat4 u_transform;

void main() {
  // Set the vertex position using the ortho & transform matrix
  gl_Position = u_matrix * u_transform * vec4(a_position, 0.0, 1.0);

  // Pass through the UV coord to the fragment shader
  v_uv = a_uv;
  v_screenuv = a_screenuv;
}
`;
class Material {
  constructor(options) {
    this._logger = Logger.getInstance();
    this._color = Color.Transparent;
    this._initialized = false;
    this._images = {};
    this._uniforms = {};
    const { color, name, vertexSource, fragmentSource, graphicsContext, images, uniforms } = options;
    this._name = name != null ? name : "anonymous material";
    this._vertexSource = vertexSource != null ? vertexSource : defaultVertexSource;
    this._fragmentSource = fragmentSource;
    this._color = color != null ? color : this._color;
    this._uniforms = uniforms != null ? uniforms : this._uniforms;
    this._images = images != null ? images : this._images;
    if (!graphicsContext) {
      throw Error(`Material ${name} must be provided an excalibur webgl graphics context`);
    }
    if (graphicsContext instanceof ExcaliburGraphicsContextWebGL) {
      this._initialize(graphicsContext);
    } else {
      this._logger.warn(`Material ${name} was created in 2D Canvas mode, currently only WebGL is supported`);
    }
  }
  _initialize(graphicsContextWebGL) {
    if (this._initialized) {
      return;
    }
    this._shader = graphicsContextWebGL.createShader({
      name: this._name,
      vertexSource: this._vertexSource,
      fragmentSource: this._fragmentSource,
      uniforms: this._uniforms,
      images: this._images,
      // max texture slots
      // - 2 for the graphic texture and screen texture
      // - 1 if just graphic
      startingTextureSlot: this.isUsingScreenTexture ? 2 : 1
    });
    this._initialized = true;
  }
  get uniforms() {
    return this._shader.uniforms;
  }
  get images() {
    return this._shader.images;
  }
  get color() {
    return this._color;
  }
  set color(c) {
    this._color = c;
  }
  get name() {
    return this._name;
  }
  get isUsingScreenTexture() {
    return this._fragmentSource.includes("u_screen_texture");
  }
  update(callback) {
    if (this._shader) {
      this._shader.use();
      callback(this._shader);
    }
  }
  getShader() {
    return this._shader;
  }
  addImageSource(samplerName, image) {
    this._shader.addImageSource(samplerName, image);
  }
  removeImageSource(samplerName) {
    this._shader.removeImageSource(samplerName);
  }
  use() {
    if (this._initialized) {
      this._shader.use();
      this._shader.trySetUniformFloatColor("u_color", this._color);
    } else {
      throw Error(`Material ${this.name} not yet initialized, use the ExcaliburGraphicsContext.createMaterial() to work around this.`);
    }
  }
}
const _Debug = class _Debug2 {
  static registerGraphicsContext(ctx) {
    _Debug2._ctx = ctx;
  }
  static draw(debugDrawCall) {
    this._drawCalls.push(debugDrawCall);
  }
  static drawPoint(point2, options) {
    _Debug2.draw((ctx) => {
      ctx.debug.drawPoint(point2, options);
    });
  }
  static drawLine(start, end, options) {
    _Debug2.draw((ctx) => {
      ctx.debug.drawLine(start, end, options);
    });
  }
  static drawLines(points, options) {
    if (points.length > 1) {
      _Debug2.draw((ctx) => {
        for (let i = 0; i < points.length - 1; i++) {
          ctx.debug.drawLine(points[i], points[i + 1], options);
        }
      });
    }
  }
  static drawText(text, pos) {
    _Debug2.draw((ctx) => {
      ctx.debug.drawText(text, pos);
    });
  }
  static drawPolygon(points, options) {
    if (points.length > 1) {
      _Debug2.draw((ctx) => {
        const firstPoint = points[0];
        const polygon = [...points, firstPoint];
        for (let i = 0; i < polygon.length - 1; i++) {
          ctx.debug.drawLine(polygon[i], polygon[i + 1], options);
        }
      });
    }
  }
  static drawCircle(center, radius, options) {
    const { color, strokeColor, width } = {
      color: Color.Black,
      strokeColor: void 0,
      width: void 0,
      ...options
    };
    _Debug2.draw((ctx) => {
      ctx.drawCircle(center, radius, color, strokeColor, width);
    });
  }
  static drawBounds(boundingBox, options) {
    _Debug2.draw((ctx) => {
      ctx.debug.drawRect(boundingBox.left, boundingBox.top, boundingBox.width, boundingBox.height, options);
    });
  }
  static drawRay(ray, options) {
    const { distance, color } = {
      color: Color.Blue,
      distance: 10,
      ...options
    };
    _Debug2.draw((ctx) => {
      const start = ray.pos;
      const end = ray.pos.add(ray.dir.scale(distance));
      ctx.debug.drawLine(start, end, { color });
    });
  }
  static flush(ctx) {
    ctx.save();
    ctx.z = _Debug2.z;
    for (const drawCall of _Debug2._drawCalls) {
      drawCall(ctx);
    }
    ctx.restore();
    _Debug2.clear();
  }
  static clear() {
    _Debug2._drawCalls.length = 0;
  }
};
_Debug._drawCalls = [];
_Debug.z = Infinity;
let Debug = _Debug;
class LineRenderer {
  constructor() {
    this.type = "ex.line";
    this.priority = 0;
    this._maxLines = 10922;
    this._vertexIndex = 0;
    this._lineCount = 0;
    this._startScratch = vec(0, 0);
    this._endScratch = vec(0, 0);
  }
  initialize(gl, context) {
    this._gl = gl;
    this._context = context;
    this._shader = new Shader({
      graphicsContext: context,
      vertexSource: lineVertexSource,
      fragmentSource: lineFragmentSource
    });
    this._shader.compile();
    this._shader.use();
    this._shader.setUniformMatrix("u_matrix", this._context.ortho);
    this._vertexBuffer = new VertexBuffer({
      gl,
      size: 6 * 2 * this._maxLines,
      type: "dynamic"
    });
    this._layout = new VertexLayout({
      gl,
      vertexBuffer: this._vertexBuffer,
      shader: this._shader,
      attributes: [
        ["a_position", 2],
        ["a_color", 4]
      ]
    });
  }
  dispose() {
    this._vertexBuffer.dispose();
    this._shader.dispose();
    this._context = null;
    this._gl = null;
  }
  draw(start, end, color) {
    if (this._isFull()) {
      this.flush();
    }
    this._lineCount++;
    const transform = this._context.getTransform();
    const finalStart = transform.multiply(start, this._startScratch);
    const finalEnd = transform.multiply(end, this._endScratch);
    const vertexBuffer = this._vertexBuffer.bufferData;
    vertexBuffer[this._vertexIndex++] = finalStart.x;
    vertexBuffer[this._vertexIndex++] = finalStart.y;
    vertexBuffer[this._vertexIndex++] = color.r / 255;
    vertexBuffer[this._vertexIndex++] = color.g / 255;
    vertexBuffer[this._vertexIndex++] = color.b / 255;
    vertexBuffer[this._vertexIndex++] = color.a;
    vertexBuffer[this._vertexIndex++] = finalEnd.x;
    vertexBuffer[this._vertexIndex++] = finalEnd.y;
    vertexBuffer[this._vertexIndex++] = color.r / 255;
    vertexBuffer[this._vertexIndex++] = color.g / 255;
    vertexBuffer[this._vertexIndex++] = color.b / 255;
    vertexBuffer[this._vertexIndex++] = color.a;
  }
  _isFull() {
    if (this._lineCount >= this._maxLines) {
      return true;
    }
    return false;
  }
  hasPendingDraws() {
    return this._lineCount !== 0;
  }
  flush() {
    if (this._lineCount === 0) {
      return;
    }
    const gl = this._gl;
    this._shader.use();
    this._layout.use(true);
    this._shader.setUniformMatrix("u_matrix", this._context.ortho);
    gl.drawArrays(gl.LINES, 0, this._lineCount * 2);
    GraphicsDiagnostics.DrawnImagesCount += this._lineCount;
    GraphicsDiagnostics.DrawCallCount++;
    this._vertexIndex = 0;
    this._lineCount = 0;
  }
}
const pointVertexSource = "#version 300 es\nin vec2 a_position;\nin vec4 a_color;\nin float a_size;\nout lowp vec4 v_color;\nuniform mat4 u_matrix;\n\nvoid main() {\n  gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\n  gl_PointSize = a_size * 2.0;\n  v_color = a_color;\n}";
const pointFragmentSource = '#version 300 es\n\nprecision mediump float;\nin lowp vec4 v_color;\n\nout vec4 fragColor;\n\nvoid main() {\n  float r = 0.0, delta = 0.0, alpha = 1.0;\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\n  r = dot(cxy, cxy);\n\n  delta = fwidth(r);\n  alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\n  // "premultiply" the color by alpha\n  vec4 color = v_color;\n  color.a = color.a * alpha;\n  color.rgb = color.rgb * color.a;\n  fragColor = color;\n}';
class PointRenderer {
  constructor() {
    this.type = "ex.point";
    this.priority = 0;
    this._maxPoints = 10922;
    this._pointCount = 0;
    this._vertexIndex = 0;
  }
  initialize(gl, context) {
    this._gl = gl;
    this._context = context;
    this._shader = new Shader({
      graphicsContext: context,
      vertexSource: pointVertexSource,
      fragmentSource: pointFragmentSource
    });
    this._shader.compile();
    this._shader.use();
    this._shader.setUniformMatrix("u_matrix", this._context.ortho);
    this._buffer = new VertexBuffer({
      gl,
      size: 7 * this._maxPoints,
      type: "dynamic"
    });
    this._layout = new VertexLayout({
      gl,
      shader: this._shader,
      vertexBuffer: this._buffer,
      attributes: [
        ["a_position", 2],
        ["a_color", 4],
        ["a_size", 1]
      ]
    });
  }
  dispose() {
    this._buffer.dispose();
    this._shader.dispose();
    this._context = null;
    this._gl = null;
  }
  draw(point2, color, size) {
    if (this._isFull()) {
      this.flush();
    }
    this._pointCount++;
    const transform = this._context.getTransform();
    const opacity = this._context.opacity;
    const snapToPixel = this._context.snapToPixel;
    const finalPoint = transform.multiply(point2);
    if (snapToPixel) {
      finalPoint.x = ~~(finalPoint.x + pixelSnapEpsilon);
      finalPoint.y = ~~(finalPoint.y + pixelSnapEpsilon);
    }
    const vertexBuffer = this._buffer.bufferData;
    vertexBuffer[this._vertexIndex++] = finalPoint.x;
    vertexBuffer[this._vertexIndex++] = finalPoint.y;
    vertexBuffer[this._vertexIndex++] = color.r / 255;
    vertexBuffer[this._vertexIndex++] = color.g / 255;
    vertexBuffer[this._vertexIndex++] = color.b / 255;
    vertexBuffer[this._vertexIndex++] = color.a * opacity;
    vertexBuffer[this._vertexIndex++] = size * Math.max(transform.getScaleX(), transform.getScaleY());
  }
  _isFull() {
    if (this._pointCount >= this._maxPoints) {
      return true;
    }
    return false;
  }
  hasPendingDraws() {
    return this._pointCount !== 0;
  }
  flush() {
    if (this._pointCount === 0) {
      return;
    }
    const gl = this._gl;
    this._shader.use();
    this._layout.use(true);
    this._shader.setUniformMatrix("u_matrix", this._context.ortho);
    gl.drawArrays(gl.POINTS, 0, this._pointCount);
    GraphicsDiagnostics.DrawnImagesCount += this._pointCount;
    GraphicsDiagnostics.DrawCallCount++;
    this._pointCount = 0;
    this._vertexIndex = 0;
  }
}
const screenVertex = "#version 300 es\nin vec2 a_position;\n\nin vec2 a_texcoord;\nout vec2 v_texcoord;\n\nvoid main() {\n  gl_Position = vec4(a_position, 0.0, 1.0);\n\n  // Pass the texcoord to the fragment shader.\n  v_texcoord = a_texcoord;\n}";
const screenFragment = "#version 300 es\nprecision mediump float;\n\n// Passed in from the vertex shader.\nin vec2 v_texcoord;\n\n// The texture.\nuniform sampler2D u_texture;\n\nout vec4 fragColor;\n\nvoid main() {\n   fragColor = texture(u_texture, v_texcoord);\n}";
class ScreenPassPainter {
  constructor(context) {
    const gl = context.__gl;
    this._gl = gl;
    this._shader = new Shader({
      graphicsContext: context,
      vertexSource: screenVertex,
      fragmentSource: screenFragment
    });
    this._shader.compile();
    this._buffer = new VertexBuffer({
      gl,
      type: "static",
      // clip space quad + uv since we don't need a camera
      data: new Float32Array([
        -1,
        -1,
        0,
        0,
        -1,
        1,
        0,
        1,
        1,
        -1,
        1,
        0,
        1,
        -1,
        1,
        0,
        -1,
        1,
        0,
        1,
        1,
        1,
        1,
        1
      ])
    });
    this._layout = new VertexLayout({
      gl,
      shader: this._shader,
      vertexBuffer: this._buffer,
      attributes: [
        ["a_position", 2],
        ["a_texcoord", 2]
      ]
    });
    this._buffer.upload();
  }
  renderWithPostProcessor(postprocessor) {
    const gl = this._gl;
    const shader = postprocessor.getShader();
    shader.use();
    postprocessor.getLayout().use();
    gl.activeTexture(gl.TEXTURE0);
    shader.trySetUniformInt("u_image", 0);
    if (postprocessor.onDraw) {
      postprocessor.onDraw();
    }
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }
  renderToScreen() {
    const gl = this._gl;
    this._shader.use();
    this._layout.use();
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }
}
const frag$3 = "#version 300 es\nprecision mediump float;\n\n// UV coord\nin vec2 v_texcoord;\n\n// Texture index\nin lowp float v_textureIndex;\n\n// Textures in the current draw\nuniform sampler2D u_textures[%%count%%];\n\nuniform bool u_pixelart;\n\n// Opacity\nin float v_opacity;\n\nin vec4 v_tint;\n\nin vec2 v_res;\n\nout vec4 fragColor;\n\n// Inigo Quilez pixel art filter https://jorenjoestar.github.io/post/pixel_art_filtering/\nvec2 uv_iq(in vec2 uv, in vec2 texture_size) {\n  vec2 pixel = uv * texture_size;\n  \n  vec2 seam=floor(pixel+.5);\n  vec2 dudv=fwidth(pixel);\n  pixel=seam+clamp((pixel-seam)/dudv,-.5,.5);\n  \n  return pixel/texture_size;\n}\n\nvoid main(){\n  // In order to support the most efficient sprite batching, we have multiple\n  // textures loaded into the gpu (usually 8) this picker logic skips over textures\n  // that do not apply to a particular sprite.\n  \n  vec4 color=vec4(1.,0,0,1.);\n  \n  // GLSL is templated out to pick the right texture and set the vec4 color\n  %%texture_picker%%\n  \n  color.rgb=color.rgb*v_opacity;\n  color.a=color.a*v_opacity;\n  fragColor=color*v_tint;\n}";
const vert$3 = "#version 300 es\nin vec2 a_position;\n\n// Opacity\nin float a_opacity;\nout float v_opacity;\n\n// UV coordinate\nin vec2 a_texcoord;\nout vec2 v_texcoord;\n\n// Texture res\nin vec2 a_res;\nout vec2 v_res;\n\n// Texture number\nin lowp float a_textureIndex;\nout lowp float v_textureIndex;\n\nin vec4 a_tint;\nout vec4 v_tint;\n\nuniform mat4 u_matrix;\n\nvoid main(){\n  // Set the vertex position using the ortho transform matrix\n  gl_Position=u_matrix*vec4(a_position,0.,1.);\n  \n  // Pass through the Opacity to the fragment shader\n  v_opacity=a_opacity;\n  // Pass through the UV coord to the fragment shader\n  v_texcoord=a_texcoord;\n\n  v_res = a_res;\n\n  // Pass through the texture number to the fragment shader\n  v_textureIndex=a_textureIndex;\n  // Pass through the tint\n  v_tint=a_tint;\n}";
class ImageRenderer {
  constructor(options) {
    this.type = "ex.image";
    this.priority = 0;
    this._maxImages = 10922;
    this._maxTextures = 0;
    this._imageCount = 0;
    this._textures = [];
    this._textureIndex = 0;
    this._textureToIndex = /* @__PURE__ */ new Map();
    this._images = /* @__PURE__ */ new Set();
    this._vertexIndex = 0;
    this._imageToWidth = /* @__PURE__ */ new Map();
    this._imageToHeight = /* @__PURE__ */ new Map();
    this._view = [0, 0, 0, 0];
    this._dest = [0, 0];
    this._quad = [0, 0, 0, 0, 0, 0, 0, 0];
    this._defaultTint = Color.White;
    this.pixelArtSampler = options.pixelArtSampler;
    this.uvPadding = options.uvPadding;
  }
  initialize(gl, context) {
    this._gl = gl;
    this._context = context;
    const maxTexture = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    const maxComplexity = getMaxShaderComplexity(gl, maxTexture);
    this._maxTextures = Math.min(maxTexture, maxComplexity);
    const transformedFrag = this._transformFragmentSource(frag$3, this._maxTextures);
    this._shader = new Shader({
      graphicsContext: context,
      fragmentSource: transformedFrag,
      vertexSource: vert$3
    });
    this._shader.compile();
    this._shader.use();
    this._shader.setUniformMatrix("u_matrix", context.ortho);
    this._shader.setUniformIntArray(
      "u_textures",
      [...Array(this._maxTextures)].map((_, i) => i)
    );
    this._buffer = new VertexBuffer({
      gl,
      size: 12 * 4 * this._maxImages,
      // 12 components * 4 verts
      type: "dynamic"
    });
    this._layout = new VertexLayout({
      gl,
      shader: this._shader,
      vertexBuffer: this._buffer,
      attributes: [
        ["a_position", 2],
        ["a_opacity", 1],
        ["a_res", 2],
        ["a_texcoord", 2],
        ["a_textureIndex", 1],
        ["a_tint", 4]
      ]
    });
    this._quads = new QuadIndexBuffer(gl, this._maxImages, true);
  }
  dispose() {
    this._buffer.dispose();
    this._quads.dispose();
    this._shader.dispose();
    this._textures.length = 0;
    this._context = null;
    this._gl = null;
  }
  _transformFragmentSource(source, maxTextures) {
    let newSource = source.replace("%%count%%", maxTextures.toString());
    let texturePickerBuilder = "";
    for (let i = 0; i < maxTextures; i++) {
      if (i === 0) {
        texturePickerBuilder += `if (v_textureIndex <= ${i}.5) {
`;
      } else {
        texturePickerBuilder += `   else if (v_textureIndex <= ${i}.5) {
`;
      }
      texturePickerBuilder += `      vec2 uv = u_pixelart ? uv_iq(v_texcoord, v_res) : v_texcoord;
`;
      texturePickerBuilder += `      color = texture(u_textures[${i}], uv);
`;
      texturePickerBuilder += `   }
`;
    }
    newSource = newSource.replace("%%texture_picker%%", texturePickerBuilder);
    return newSource;
  }
  _addImageAsTexture(image) {
    if (this._images.has(image)) {
      return;
    }
    const maybeFiltering = image.getAttribute(ImageSourceAttributeConstants.Filtering);
    const filtering = maybeFiltering ? parseImageFiltering(maybeFiltering) : void 0;
    const wrapX = parseImageWrapping(image.getAttribute(ImageSourceAttributeConstants.WrappingX));
    const wrapY = parseImageWrapping(image.getAttribute(ImageSourceAttributeConstants.WrappingY));
    const force = image.getAttribute("forceUpload") === "true" ? true : false;
    const texture = this._context.textureLoader.load(
      image,
      {
        filtering,
        wrapping: { x: wrapX, y: wrapY }
      },
      force
    );
    image.removeAttribute("forceUpload");
    if (this._textures.indexOf(texture) === -1) {
      this._textures.push(texture);
      this._textureToIndex.set(texture, this._textureIndex++);
      this._images.add(image);
    }
  }
  _bindTextures(gl) {
    for (let i = 0; i < this._maxTextures; i++) {
      gl.activeTexture(gl.TEXTURE0 + i);
      gl.bindTexture(gl.TEXTURE_2D, this._textures[i] || this._textures[0]);
    }
  }
  _getTextureIdForImage(image) {
    var _a;
    if (image) {
      const maybeTexture = this._context.textureLoader.get(image);
      return (_a = this._textureToIndex.get(maybeTexture)) != null ? _a : -1;
    }
    return -1;
  }
  _isFull() {
    if (this._imageCount >= this._maxImages) {
      return true;
    }
    if (this._textures.length >= this._maxTextures) {
      return true;
    }
    return false;
  }
  _getImageWidth(image) {
    let maybeWidth = this._imageToWidth.get(image);
    if (maybeWidth === void 0) {
      maybeWidth = image.width;
      this._imageToWidth.set(image, maybeWidth);
    }
    return maybeWidth;
  }
  _getImageHeight(image) {
    let maybeHeight = this._imageToHeight.get(image);
    if (maybeHeight === void 0) {
      maybeHeight = image.height;
      this._imageToHeight.set(image, maybeHeight);
    }
    return maybeHeight;
  }
  draw(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
    var _a, _b, _c, _d;
    if (this._isFull()) {
      this.flush();
    }
    this._imageCount++;
    this._addImageAsTexture(image);
    const maybeImageWidth = this._getImageWidth(image);
    const maybeImageHeight = this._getImageHeight(image);
    let width = maybeImageWidth || swidth || 0;
    let height = maybeImageHeight || sheight || 0;
    this._view[0] = 0;
    this._view[1] = 0;
    this._view[2] = (_a = swidth != null ? swidth : maybeImageWidth) != null ? _a : 0;
    this._view[3] = (_b = sheight != null ? sheight : maybeImageHeight) != null ? _b : 0;
    this._dest[0] = sx != null ? sx : 1;
    this._dest[1] = sy != null ? sy : 1;
    if (dx !== void 0 && dy !== void 0 && dwidth !== void 0 && dheight !== void 0) {
      this._view[0] = sx != null ? sx : 1;
      this._view[1] = sy != null ? sy : 1;
      this._view[2] = (_c = swidth != null ? swidth : maybeImageWidth) != null ? _c : 0;
      this._view[3] = (_d = sheight != null ? sheight : maybeImageHeight) != null ? _d : 0;
      this._dest[0] = dx;
      this._dest[1] = dy;
      width = dwidth;
      height = dheight;
    }
    sx = this._view[0];
    sy = this._view[1];
    const sw = this._view[2];
    const sh = this._view[3];
    const transform = this._context.getTransform();
    const opacity = this._context.opacity;
    const snapToPixel = this._context.snapToPixel;
    this._quad[0] = this._dest[0];
    this._quad[1] = this._dest[1];
    this._quad[2] = this._dest[0] + width;
    this._quad[3] = this._dest[1];
    this._quad[4] = this._dest[0];
    this._quad[5] = this._dest[1] + height;
    this._quad[6] = this._dest[0] + width;
    this._quad[7] = this._dest[1] + height;
    transform.multiplyQuadInPlace(this._quad);
    if (snapToPixel) {
      this._quad[0] = ~~(this._quad[0] + sign(this._quad[0]) * pixelSnapEpsilon);
      this._quad[1] = ~~(this._quad[1] + sign(this._quad[1]) * pixelSnapEpsilon);
      this._quad[2] = ~~(this._quad[2] + sign(this._quad[2]) * pixelSnapEpsilon);
      this._quad[3] = ~~(this._quad[3] + sign(this._quad[3]) * pixelSnapEpsilon);
      this._quad[4] = ~~(this._quad[4] + sign(this._quad[4]) * pixelSnapEpsilon);
      this._quad[5] = ~~(this._quad[5] + sign(this._quad[5]) * pixelSnapEpsilon);
      this._quad[6] = ~~(this._quad[6] + sign(this._quad[6]) * pixelSnapEpsilon);
      this._quad[7] = ~~(this._quad[7] + sign(this._quad[7]) * pixelSnapEpsilon);
    }
    const tint = this._context.tint || this._defaultTint;
    const textureId = this._getTextureIdForImage(image);
    const imageWidth = maybeImageWidth || width;
    const imageHeight = maybeImageHeight || height;
    const uvx0 = (sx + this.uvPadding) / imageWidth;
    const uvy0 = (sy + this.uvPadding) / imageHeight;
    const uvx1 = (sx + sw - this.uvPadding) / imageWidth;
    const uvy1 = (sy + sh - this.uvPadding) / imageHeight;
    const txWidth = maybeImageWidth;
    const txHeight = maybeImageHeight;
    const vertexBuffer = this._layout.vertexBuffer.bufferData;
    vertexBuffer[this._vertexIndex++] = this._quad[0];
    vertexBuffer[this._vertexIndex++] = this._quad[1];
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = txWidth;
    vertexBuffer[this._vertexIndex++] = txHeight;
    vertexBuffer[this._vertexIndex++] = uvx0;
    vertexBuffer[this._vertexIndex++] = uvy0;
    vertexBuffer[this._vertexIndex++] = textureId;
    vertexBuffer[this._vertexIndex++] = tint.r / 255;
    vertexBuffer[this._vertexIndex++] = tint.g / 255;
    vertexBuffer[this._vertexIndex++] = tint.b / 255;
    vertexBuffer[this._vertexIndex++] = tint.a;
    vertexBuffer[this._vertexIndex++] = this._quad[4];
    vertexBuffer[this._vertexIndex++] = this._quad[5];
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = txWidth;
    vertexBuffer[this._vertexIndex++] = txHeight;
    vertexBuffer[this._vertexIndex++] = uvx0;
    vertexBuffer[this._vertexIndex++] = uvy1;
    vertexBuffer[this._vertexIndex++] = textureId;
    vertexBuffer[this._vertexIndex++] = tint.r / 255;
    vertexBuffer[this._vertexIndex++] = tint.g / 255;
    vertexBuffer[this._vertexIndex++] = tint.b / 255;
    vertexBuffer[this._vertexIndex++] = tint.a;
    vertexBuffer[this._vertexIndex++] = this._quad[2];
    vertexBuffer[this._vertexIndex++] = this._quad[3];
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = txWidth;
    vertexBuffer[this._vertexIndex++] = txHeight;
    vertexBuffer[this._vertexIndex++] = uvx1;
    vertexBuffer[this._vertexIndex++] = uvy0;
    vertexBuffer[this._vertexIndex++] = textureId;
    vertexBuffer[this._vertexIndex++] = tint.r / 255;
    vertexBuffer[this._vertexIndex++] = tint.g / 255;
    vertexBuffer[this._vertexIndex++] = tint.b / 255;
    vertexBuffer[this._vertexIndex++] = tint.a;
    vertexBuffer[this._vertexIndex++] = this._quad[6];
    vertexBuffer[this._vertexIndex++] = this._quad[7];
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = txWidth;
    vertexBuffer[this._vertexIndex++] = txHeight;
    vertexBuffer[this._vertexIndex++] = uvx1;
    vertexBuffer[this._vertexIndex++] = uvy1;
    vertexBuffer[this._vertexIndex++] = textureId;
    vertexBuffer[this._vertexIndex++] = tint.r / 255;
    vertexBuffer[this._vertexIndex++] = tint.g / 255;
    vertexBuffer[this._vertexIndex++] = tint.b / 255;
    vertexBuffer[this._vertexIndex++] = tint.a;
  }
  hasPendingDraws() {
    return this._imageCount !== 0;
  }
  flush() {
    if (this._imageCount === 0) {
      return;
    }
    const gl = this._gl;
    this._shader.use();
    this._layout.use(true, 4 * 12 * this._imageCount);
    this._shader.setUniformMatrix("u_matrix", this._context.ortho);
    this._shader.setUniformBoolean("u_pixelart", this.pixelArtSampler);
    this._bindTextures(gl);
    this._quads.bind();
    gl.drawElements(gl.TRIANGLES, this._imageCount * 6, this._quads.bufferGlType, 0);
    GraphicsDiagnostics.DrawnImagesCount += this._imageCount;
    GraphicsDiagnostics.DrawCallCount++;
    this._imageCount = 0;
    this._vertexIndex = 0;
    this._textures.length = 0;
    this._textureIndex = 0;
    this._textureToIndex.clear();
    this._images.clear();
    this._imageToWidth.clear();
    this._imageToHeight.clear();
  }
}
const frag$2 = "#version 300 es\n\nprecision mediump float;\n\n// UV coord\nin vec2 v_uv;\n\nin vec2 v_size; // in pixels\n\n// Color coord to blend with image\nin lowp vec4 v_color;\n\n// Stroke color if used\nin lowp vec4 v_strokeColor;\n\n// Stroke thickness if used\nin lowp float v_strokeThickness; // in pixels\n\n// Opacity\nin float v_opacity;\n\nout vec4 fragColor;\n\nvoid main() {\n    // modified from https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border\n    vec2 uv = v_uv;\n    vec2 fragCoord = uv * v_size;\n    float maxX = v_size.x - v_strokeThickness;\n    float minX = v_strokeThickness;\n    float maxY = v_size.y - v_strokeThickness;\n    float minY = v_strokeThickness;\n\n    if (fragCoord.x < maxX && fragCoord.x > minX &&\n        fragCoord.y < maxY && fragCoord.y > minY) {\n      fragColor = v_color;\n    } else {\n      fragColor = v_strokeColor;\n    }\n    fragColor.a *= v_opacity;\n    fragColor.rgb *= fragColor.a;\n\n    // vec2 v2CenteredPos     = abs(fragCoord - v_size.xy / 2.0);\n    // vec2 v2HalfShapeSizePx = v_size.xy/2.0 - v_strokeThickness/2.0;\n\n    // float fHalfBorderDist      = 0.0;\n    // float fHalfBorderThickness = 0.0;\n\n    // if (fragCoord.x > max(v_radius, v_strokeThickness) && \n    //     fragCoord.x < v_size.x - max(v_radius, v_strokeThickness))\n    // {\n    //     fHalfBorderDist      = v2CenteredPos.y - v2HalfShapeSizePx.y;\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\n    // }\n    // else if (fragCoord.y > max(v_radius, v_strokeThickness) && \n    //          fragCoord.y < v_size.y - max(v_radius, v_strokeThickness))\n    // {\n    //     fHalfBorderDist      = v2CenteredPos.x - v2HalfShapeSizePx.x;\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\n    // }\n    // else\n    // {\n    //     vec2 edgeVec = max(vec2(0.0), v_radius - vec2(\n    //         uv.x > 0.5 ? v_size.x - fragCoord.x : fragCoord.x,\n    //         uv.y > 0.5 ? v_size.y - fragCoord.y : fragCoord.y));\n        \n    //     float ellipse_ab    = v_radius-v_strokeThickness;\n    //     vec2 ellipse_isect = (v_strokeThickness > v_radius || v_strokeThickness > v_radius) ? vec2(0.0) :\n    //                             edgeVec.xy * ellipse_ab*ellipse_ab / length(ellipse_ab*edgeVec.yx); \n            \n    //     fHalfBorderThickness = (v_radius - length(ellipse_isect)) / 2.0;\n    //     fHalfBorderDist      = length(edgeVec) - (v_radius - fHalfBorderThickness);\n    // }\n\n    // vec4 v4FromColor = v_strokeColor;\n    // v4FromColor.rgb *= v4FromColor.a;\n    // vec4 v4ToColor   = vec4(0.0); // background color is transparent\n    // if (fHalfBorderDist < 0.0) {\n    //     v4ToColor = v_color;\n    //     v4ToColor.rgb *= v4ToColor.a;\n    // }\n\n    // float mixPct = abs(fHalfBorderDist) - fHalfBorderThickness;\n\n    // vec4 finalColor = mix(v4FromColor, v4ToColor, mixPct);\n    // gl_FragColor = finalColor;\n}";
const vert$2 = "#version 300 es\nin vec2 a_position;\n\n// UV coordinate\nin vec2 a_uv;\nout vec2 v_uv;\n\nin vec2 a_size;\nout vec2 v_size;\n\n// Opacity \nin float a_opacity;\nout float v_opacity;\n\nin vec4 a_color;\nout vec4 v_color;\n\nin vec4 a_strokeColor;\nout vec4 v_strokeColor;\n\nin float a_strokeThickness;\nout float v_strokeThickness;\n\nuniform mat4 u_matrix;\n\n\nvoid main() {\n   // Set the vertex position using the ortho transform matrix\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\n\n   // Pass through UV coords\n   v_uv = a_uv;\n   // Pass through size\n   v_size = a_size;\n   // Pass through the Opacity to the fragment shader\n   v_opacity = a_opacity;\n   // Pass through the color to the fragment shader\n   v_color = a_color;\n   // Pass through the stroke color to the fragment shader\n   v_strokeColor = a_strokeColor;\n   // Pass through the stroke thickenss to the fragment shader\n   v_strokeThickness = a_strokeThickness;\n}";
class RectangleRenderer {
  constructor() {
    this.type = "ex.rectangle";
    this.priority = 0;
    this._maxRectangles = 10922;
    this._rectangleCount = 0;
    this._vertexIndex = 0;
    this._transparent = Color.Transparent;
    this._scratch1 = vec(0, 0);
    this._scratch2 = vec(0, 0);
    this._scratch3 = vec(0, 0);
    this._scratch4 = vec(0, 0);
  }
  initialize(gl, context) {
    this._gl = gl;
    this._context = context;
    this._shader = new Shader({
      graphicsContext: context,
      fragmentSource: frag$2,
      vertexSource: vert$2
    });
    this._shader.compile();
    this._shader.use();
    this._shader.setUniformMatrix("u_matrix", context.ortho);
    this._buffer = new VertexBuffer({
      gl,
      size: 16 * 4 * this._maxRectangles,
      type: "dynamic"
    });
    this._layout = new VertexLayout({
      gl,
      shader: this._shader,
      vertexBuffer: this._buffer,
      attributes: [
        ["a_position", 2],
        ["a_uv", 2],
        ["a_size", 2],
        ["a_opacity", 1],
        ["a_color", 4],
        ["a_strokeColor", 4],
        ["a_strokeThickness", 1]
      ]
    });
    this._quads = new QuadIndexBuffer(gl, this._maxRectangles, true);
  }
  dispose() {
    this._buffer.dispose();
    this._quads.dispose();
    this._shader.dispose();
    this._context = null;
    this._gl = null;
  }
  _isFull() {
    if (this._rectangleCount >= this._maxRectangles) {
      return true;
    }
    return false;
  }
  draw(...args) {
    if (args[0] instanceof Vector && args[1] instanceof Vector) {
      this.drawLine.apply(this, args);
    } else {
      this.drawRectangle.apply(this, args);
    }
  }
  drawLine(start, end, color, thickness = 1) {
    if (this._isFull()) {
      this.flush();
    }
    this._rectangleCount++;
    const transform = this._context.getTransform();
    const opacity = this._context.opacity;
    const snapToPixel = this._context.snapToPixel;
    const dir = end.sub(start);
    const length = dir.magnitude;
    const normal = dir.normalize().perpendicular();
    const halfThick = thickness / 2;
    const startTop = transform.multiply(normal.scale(halfThick, this._scratch1).add(start, this._scratch1), this._scratch1);
    const startBottom = transform.multiply(normal.scale(-halfThick, this._scratch2).add(start, this._scratch2), this._scratch2);
    const endTop = transform.multiply(normal.scale(halfThick, this._scratch3).add(end, this._scratch3), this._scratch3);
    const endBottom = transform.multiply(normal.scale(-halfThick, this._scratch4).add(end, this._scratch4), this._scratch4);
    if (snapToPixel) {
      startTop.x = ~~(startTop.x + pixelSnapEpsilon);
      startTop.y = ~~(startTop.y + pixelSnapEpsilon);
      endTop.x = ~~(endTop.x + pixelSnapEpsilon);
      endTop.y = ~~(endTop.y + pixelSnapEpsilon);
      startBottom.x = ~~(startBottom.x + pixelSnapEpsilon);
      startBottom.y = ~~(startBottom.y + pixelSnapEpsilon);
      endBottom.x = ~~(endBottom.x + pixelSnapEpsilon);
      endBottom.y = ~~(endBottom.y + pixelSnapEpsilon);
    }
    const uvx0 = 0;
    const uvy0 = 0;
    const uvx1 = 1;
    const uvy1 = 1;
    const stroke = this._transparent;
    const strokeThickness = 0;
    const width = 1;
    const vertexBuffer = this._layout.vertexBuffer.bufferData;
    vertexBuffer[this._vertexIndex++] = startTop.x;
    vertexBuffer[this._vertexIndex++] = startTop.y;
    vertexBuffer[this._vertexIndex++] = uvx0;
    vertexBuffer[this._vertexIndex++] = uvy0;
    vertexBuffer[this._vertexIndex++] = length;
    vertexBuffer[this._vertexIndex++] = thickness;
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = color.r / 255;
    vertexBuffer[this._vertexIndex++] = color.g / 255;
    vertexBuffer[this._vertexIndex++] = color.b / 255;
    vertexBuffer[this._vertexIndex++] = color.a;
    vertexBuffer[this._vertexIndex++] = stroke.r / 255;
    vertexBuffer[this._vertexIndex++] = stroke.g / 255;
    vertexBuffer[this._vertexIndex++] = stroke.b / 255;
    vertexBuffer[this._vertexIndex++] = stroke.a;
    vertexBuffer[this._vertexIndex++] = strokeThickness / width;
    vertexBuffer[this._vertexIndex++] = startBottom.x;
    vertexBuffer[this._vertexIndex++] = startBottom.y;
    vertexBuffer[this._vertexIndex++] = uvx0;
    vertexBuffer[this._vertexIndex++] = uvy1;
    vertexBuffer[this._vertexIndex++] = length;
    vertexBuffer[this._vertexIndex++] = thickness;
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = color.r / 255;
    vertexBuffer[this._vertexIndex++] = color.g / 255;
    vertexBuffer[this._vertexIndex++] = color.b / 255;
    vertexBuffer[this._vertexIndex++] = color.a;
    vertexBuffer[this._vertexIndex++] = stroke.r / 255;
    vertexBuffer[this._vertexIndex++] = stroke.g / 255;
    vertexBuffer[this._vertexIndex++] = stroke.b / 255;
    vertexBuffer[this._vertexIndex++] = stroke.a;
    vertexBuffer[this._vertexIndex++] = strokeThickness / width;
    vertexBuffer[this._vertexIndex++] = endTop.x;
    vertexBuffer[this._vertexIndex++] = endTop.y;
    vertexBuffer[this._vertexIndex++] = uvx1;
    vertexBuffer[this._vertexIndex++] = uvy0;
    vertexBuffer[this._vertexIndex++] = length;
    vertexBuffer[this._vertexIndex++] = thickness;
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = color.r / 255;
    vertexBuffer[this._vertexIndex++] = color.g / 255;
    vertexBuffer[this._vertexIndex++] = color.b / 255;
    vertexBuffer[this._vertexIndex++] = color.a;
    vertexBuffer[this._vertexIndex++] = stroke.r / 255;
    vertexBuffer[this._vertexIndex++] = stroke.g / 255;
    vertexBuffer[this._vertexIndex++] = stroke.b / 255;
    vertexBuffer[this._vertexIndex++] = stroke.a;
    vertexBuffer[this._vertexIndex++] = strokeThickness / width;
    vertexBuffer[this._vertexIndex++] = endBottom.x;
    vertexBuffer[this._vertexIndex++] = endBottom.y;
    vertexBuffer[this._vertexIndex++] = uvx1;
    vertexBuffer[this._vertexIndex++] = uvy1;
    vertexBuffer[this._vertexIndex++] = length;
    vertexBuffer[this._vertexIndex++] = thickness;
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = color.r / 255;
    vertexBuffer[this._vertexIndex++] = color.g / 255;
    vertexBuffer[this._vertexIndex++] = color.b / 255;
    vertexBuffer[this._vertexIndex++] = color.a;
    vertexBuffer[this._vertexIndex++] = stroke.r / 255;
    vertexBuffer[this._vertexIndex++] = stroke.g / 255;
    vertexBuffer[this._vertexIndex++] = stroke.b / 255;
    vertexBuffer[this._vertexIndex++] = stroke.a;
    vertexBuffer[this._vertexIndex++] = strokeThickness / width;
  }
  drawRectangle(pos, width, height, color, stroke = Color.Transparent, strokeThickness = 0) {
    if (this._isFull()) {
      this.flush();
    }
    this._rectangleCount++;
    const transform = this._context.getTransform();
    const opacity = this._context.opacity;
    const snapToPixel = this._context.snapToPixel;
    const topLeft = transform.multiply(pos.add(vec(0, 0)));
    const topRight = transform.multiply(pos.add(vec(width, 0)));
    const bottomRight = transform.multiply(pos.add(vec(width, height)));
    const bottomLeft = transform.multiply(pos.add(vec(0, height)));
    if (snapToPixel) {
      topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);
      topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);
      topRight.x = ~~(topRight.x + pixelSnapEpsilon);
      topRight.y = ~~(topRight.y + pixelSnapEpsilon);
      bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);
      bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);
      bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);
      bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);
    }
    const uvx0 = 0;
    const uvy0 = 0;
    const uvx1 = 1;
    const uvy1 = 1;
    const vertexBuffer = this._layout.vertexBuffer.bufferData;
    vertexBuffer[this._vertexIndex++] = topLeft.x;
    vertexBuffer[this._vertexIndex++] = topLeft.y;
    vertexBuffer[this._vertexIndex++] = uvx0;
    vertexBuffer[this._vertexIndex++] = uvy0;
    vertexBuffer[this._vertexIndex++] = width;
    vertexBuffer[this._vertexIndex++] = height;
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = color.r / 255;
    vertexBuffer[this._vertexIndex++] = color.g / 255;
    vertexBuffer[this._vertexIndex++] = color.b / 255;
    vertexBuffer[this._vertexIndex++] = color.a;
    vertexBuffer[this._vertexIndex++] = stroke.r / 255;
    vertexBuffer[this._vertexIndex++] = stroke.g / 255;
    vertexBuffer[this._vertexIndex++] = stroke.b / 255;
    vertexBuffer[this._vertexIndex++] = stroke.a;
    vertexBuffer[this._vertexIndex++] = strokeThickness;
    vertexBuffer[this._vertexIndex++] = bottomLeft.x;
    vertexBuffer[this._vertexIndex++] = bottomLeft.y;
    vertexBuffer[this._vertexIndex++] = uvx0;
    vertexBuffer[this._vertexIndex++] = uvy1;
    vertexBuffer[this._vertexIndex++] = width;
    vertexBuffer[this._vertexIndex++] = height;
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = color.r / 255;
    vertexBuffer[this._vertexIndex++] = color.g / 255;
    vertexBuffer[this._vertexIndex++] = color.b / 255;
    vertexBuffer[this._vertexIndex++] = color.a;
    vertexBuffer[this._vertexIndex++] = stroke.r / 255;
    vertexBuffer[this._vertexIndex++] = stroke.g / 255;
    vertexBuffer[this._vertexIndex++] = stroke.b / 255;
    vertexBuffer[this._vertexIndex++] = stroke.a;
    vertexBuffer[this._vertexIndex++] = strokeThickness;
    vertexBuffer[this._vertexIndex++] = topRight.x;
    vertexBuffer[this._vertexIndex++] = topRight.y;
    vertexBuffer[this._vertexIndex++] = uvx1;
    vertexBuffer[this._vertexIndex++] = uvy0;
    vertexBuffer[this._vertexIndex++] = width;
    vertexBuffer[this._vertexIndex++] = height;
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = color.r / 255;
    vertexBuffer[this._vertexIndex++] = color.g / 255;
    vertexBuffer[this._vertexIndex++] = color.b / 255;
    vertexBuffer[this._vertexIndex++] = color.a;
    vertexBuffer[this._vertexIndex++] = stroke.r / 255;
    vertexBuffer[this._vertexIndex++] = stroke.g / 255;
    vertexBuffer[this._vertexIndex++] = stroke.b / 255;
    vertexBuffer[this._vertexIndex++] = stroke.a;
    vertexBuffer[this._vertexIndex++] = strokeThickness;
    vertexBuffer[this._vertexIndex++] = bottomRight.x;
    vertexBuffer[this._vertexIndex++] = bottomRight.y;
    vertexBuffer[this._vertexIndex++] = uvx1;
    vertexBuffer[this._vertexIndex++] = uvy1;
    vertexBuffer[this._vertexIndex++] = width;
    vertexBuffer[this._vertexIndex++] = height;
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = color.r / 255;
    vertexBuffer[this._vertexIndex++] = color.g / 255;
    vertexBuffer[this._vertexIndex++] = color.b / 255;
    vertexBuffer[this._vertexIndex++] = color.a;
    vertexBuffer[this._vertexIndex++] = stroke.r / 255;
    vertexBuffer[this._vertexIndex++] = stroke.g / 255;
    vertexBuffer[this._vertexIndex++] = stroke.b / 255;
    vertexBuffer[this._vertexIndex++] = stroke.a;
    vertexBuffer[this._vertexIndex++] = strokeThickness;
  }
  hasPendingDraws() {
    return this._rectangleCount !== 0;
  }
  flush() {
    if (this._rectangleCount === 0) {
      return;
    }
    const gl = this._gl;
    this._shader.use();
    this._layout.use(true);
    this._shader.setUniformMatrix("u_matrix", this._context.ortho);
    this._quads.bind();
    gl.drawElements(gl.TRIANGLES, this._rectangleCount * 6, this._quads.bufferGlType, 0);
    GraphicsDiagnostics.DrawnImagesCount += this._rectangleCount;
    GraphicsDiagnostics.DrawCallCount++;
    this._rectangleCount = 0;
    this._vertexIndex = 0;
  }
}
const frag$1 = "#version 300 es\nprecision highp float;\n\n// UV coord\nin vec2 v_uv;\n\n// Color coord to blend with image\nin lowp vec4 v_color;\n\n// Stroke color if used\nin lowp vec4 v_strokeColor;\n\n// Stroke thickness if used\nin lowp float v_strokeThickness;\n\n// Opacity\nin float v_opacity;\n\nout vec4 fragColor;\n\nvoid main() {\n  // make (0, 0) the center the uv \n  vec2 uv = v_uv * 2.0 - 1.0;\n\n  vec4 color = v_color;\n  vec4 strokeColor = v_strokeColor;\n\n  // circle border is at radius 1.0 \n  // dist is > 0 when inside the circle \n  float d = length(uv);\n  float dist = 1.0 - length(uv);\n\n  // Fade based on fwidth\n  float fade = fwidth(dot(uv, uv));\n\n  // if dist is greater than 0 step to 1;\n  // when we cross this 0 threshold add a smooth fade\n  float fill = smoothstep(-fade/2.0, fade/2.0, dist);\n\n  // if dist is greater than the stroke thickness step to 1\n  float stroke = 1.0 - smoothstep(v_strokeThickness, v_strokeThickness + fade, dist);\n\n  strokeColor.a *= fill * stroke;\n  strokeColor.rgb *= strokeColor.a;\n\n  color.a *= fill * (1.0 - stroke);\n  color.rgb *= color.a;\n\n  vec4 finalColor = mix(vec4(0.0), (color + strokeColor), fill);\n  finalColor.rgb = finalColor.rgb * v_opacity;\n  finalColor.a = finalColor.a * v_opacity;\n  fragColor = finalColor;\n}";
const vert$1 = "#version 300 es\nin vec2 a_position;\n\n// UV coordinate\nin vec2 a_uv;\nout vec2 v_uv;\n\n// Opacity \nin float a_opacity;\nout float v_opacity;\n\nin vec4 a_color;\nout vec4 v_color;\n\nin vec4 a_strokeColor;\nout vec4 v_strokeColor;\n\nin float a_strokeThickness;\nout float v_strokeThickness;\n\nuniform mat4 u_matrix;\n\n\nvoid main() {\n   // Set the vertex position using the ortho transform matrix\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\n\n   // Pass through UV coords\n   v_uv = a_uv;\n   // Pass through the Opacity to the fragment shader\n   v_opacity = a_opacity;\n   // Pass through the color to the fragment shader\n   v_color = a_color;\n   // Pass through the stroke color to the fragment shader\n   v_strokeColor = a_strokeColor;\n   // Pass through the stroke thickenss to the fragment shader\n   v_strokeThickness = a_strokeThickness;\n}";
class CircleRenderer {
  constructor() {
    this.type = "ex.circle";
    this.priority = 0;
    this._maxCircles = 10922;
    this._circleCount = 0;
    this._vertexIndex = 0;
  }
  initialize(gl, context) {
    this._gl = gl;
    this._context = context;
    this._shader = new Shader({
      graphicsContext: context,
      fragmentSource: frag$1,
      vertexSource: vert$1
    });
    this._shader.compile();
    this._shader.use();
    this._shader.setUniformMatrix("u_matrix", context.ortho);
    this._buffer = new VertexBuffer({
      gl,
      size: 14 * 4 * this._maxCircles,
      type: "dynamic"
    });
    this._layout = new VertexLayout({
      gl,
      shader: this._shader,
      vertexBuffer: this._buffer,
      attributes: [
        ["a_position", 2],
        ["a_uv", 2],
        ["a_opacity", 1],
        ["a_color", 4],
        ["a_strokeColor", 4],
        ["a_strokeThickness", 1]
      ]
    });
    this._quads = new QuadIndexBuffer(gl, this._maxCircles, true);
  }
  dispose() {
    this._buffer.dispose();
    this._quads.dispose();
    this._shader.dispose();
    this._context = null;
    this._gl = null;
  }
  _isFull() {
    if (this._circleCount >= this._maxCircles) {
      return true;
    }
    return false;
  }
  draw(pos, radius, color, stroke = Color.Transparent, strokeThickness = 0) {
    if (this._isFull()) {
      this.flush();
    }
    this._circleCount++;
    const transform = this._context.getTransform();
    const opacity = this._context.opacity;
    const snapToPixel = this._context.snapToPixel;
    const topLeft = transform.multiply(pos.add(vec(-radius, -radius)));
    const topRight = transform.multiply(pos.add(vec(radius, -radius)));
    const bottomRight = transform.multiply(pos.add(vec(radius, radius)));
    const bottomLeft = transform.multiply(pos.add(vec(-radius, radius)));
    if (snapToPixel) {
      topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);
      topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);
      topRight.x = ~~(topRight.x + pixelSnapEpsilon);
      topRight.y = ~~(topRight.y + pixelSnapEpsilon);
      bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);
      bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);
      bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);
      bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);
    }
    const uvx0 = 0;
    const uvy0 = 0;
    const uvx1 = 1;
    const uvy1 = 1;
    const vertexBuffer = this._layout.vertexBuffer.bufferData;
    vertexBuffer[this._vertexIndex++] = topLeft.x;
    vertexBuffer[this._vertexIndex++] = topLeft.y;
    vertexBuffer[this._vertexIndex++] = uvx0;
    vertexBuffer[this._vertexIndex++] = uvy0;
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = color.r / 255;
    vertexBuffer[this._vertexIndex++] = color.g / 255;
    vertexBuffer[this._vertexIndex++] = color.b / 255;
    vertexBuffer[this._vertexIndex++] = color.a;
    vertexBuffer[this._vertexIndex++] = stroke.r / 255;
    vertexBuffer[this._vertexIndex++] = stroke.g / 255;
    vertexBuffer[this._vertexIndex++] = stroke.b / 255;
    vertexBuffer[this._vertexIndex++] = stroke.a;
    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
    vertexBuffer[this._vertexIndex++] = bottomLeft.x;
    vertexBuffer[this._vertexIndex++] = bottomLeft.y;
    vertexBuffer[this._vertexIndex++] = uvx0;
    vertexBuffer[this._vertexIndex++] = uvy1;
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = color.r / 255;
    vertexBuffer[this._vertexIndex++] = color.g / 255;
    vertexBuffer[this._vertexIndex++] = color.b / 255;
    vertexBuffer[this._vertexIndex++] = color.a;
    vertexBuffer[this._vertexIndex++] = stroke.r / 255;
    vertexBuffer[this._vertexIndex++] = stroke.g / 255;
    vertexBuffer[this._vertexIndex++] = stroke.b / 255;
    vertexBuffer[this._vertexIndex++] = stroke.a;
    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
    vertexBuffer[this._vertexIndex++] = topRight.x;
    vertexBuffer[this._vertexIndex++] = topRight.y;
    vertexBuffer[this._vertexIndex++] = uvx1;
    vertexBuffer[this._vertexIndex++] = uvy0;
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = color.r / 255;
    vertexBuffer[this._vertexIndex++] = color.g / 255;
    vertexBuffer[this._vertexIndex++] = color.b / 255;
    vertexBuffer[this._vertexIndex++] = color.a;
    vertexBuffer[this._vertexIndex++] = stroke.r / 255;
    vertexBuffer[this._vertexIndex++] = stroke.g / 255;
    vertexBuffer[this._vertexIndex++] = stroke.b / 255;
    vertexBuffer[this._vertexIndex++] = stroke.a;
    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
    vertexBuffer[this._vertexIndex++] = bottomRight.x;
    vertexBuffer[this._vertexIndex++] = bottomRight.y;
    vertexBuffer[this._vertexIndex++] = uvx1;
    vertexBuffer[this._vertexIndex++] = uvy1;
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = color.r / 255;
    vertexBuffer[this._vertexIndex++] = color.g / 255;
    vertexBuffer[this._vertexIndex++] = color.b / 255;
    vertexBuffer[this._vertexIndex++] = color.a;
    vertexBuffer[this._vertexIndex++] = stroke.r / 255;
    vertexBuffer[this._vertexIndex++] = stroke.g / 255;
    vertexBuffer[this._vertexIndex++] = stroke.b / 255;
    vertexBuffer[this._vertexIndex++] = stroke.a;
    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
  }
  hasPendingDraws() {
    return this._circleCount !== 0;
  }
  flush() {
    if (this._circleCount === 0) {
      return;
    }
    const gl = this._gl;
    this._shader.use();
    this._layout.use(true);
    this._shader.setUniformMatrix("u_matrix", this._context.ortho);
    this._quads.bind();
    gl.drawElements(gl.TRIANGLES, this._circleCount * 6, this._quads.bufferGlType, 0);
    GraphicsDiagnostics.DrawnImagesCount += this._circleCount;
    GraphicsDiagnostics.DrawCallCount++;
    this._circleCount = 0;
    this._vertexIndex = 0;
  }
}
class DrawCall {
  constructor() {
    this.z = 0;
    this.priority = 0;
    this.renderer = "";
    this.transform = AffineMatrix.identity();
    this.state = {
      z: 0,
      opacity: 1,
      tint: Color.White,
      material: null
    };
    this.args = new Array(10);
  }
}
class MaterialRenderer {
  constructor() {
    this.type = "ex.material";
    this.priority = 0;
    this._textures = [];
  }
  initialize(gl, context) {
    this._gl = gl;
    this._context = context;
    this._buffer = new VertexBuffer({
      gl,
      size: 6 * 4,
      // 6 components * 4 verts
      type: "dynamic"
    });
    this._layout = new VertexLayout({
      gl,
      vertexBuffer: this._buffer,
      attributes: [
        ["a_position", 2],
        ["a_uv", 2],
        ["a_screenuv", 2]
      ],
      suppressWarnings: true
    });
    this._quads = new QuadIndexBuffer(gl, 1, true);
  }
  dispose() {
    this._buffer.dispose();
    this._quads.dispose();
    this._textures.length = 0;
    this._context = null;
    this._gl = null;
  }
  draw(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
    var _a, _b, _c, _d;
    const gl = this._gl;
    const material = this._context.material;
    if (!material) {
      return;
    }
    const transform = this._context.getTransform();
    const opacity = this._context.opacity;
    const shader = material.getShader();
    const vertexBuffer = this._layout.vertexBuffer.bufferData;
    let vertexIndex = 0;
    let width = (image == null ? void 0 : image.width) || swidth || 0;
    let height = (image == null ? void 0 : image.height) || sheight || 0;
    let view = [0, 0, (_a = swidth != null ? swidth : image == null ? void 0 : image.width) != null ? _a : 0, (_b = sheight != null ? sheight : image == null ? void 0 : image.height) != null ? _b : 0];
    let dest = [sx != null ? sx : 1, sy != null ? sy : 1];
    if (dx !== void 0 && dy !== void 0 && dwidth !== void 0 && dheight !== void 0) {
      view = [sx != null ? sx : 1, sy != null ? sy : 1, (_c = swidth != null ? swidth : image == null ? void 0 : image.width) != null ? _c : 0, (_d = sheight != null ? sheight : image == null ? void 0 : image.height) != null ? _d : 0];
      dest = [dx, dy];
      width = dwidth;
      height = dheight;
    }
    sx = view[0];
    sy = view[1];
    const sw = view[2];
    const sh = view[3];
    const topLeft = vec(dest[0], dest[1]);
    const topRight = vec(dest[0] + width, dest[1]);
    const bottomLeft = vec(dest[0], dest[1] + height);
    const bottomRight = vec(dest[0] + width, dest[1] + height);
    const imageWidth = image.width || width;
    const imageHeight = image.height || height;
    const uvx0 = sx / imageWidth;
    const uvy0 = sy / imageHeight;
    const uvx1 = (sx + sw - 0.01) / imageWidth;
    const uvy1 = (sy + sh - 0.01) / imageHeight;
    const topLeftScreen = transform.getPosition();
    const bottomRightScreen = topLeftScreen.add(bottomRight);
    const screenUVX0 = topLeftScreen.x / this._context.width;
    const screenUVY0 = topLeftScreen.y / this._context.height;
    const screenUVX1 = bottomRightScreen.x / this._context.width;
    const screenUVY1 = bottomRightScreen.y / this._context.height;
    vertexBuffer[vertexIndex++] = topLeft.x;
    vertexBuffer[vertexIndex++] = topLeft.y;
    vertexBuffer[vertexIndex++] = uvx0;
    vertexBuffer[vertexIndex++] = uvy0;
    vertexBuffer[vertexIndex++] = screenUVX0;
    vertexBuffer[vertexIndex++] = screenUVY0;
    vertexBuffer[vertexIndex++] = bottomLeft.x;
    vertexBuffer[vertexIndex++] = bottomLeft.y;
    vertexBuffer[vertexIndex++] = uvx0;
    vertexBuffer[vertexIndex++] = uvy1;
    vertexBuffer[vertexIndex++] = screenUVX0;
    vertexBuffer[vertexIndex++] = screenUVY1;
    vertexBuffer[vertexIndex++] = topRight.x;
    vertexBuffer[vertexIndex++] = topRight.y;
    vertexBuffer[vertexIndex++] = uvx1;
    vertexBuffer[vertexIndex++] = uvy0;
    vertexBuffer[vertexIndex++] = screenUVX1;
    vertexBuffer[vertexIndex++] = screenUVY0;
    vertexBuffer[vertexIndex++] = bottomRight.x;
    vertexBuffer[vertexIndex++] = bottomRight.y;
    vertexBuffer[vertexIndex++] = uvx1;
    vertexBuffer[vertexIndex++] = uvy1;
    vertexBuffer[vertexIndex++] = screenUVX1;
    vertexBuffer[vertexIndex++] = screenUVY1;
    const texture = this._addImageAsTexture(image);
    material.use();
    this._layout.shader = shader;
    this._layout.use(true);
    shader.trySetUniformFloat("u_time_ms", performance.now());
    shader.trySetUniformFloat("u_opacity", opacity);
    shader.trySetUniformFloatVector("u_resolution", vec(this._context.width, this._context.height));
    shader.trySetUniformFloatVector("u_graphic_resolution", vec(imageWidth, imageHeight));
    shader.trySetUniformFloatVector("u_size", vec(sw, sh));
    shader.trySetUniformMatrix("u_matrix", this._context.ortho);
    shader.trySetUniformMatrix("u_transform", transform.to4x4());
    gl.activeTexture(gl.TEXTURE0 + 0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    shader.trySetUniformInt("u_graphic", 0);
    if (material.isUsingScreenTexture) {
      gl.activeTexture(gl.TEXTURE0 + 1);
      gl.bindTexture(gl.TEXTURE_2D, this._context.materialScreenTexture);
      shader.trySetUniformInt("u_screen_texture", 1);
    }
    this._quads.bind();
    gl.drawElements(gl.TRIANGLES, 6, this._quads.bufferGlType, 0);
    GraphicsDiagnostics.DrawnImagesCount++;
    GraphicsDiagnostics.DrawCallCount++;
  }
  _addImageAsTexture(image) {
    const maybeFiltering = image.getAttribute(ImageSourceAttributeConstants.Filtering);
    const filtering = maybeFiltering ? parseImageFiltering(maybeFiltering) : void 0;
    const wrapX = parseImageWrapping(image.getAttribute(ImageSourceAttributeConstants.WrappingX));
    const wrapY = parseImageWrapping(image.getAttribute(ImageSourceAttributeConstants.WrappingY));
    const force = image.getAttribute("forceUpload") === "true" ? true : false;
    const texture = this._context.textureLoader.load(
      image,
      {
        filtering,
        wrapping: { x: wrapX, y: wrapY }
      },
      force
    );
    image.removeAttribute("forceUpload");
    if (this._textures.indexOf(texture) === -1) {
      this._textures.push(texture);
    }
    return texture;
  }
  hasPendingDraws() {
    return false;
  }
  flush() {
  }
}
const frag = "#version 300 es\nprecision mediump float;\n\n// UV coord\nin vec2 v_texcoord;\n\n// Textures in the current draw\nuniform sampler2D u_textures[%%count%%];\n\nuniform bool u_pixelart;\n\nin float v_texture_index;\n\nin float v_opacity;\n\nin vec4 v_tint;\n\n// texture resolution\nin vec2 v_res;\n\nin vec2 v_size;\n\nin vec2 v_uv_min;\nin vec2 v_uv_max;\n\nout vec4 fragColor;\n\n// Inigo Quilez pixel art filter https://jorenjoestar.github.io/post/pixel_art_filtering/\nvec2 uv_iq(in vec2 uv, in vec2 texture_size) {\n  vec2 pixel = uv * texture_size;\n\n  vec2 seam=floor(pixel+.5);\n  vec2 dudv=fwidth(pixel);\n  pixel=seam+clamp((pixel-seam)/dudv,-.5,.5);\n\n  return pixel/texture_size;\n}\n\nfloat lerp(float from, float to, float rel){\n  return ((1. - rel) * from) + (rel * to);\n}\n\nfloat invLerp(float from, float to, float value){\n  return (value - from) / (to - from);\n}\n\nfloat remap(float origFrom, float origTo, float targetFrom, float targetTo, float value){\n  float rel = invLerp(origFrom, origTo, value);\n  return lerp(targetFrom, targetTo, rel);\n}\n\nvoid main(){\n  // In order to support the most efficient sprite batching, we have multiple\n  // textures loaded into the gpu (usually 8) this picker logic skips over textures\n  // that do not apply to a particular sprite.\n\n  vec4 color=vec4(1.,0,0,1.);\n  vec2 remapped_uv = v_texcoord;\n  remapped_uv.x = remap(0.,1., v_uv_min.x, v_uv_max.x, v_texcoord.x);\n  remapped_uv.y = remap(0.,1., v_uv_min.y, v_uv_max.y, v_texcoord.y);\n  vec2 uv = u_pixelart ? uv_iq(remapped_uv, v_size) : remapped_uv;\n\n  // GLSL is templated out to pick the right texture and set the vec4 color\n  %%texture_picker%%\n\n  color.rgb = color.rgb * v_opacity;\n  color.a = color.a * v_opacity;\n  fragColor = color * v_tint;\n}";
const vert = "#version 300 es\nlayout(location=0) in vec2 pos;\nlayout(location=1) in vec2 a_texcoord;\nout vec2 v_texcoord;\n\nlayout(location=2) in vec2 a_offset;\nlayout(location=3) in vec2 a_mat_column1;\nlayout(location=4) in vec2 a_mat_column2;\nlayout(location=5) in vec2 a_mat_column3;\n\nlayout(location=6) in float a_opacity;\nout float v_opacity;\n\n// Texture resolution (could be bigger than a_size)\nlayout(location=7) in vec2 a_res;\nout vec2 v_res;\n\n// Final size of graphic\nlayout(location=8) in vec2 a_size;\nout vec2 v_size;\n\nlayout(location=9) in lowp float a_texture_index;\nout lowp float v_texture_index;\n\nlayout(location=10) in vec2 a_uv_min;\nout vec2 v_uv_min;\n\nlayout(location=11) in vec2 a_uv_max;\nout vec2 v_uv_max;\n\nlayout(location=12) in vec4 a_tint;\nout vec4 v_tint;\n\nuniform mat4 u_matrix;\n\nvoid main(){\n  mat4 world_mat = mat4(\n    a_mat_column1.x, a_mat_column1.y, 0., 0.,\n    a_mat_column2.x, a_mat_column2.y, 0., 0.,\n    0.             , 0.             , 1., 0.,\n    a_mat_column3.x, a_mat_column3.y, 0., 1.\n  );\n\n  vec2 newPos = vec2(pos.x * a_res.x, pos.y * a_res.y);\n  gl_Position = u_matrix * world_mat * vec4(newPos + a_offset, 0., 1.);\n\n  v_opacity = a_opacity;\n  v_texcoord = a_texcoord;\n  v_uv_min = a_uv_min;\n  v_uv_max = a_uv_max;\n  v_res = a_res;\n  v_size = a_size;\n  v_texture_index = a_texture_index;\n  v_tint = a_tint;\n}";
class ImageRendererV2 {
  constructor(options) {
    this.type = "ex.image-v2";
    this.priority = 0;
    this._maxImages = 2e4;
    this._maxTextures = 0;
    this._components = 2 + 2 + 2 + 2 + 1 + 2 + 2 + 1 + 2 + 2 + 4;
    this._imageCount = 0;
    this._textures = [];
    this._textureIndex = 0;
    this._textureToIndex = /* @__PURE__ */ new Map();
    this._images = /* @__PURE__ */ new Set();
    this._vertexIndex = 0;
    this._imageToWidth = /* @__PURE__ */ new Map();
    this._imageToHeight = /* @__PURE__ */ new Map();
    this._view = [0, 0, 0, 0];
    this._dest = [0, 0];
    this._defaultTint = Color.White;
    this.pixelArtSampler = options.pixelArtSampler;
    this.uvPadding = options.uvPadding;
  }
  initialize(gl, context) {
    this._gl = gl;
    this._context = context;
    const maxTexture = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    const maxComplexity = getMaxShaderComplexity(gl, maxTexture);
    this._maxTextures = Math.min(maxTexture, maxComplexity);
    const transformedFrag = this._transformFragmentSource(frag, this._maxTextures);
    this._shader = new Shader({
      graphicsContext: context,
      fragmentSource: transformedFrag,
      vertexSource: vert
    });
    this._shader.compile();
    this._shader.use();
    this._shader.setUniformMatrix("u_matrix", context.ortho);
    this._shader.setUniformIntArray(
      "u_textures",
      [...Array(this._maxTextures)].map((_, i) => i)
    );
    this._vao = gl.createVertexArray();
    gl.bindVertexArray(this._vao);
    this._quadMesh = new Float32Array([
      // pos       uv
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1
    ]);
    this._meshBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this._meshBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this._quadMesh, gl.STATIC_DRAW);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8);
    gl.enableVertexAttribArray(1);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    const components = this._components;
    this._transformData = new VertexBuffer({
      gl,
      size: components * this._maxImages,
      // components * images
      type: "dynamic"
    });
    this._transformData.bind();
    let offset = 0;
    let start = 2;
    const bytesPerFloat = 4;
    const totalSize = components * 4;
    gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
    gl.enableVertexAttribArray(2);
    offset += 2 * bytesPerFloat;
    gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
    gl.enableVertexAttribArray(3);
    offset += 2 * bytesPerFloat;
    gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
    gl.enableVertexAttribArray(4);
    offset += 2 * bytesPerFloat;
    gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
    gl.enableVertexAttribArray(5);
    offset += 2 * bytesPerFloat;
    gl.vertexAttribPointer(start++, 1, gl.FLOAT, false, totalSize, offset);
    gl.enableVertexAttribArray(6);
    offset += 1 * bytesPerFloat;
    gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
    gl.enableVertexAttribArray(7);
    offset += 2 * bytesPerFloat;
    gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
    gl.enableVertexAttribArray(8);
    offset += 2 * bytesPerFloat;
    gl.vertexAttribPointer(start++, 1, gl.FLOAT, false, totalSize, offset);
    gl.enableVertexAttribArray(9);
    offset += 1 * bytesPerFloat;
    gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
    gl.enableVertexAttribArray(10);
    offset += 2 * bytesPerFloat;
    gl.vertexAttribPointer(start++, 2, gl.FLOAT, false, totalSize, offset);
    gl.enableVertexAttribArray(11);
    offset += 2 * bytesPerFloat;
    gl.vertexAttribPointer(start++, 4, gl.FLOAT, false, totalSize, offset);
    gl.enableVertexAttribArray(12);
    offset += 4 * bytesPerFloat;
    gl.vertexAttribDivisor(2, 1);
    gl.vertexAttribDivisor(3, 1);
    gl.vertexAttribDivisor(4, 1);
    gl.vertexAttribDivisor(5, 1);
    gl.vertexAttribDivisor(6, 1);
    gl.vertexAttribDivisor(7, 1);
    gl.vertexAttribDivisor(8, 1);
    gl.vertexAttribDivisor(9, 1);
    gl.vertexAttribDivisor(10, 1);
    gl.vertexAttribDivisor(11, 1);
    gl.vertexAttribDivisor(12, 1);
    gl.bindVertexArray(null);
  }
  _bindData(gl) {
    const components = this._components;
    this._transformData.bind();
    this._transformData.upload(components * this._imageCount);
    gl.bindVertexArray(this._vao);
  }
  dispose() {
    this._transformData.dispose();
    this._shader.dispose();
    this._textures.length = 0;
    this._context = null;
    this._gl = null;
  }
  _transformFragmentSource(source, maxTextures) {
    let newSource = source.replace("%%count%%", maxTextures.toString());
    let texturePickerBuilder = "";
    for (let i = 0; i < maxTextures; i++) {
      if (i === 0) {
        texturePickerBuilder += `if (v_texture_index <= ${i}.5) {
`;
      } else {
        texturePickerBuilder += `   else if (v_texture_index <= ${i}.5) {
`;
      }
      texturePickerBuilder += `      color = texture(u_textures[${i}], uv);
`;
      texturePickerBuilder += `   }
`;
    }
    newSource = newSource.replace("%%texture_picker%%", texturePickerBuilder);
    return newSource;
  }
  _addImageAsTexture(image) {
    if (this._images.has(image)) {
      return;
    }
    const maybeFiltering = image.getAttribute(ImageSourceAttributeConstants.Filtering);
    const filtering = maybeFiltering ? parseImageFiltering(maybeFiltering) : void 0;
    const wrapX = parseImageWrapping(image.getAttribute(ImageSourceAttributeConstants.WrappingX));
    const wrapY = parseImageWrapping(image.getAttribute(ImageSourceAttributeConstants.WrappingY));
    const force = image.getAttribute("forceUpload") === "true" ? true : false;
    const texture = this._context.textureLoader.load(
      image,
      {
        filtering,
        wrapping: { x: wrapX, y: wrapY }
      },
      force
    );
    image.removeAttribute("forceUpload");
    if (this._textures.indexOf(texture) === -1) {
      this._textures.push(texture);
      this._textureToIndex.set(texture, this._textureIndex++);
      this._images.add(image);
    }
  }
  _bindTextures(gl) {
    const max = Math.min(this._textureIndex, this._maxTextures);
    for (let i = 0; i < max; i++) {
      gl.activeTexture(gl.TEXTURE0 + i);
      gl.bindTexture(gl.TEXTURE_2D, this._textures[i] || this._textures[0]);
    }
  }
  _getTextureIdForImage(image) {
    var _a;
    if (image) {
      const maybeTexture = this._context.textureLoader.get(image);
      return (_a = this._textureToIndex.get(maybeTexture)) != null ? _a : -1;
    }
    return -1;
  }
  _isFull() {
    if (this._imageCount >= this._maxImages) {
      return true;
    }
    if (this._textures.length >= this._maxTextures) {
      return true;
    }
    return false;
  }
  _getImageWidth(image) {
    let maybeWidth = this._imageToWidth.get(image);
    if (maybeWidth === void 0) {
      maybeWidth = image.width;
      this._imageToWidth.set(image, maybeWidth);
    }
    return maybeWidth;
  }
  _getImageHeight(image) {
    let maybeHeight = this._imageToHeight.get(image);
    if (maybeHeight === void 0) {
      maybeHeight = image.height;
      this._imageToHeight.set(image, maybeHeight);
    }
    return maybeHeight;
  }
  draw(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
    var _a, _b, _c, _d;
    if (this._isFull()) {
      this.flush();
    }
    this._imageCount++;
    this._addImageAsTexture(image);
    const maybeImageWidth = this._getImageWidth(image);
    const maybeImageHeight = this._getImageHeight(image);
    let width = maybeImageWidth || swidth || 0;
    let height = maybeImageHeight || sheight || 0;
    this._view[0] = 0;
    this._view[1] = 0;
    this._view[2] = (_a = swidth != null ? swidth : maybeImageWidth) != null ? _a : 0;
    this._view[3] = (_b = sheight != null ? sheight : maybeImageHeight) != null ? _b : 0;
    this._dest[0] = sx != null ? sx : 1;
    this._dest[1] = sy != null ? sy : 1;
    if (dx !== void 0 && dy !== void 0 && dwidth !== void 0 && dheight !== void 0) {
      this._view[0] = sx != null ? sx : 1;
      this._view[1] = sy != null ? sy : 1;
      this._view[2] = (_c = swidth != null ? swidth : maybeImageWidth) != null ? _c : 0;
      this._view[3] = (_d = sheight != null ? sheight : maybeImageHeight) != null ? _d : 0;
      this._dest[0] = dx;
      this._dest[1] = dy;
      width = dwidth;
      height = dheight;
    }
    sx = this._view[0];
    sy = this._view[1];
    const sw = this._view[2];
    const sh = this._view[3];
    const transform = this._context.getTransform();
    const opacity = this._context.opacity;
    const snapToPixel = this._context.snapToPixel;
    if (snapToPixel) {
      this._dest[0] = ~~(this._dest[0] + pixelSnapEpsilon);
      this._dest[1] = ~~(this._dest[1] + pixelSnapEpsilon);
    }
    const tint = this._context.tint || this._defaultTint;
    const textureId = this._getTextureIdForImage(image);
    const imageWidth = maybeImageWidth || width;
    const imageHeight = maybeImageHeight || height;
    const uvx0 = (sx + this.uvPadding) / imageWidth;
    const uvy0 = (sy + this.uvPadding) / imageHeight;
    const uvx1 = (sx + sw - this.uvPadding) / imageWidth;
    const uvy1 = (sy + sh - this.uvPadding) / imageHeight;
    const txWidth = maybeImageWidth;
    const txHeight = maybeImageHeight;
    const vertexBuffer = this._transformData.bufferData;
    vertexBuffer[this._vertexIndex++] = this._dest[0];
    vertexBuffer[this._vertexIndex++] = this._dest[1];
    vertexBuffer[this._vertexIndex++] = transform.data[0];
    vertexBuffer[this._vertexIndex++] = transform.data[1];
    vertexBuffer[this._vertexIndex++] = transform.data[2];
    vertexBuffer[this._vertexIndex++] = transform.data[3];
    vertexBuffer[this._vertexIndex++] = transform.data[4];
    vertexBuffer[this._vertexIndex++] = transform.data[5];
    vertexBuffer[this._vertexIndex++] = opacity;
    vertexBuffer[this._vertexIndex++] = width;
    vertexBuffer[this._vertexIndex++] = height;
    vertexBuffer[this._vertexIndex++] = txWidth;
    vertexBuffer[this._vertexIndex++] = txHeight;
    vertexBuffer[this._vertexIndex++] = textureId;
    vertexBuffer[this._vertexIndex++] = uvx0;
    vertexBuffer[this._vertexIndex++] = uvy0;
    vertexBuffer[this._vertexIndex++] = uvx1;
    vertexBuffer[this._vertexIndex++] = uvy1;
    vertexBuffer[this._vertexIndex++] = tint.r / 255;
    vertexBuffer[this._vertexIndex++] = tint.g / 255;
    vertexBuffer[this._vertexIndex++] = tint.b / 255;
    vertexBuffer[this._vertexIndex++] = tint.a;
  }
  hasPendingDraws() {
    return this._imageCount !== 0;
  }
  flush() {
    if (this._imageCount === 0) {
      return;
    }
    const gl = this._gl;
    this._shader.use();
    this._bindData(gl);
    this._shader.setUniformMatrix("u_matrix", this._context.ortho);
    this._shader.setUniformBoolean("u_pixelart", this.pixelArtSampler);
    this._bindTextures(gl);
    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, this._imageCount);
    GraphicsDiagnostics.DrawnImagesCount += this._imageCount;
    GraphicsDiagnostics.DrawCallCount++;
    gl.bindVertexArray(null);
    this._imageCount = 0;
    this._vertexIndex = 0;
    this._textures.length = 0;
    this._textureIndex = 0;
    this._textureToIndex.clear();
    this._images.clear();
    this._imageToWidth.clear();
    this._imageToHeight.clear();
  }
}
const pixelSnapEpsilon = 1e-4;
class ExcaliburGraphicsContextWebGLDebug {
  constructor(_webglCtx) {
    this._webglCtx = _webglCtx;
    this._debugText = new DebugText();
  }
  /**
   * Draw a debugging rectangle to the context
   * @param x
   * @param y
   * @param width
   * @param height
   */
  drawRect(x, y, width, height, rectOptions = { color: Color.Black }) {
    this.drawLine(vec(x, y), vec(x + width, y), { ...rectOptions });
    this.drawLine(vec(x + width, y), vec(x + width, y + height), { ...rectOptions });
    this.drawLine(vec(x + width, y + height), vec(x, y + height), { ...rectOptions });
    this.drawLine(vec(x, y + height), vec(x, y), { ...rectOptions });
  }
  /**
   * Draw a debugging line to the context
   * @param start
   * @param end
   * @param lineOptions
   */
  drawLine(start, end, lineOptions) {
    var _a;
    this._webglCtx.draw("ex.line", start, end, (_a = lineOptions == null ? void 0 : lineOptions.color) != null ? _a : Color.Black);
  }
  /**
   * Draw a debugging point to the context
   * @param point
   * @param pointOptions
   */
  drawPoint(point2, pointOptions = { color: Color.Black, size: 5 }) {
    this._webglCtx.draw("ex.point", point2, pointOptions.color, pointOptions.size);
  }
  drawText(text, pos) {
    this._debugText.write(this._webglCtx, text, pos);
  }
}
class ExcaliburGraphicsContextWebGL {
  constructor(options) {
    this._logger = Logger.getInstance();
    this._renderers = /* @__PURE__ */ new Map();
    this._lazyRenderersFactory = /* @__PURE__ */ new Map();
    this.imageRenderer = Flags.isEnabled("use-legacy-image-renderer") ? "ex.image" : "ex.image-v2";
    this._isDrawLifecycle = false;
    this.useDrawSorting = true;
    this._drawCallPool = new Pool(() => new DrawCall(), void 0, 4e3);
    this._drawCallIndex = 0;
    this._drawCalls = new Array(4e3).fill(null);
    this._postProcessTargets = [];
    this._postprocessors = [];
    this._transform = new TransformStack();
    this._state = new StateStack();
    this.snapToPixel = false;
    this.smoothing = false;
    this.pixelArtSampler = false;
    this.uvPadding = 0.01;
    this.backgroundColor = Color.ExcaliburBlue;
    this.multiSampleAntialiasing = true;
    this.transparency = true;
    this._isContextLost = false;
    this._disposed = false;
    this._imageToWidth = /* @__PURE__ */ new Map();
    this._imageToHeight = /* @__PURE__ */ new Map();
    this.debug = new ExcaliburGraphicsContextWebGLDebug(this);
    this._totalPostProcessorTime = 0;
    const {
      canvasElement,
      context,
      enableTransparency,
      antialiasing,
      uvPadding,
      multiSampleAntialiasing,
      pixelArtSampler,
      powerPreference,
      snapToPixel,
      backgroundColor,
      useDrawSorting,
      garbageCollector,
      handleContextLost,
      handleContextRestored
    } = options;
    this.__gl = context != null ? context : canvasElement.getContext("webgl2", {
      antialias: antialiasing != null ? antialiasing : this.smoothing,
      premultipliedAlpha: false,
      alpha: enableTransparency != null ? enableTransparency : this.transparency,
      depth: false,
      powerPreference: powerPreference != null ? powerPreference : "high-performance"
    });
    if (!this.__gl) {
      throw Error("Failed to retrieve webgl context from browser");
    }
    if (handleContextLost) {
      this.__gl.canvas.addEventListener("webglcontextlost", handleContextLost, false);
    }
    if (handleContextRestored) {
      this.__gl.canvas.addEventListener("webglcontextrestored", handleContextRestored, false);
    }
    this.__gl.canvas.addEventListener("webglcontextlost", () => {
      this._isContextLost = true;
    });
    this.__gl.canvas.addEventListener("webglcontextrestored", () => {
      this._isContextLost = false;
    });
    this.textureLoader = new TextureLoader(this.__gl, garbageCollector);
    this.snapToPixel = snapToPixel != null ? snapToPixel : this.snapToPixel;
    this.smoothing = antialiasing != null ? antialiasing : this.smoothing;
    this.transparency = enableTransparency != null ? enableTransparency : this.transparency;
    this.pixelArtSampler = pixelArtSampler != null ? pixelArtSampler : this.pixelArtSampler;
    this.uvPadding = uvPadding != null ? uvPadding : this.uvPadding;
    this.multiSampleAntialiasing = typeof multiSampleAntialiasing === "boolean" ? multiSampleAntialiasing : this.multiSampleAntialiasing;
    this.samples = typeof multiSampleAntialiasing === "object" ? multiSampleAntialiasing.samples : void 0;
    this.backgroundColor = backgroundColor != null ? backgroundColor : this.backgroundColor;
    this.useDrawSorting = useDrawSorting != null ? useDrawSorting : this.useDrawSorting;
    this._drawCallPool.disableWarnings = true;
    this._drawCallPool.preallocate();
    this._init();
  }
  get z() {
    return this._state.current.z;
  }
  set z(value) {
    this._state.current.z = value;
  }
  get opacity() {
    return this._state.current.opacity;
  }
  set opacity(value) {
    this._state.current.opacity = value;
  }
  get tint() {
    return this._state.current.tint;
  }
  set tint(color) {
    this._state.current.tint = color;
  }
  get width() {
    return this.__gl.canvas.width;
  }
  get height() {
    return this.__gl.canvas.height;
  }
  get ortho() {
    return this._ortho;
  }
  /**
   * Checks the underlying webgl implementation if the requested internal resolution is supported
   * @param dim
   */
  checkIfResolutionSupported(dim) {
    let supported = true;
    if (dim.width > 4096 || dim.height > 4096) {
      supported = false;
    }
    return supported;
  }
  dispose() {
    if (!this._disposed) {
      this._disposed = true;
      this.textureLoader.dispose();
      for (const renderer of this._renderers.values()) {
        renderer.dispose();
      }
      this._renderers.clear();
      this._drawCallPool.dispose();
      this._drawCalls.length = 0;
      this.__gl = null;
    }
  }
  _init() {
    const gl = this.__gl;
    this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthMask(false);
    this.register(
      new ImageRenderer({
        uvPadding: this.uvPadding,
        pixelArtSampler: this.pixelArtSampler
      })
    );
    this.register(new MaterialRenderer());
    this.register(new RectangleRenderer());
    this.register(new CircleRenderer());
    this.register(new PointRenderer());
    this.register(new LineRenderer());
    this.lazyRegister("ex.particle", () => new ParticleRenderer());
    this.register(
      new ImageRendererV2({
        uvPadding: this.uvPadding,
        pixelArtSampler: this.pixelArtSampler
      })
    );
    this.materialScreenTexture = gl.createTexture();
    if (!this.materialScreenTexture) {
      throw new Error("Could not create screen texture!");
    }
    gl.bindTexture(gl.TEXTURE_2D, this.materialScreenTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.bindTexture(gl.TEXTURE_2D, null);
    this._screenRenderer = new ScreenPassPainter(this);
    this._renderTarget = new RenderTarget({
      gl,
      transparency: this.transparency,
      width: gl.canvas.width,
      height: gl.canvas.height
    });
    this._postProcessTargets = [
      new RenderTarget({
        gl,
        transparency: this.transparency,
        width: gl.canvas.width,
        height: gl.canvas.height
      }),
      new RenderTarget({
        gl,
        transparency: this.transparency,
        width: gl.canvas.width,
        height: gl.canvas.height
      })
    ];
    this._msaaTarget = new RenderTarget({
      gl,
      transparency: this.transparency,
      width: gl.canvas.width,
      height: gl.canvas.height,
      antialias: this.multiSampleAntialiasing,
      samples: this.samples
    });
  }
  register(renderer) {
    this._renderers.set(renderer.type, renderer);
    renderer.initialize(this.__gl, this);
  }
  lazyRegister(type, renderer) {
    this._lazyRenderersFactory.set(type, renderer);
  }
  get(rendererName) {
    let maybeRenderer = this._renderers.get(rendererName);
    if (!maybeRenderer) {
      const lazyFactory = this._lazyRenderersFactory.get(rendererName);
      if (lazyFactory) {
        this._logger.debug("lazy init renderer:", rendererName);
        maybeRenderer = lazyFactory();
        this.register(maybeRenderer);
      }
    }
    return maybeRenderer;
  }
  _isCurrentRenderer(renderer) {
    if (!this._currentRenderer || this._currentRenderer === renderer) {
      return true;
    }
    return false;
  }
  beginDrawLifecycle() {
    this._isDrawLifecycle = true;
  }
  endDrawLifecycle() {
    this._isDrawLifecycle = false;
  }
  draw(rendererName, ...args) {
    {
      if (args.length > 9) {
        throw new Error("Only 10 or less renderer arguments are supported!;");
      }
    }
    if (!this._isDrawLifecycle) {
      this._logger.warnOnce(
        `Attempting to draw outside the the drawing lifecycle (preDraw/postDraw) is not supported and is a source of bugs/errors.
If you want to do custom drawing, use Actor.graphics, or any onPreDraw or onPostDraw handler.`
      );
    }
    if (this._isContextLost) {
      this._logger.errorOnce(`Unable to draw ${rendererName}, the webgl context is lost`);
      return;
    }
    const renderer = this.get(rendererName);
    if (renderer) {
      if (this.useDrawSorting) {
        const drawCall = this._drawCallPool.get();
        drawCall.z = this._state.current.z;
        drawCall.priority = renderer.priority;
        drawCall.renderer = rendererName;
        this.getTransform().clone(drawCall.transform);
        drawCall.state.z = this._state.current.z;
        drawCall.state.opacity = this._state.current.opacity;
        drawCall.state.tint = this._state.current.tint;
        drawCall.state.material = this._state.current.material;
        drawCall.args[0] = args[0];
        drawCall.args[1] = args[1];
        drawCall.args[2] = args[2];
        drawCall.args[3] = args[3];
        drawCall.args[4] = args[4];
        drawCall.args[5] = args[5];
        drawCall.args[6] = args[6];
        drawCall.args[7] = args[7];
        drawCall.args[8] = args[8];
        drawCall.args[9] = args[9];
        this._drawCalls[this._drawCallIndex++] = drawCall;
      } else {
        if (!this._currentRenderer) {
          this._currentRenderer = renderer;
        }
        if (!this._isCurrentRenderer(renderer)) {
          this._currentRenderer.flush();
        }
        renderer.draw(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
        this._currentRenderer = renderer;
      }
    } else {
      throw Error(`No renderer with name ${rendererName} has been registered`);
    }
  }
  resetTransform() {
    this._transform.reset();
  }
  updateViewport(resolution) {
    const gl = this.__gl;
    this._ortho = this._ortho = Matrix.ortho(0, resolution.width, resolution.height, 0, 400, -400);
    this._renderTarget.setResolution(gl.canvas.width, gl.canvas.height);
    this._msaaTarget.setResolution(gl.canvas.width, gl.canvas.height);
    this._postProcessTargets[0].setResolution(gl.canvas.width, gl.canvas.height);
    this._postProcessTargets[1].setResolution(gl.canvas.width, gl.canvas.height);
  }
  _getImageWidth(image) {
    let maybeWidth = this._imageToWidth.get(image);
    if (maybeWidth === void 0) {
      maybeWidth = image.width;
      this._imageToWidth.set(image, maybeWidth);
    }
    return maybeWidth;
  }
  _getImageHeight(image) {
    let maybeHeight = this._imageToHeight.get(image);
    if (maybeHeight === void 0) {
      maybeHeight = image.height;
      this._imageToHeight.set(image, maybeHeight);
    }
    return maybeHeight;
  }
  drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
    if (swidth === 0 || sheight === 0) {
      return;
    } else if (dwidth === 0 || dheight === 0) {
      return;
    } else if (this._getImageWidth(image) === 0 || this._getImageHeight(image) === 0) {
      return;
    }
    if (!image) {
      Logger.getInstance().warn("Cannot draw a null or undefined image");
      if (console.trace) {
        console.trace();
      }
      return;
    }
    if (this._state.current.material) {
      this.draw("ex.material", image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
    } else {
      if (this.imageRenderer === "ex.image") {
        this.draw(this.imageRenderer, image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
      } else {
        this.draw(this.imageRenderer, image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
      }
    }
  }
  drawLine(start, end, color, thickness = 1) {
    this.draw("ex.rectangle", start, end, color, thickness);
  }
  drawRectangle(pos, width, height, color, stroke, strokeThickness) {
    this.draw("ex.rectangle", pos, width, height, color, stroke, strokeThickness);
  }
  drawCircle(pos, radius, color, stroke, thickness) {
    this.draw("ex.circle", pos, radius, color, stroke, thickness);
  }
  save() {
    this._transform.save();
    this._state.save();
  }
  restore() {
    this._transform.restore();
    this._state.restore();
  }
  translate(x, y) {
    this._transform.translate(this.snapToPixel ? ~~(x + pixelSnapEpsilon) : x, this.snapToPixel ? ~~(y + pixelSnapEpsilon) : y);
  }
  rotate(angle) {
    this._transform.rotate(angle);
  }
  scale(x, y) {
    this._transform.scale(x, y);
  }
  transform(matrix) {
    this._transform.current = matrix;
  }
  getTransform() {
    return this._transform.current;
  }
  multiply(m) {
    this._transform.current.multiply(m, this._transform.current);
  }
  addPostProcessor(postprocessor) {
    this._postprocessors.push(postprocessor);
    postprocessor.initialize(this);
  }
  removePostProcessor(postprocessor) {
    const index = this._postprocessors.indexOf(postprocessor);
    if (index !== -1) {
      this._postprocessors.splice(index, 1);
    }
  }
  clearPostProcessors() {
    this._postprocessors.length = 0;
  }
  updatePostProcessors(elapsed) {
    for (const postprocessor of this._postprocessors) {
      const shader = postprocessor.getShader();
      shader.use();
      const uniforms = shader.getUniformDefinitions();
      this._totalPostProcessorTime += elapsed;
      if (uniforms.find((u) => u.name === "u_time_ms")) {
        shader.setUniformFloat("u_time_ms", this._totalPostProcessorTime);
      }
      if (uniforms.find((u) => u.name === "u_elapsed_ms")) {
        shader.setUniformFloat("u_elapsed_ms", elapsed);
      }
      if (uniforms.find((u) => u.name === "u_resolution")) {
        shader.setUniformFloatVector("u_resolution", vec(this.width, this.height));
      }
      if (postprocessor.onUpdate) {
        postprocessor.onUpdate(elapsed);
      }
    }
  }
  set material(material) {
    this._state.current.material = material;
  }
  get material() {
    return this._state.current.material;
  }
  /**
   * Creates and initializes the material which compiles the internal shader
   * @param options
   * @returns Material
   */
  createMaterial(options) {
    const material = new Material({ ...options, graphicsContext: this });
    return material;
  }
  createShader(options) {
    const { name, vertexSource, fragmentSource, uniforms, images, startingTextureSlot } = options;
    const shader = new Shader({
      name,
      graphicsContext: this,
      vertexSource,
      fragmentSource,
      uniforms,
      images,
      startingTextureSlot
    });
    shader.compile();
    return shader;
  }
  clear() {
    const gl = this.__gl;
    const currentTarget = this.multiSampleAntialiasing ? this._msaaTarget : this._renderTarget;
    currentTarget.use();
    gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
    gl.clear(gl.COLOR_BUFFER_BIT);
  }
  /**
   * Flushes all batched rendering to the screen
   */
  flush() {
    var _a;
    if (this._isContextLost) {
      this._logger.errorOnce(`Unable to flush the webgl context is lost`);
      return;
    }
    let currentTarget = this.multiSampleAntialiasing ? this._msaaTarget : this._renderTarget;
    currentTarget.use();
    if (this.useDrawSorting) {
      for (let i = this._drawCallIndex; i < this._drawCalls.length; i++) {
        this._drawCalls[i] = null;
      }
      const originalSort = /* @__PURE__ */ new Map();
      for (const [name] of this._renderers) {
        let firstIndex = 0;
        for (firstIndex = 0; firstIndex < this._drawCallIndex; firstIndex++) {
          if (this._drawCalls[firstIndex].renderer === name) {
            break;
          }
        }
        originalSort.set(name, firstIndex);
      }
      this._drawCalls.sort((a, b) => {
        if (a === null || b === null) {
          return 0;
        }
        const zIndex = a.z - b.z;
        const originalSortOrder = originalSort.get(a.renderer) - originalSort.get(b.renderer);
        const priority = a.priority - b.priority;
        if (zIndex === 0) {
          if (priority === 0) {
            return originalSortOrder;
          }
          return priority;
        }
        return zIndex;
      });
      const oldTransform = this._transform.current;
      const oldState = this._state.current;
      if (this._drawCalls.length && this._drawCallIndex) {
        let currentRendererName = this._drawCalls[0].renderer;
        let currentRenderer = this.get(currentRendererName);
        for (let i = 0; i < this._drawCallIndex; i++) {
          this._transform.current = this._drawCalls[i].transform;
          this._state.current = this._drawCalls[i].state;
          if (this._drawCalls[i].renderer !== currentRendererName) {
            currentRenderer.flush();
            currentRendererName = this._drawCalls[i].renderer;
            currentRenderer = this.get(currentRendererName);
          }
          if (currentRenderer instanceof MaterialRenderer && ((_a = this.material) == null ? void 0 : _a.isUsingScreenTexture)) {
            currentTarget.copyToTexture(this.materialScreenTexture);
            currentTarget.use();
          }
          currentRenderer.draw(...this._drawCalls[i].args);
        }
        if (currentRenderer.hasPendingDraws()) {
          currentRenderer.flush();
        }
      }
      this._transform.current = oldTransform;
      this._state.current = oldState;
      this._drawCallPool.done();
      this._drawCallIndex = 0;
      this._imageToHeight.clear();
      this._imageToWidth.clear();
    } else {
      for (const renderer of this._renderers.values()) {
        if (renderer.hasPendingDraws()) {
          renderer.flush();
        }
      }
    }
    currentTarget.disable();
    if (this._postprocessors.length > 0) {
      currentTarget.toRenderSource().use();
    }
    for (let i = 0; i < this._postprocessors.length; i++) {
      currentTarget = this._postProcessTargets[i % 2];
      this._postProcessTargets[i % 2].use();
      this._screenRenderer.renderWithPostProcessor(this._postprocessors[i]);
      this._postProcessTargets[i % 2].toRenderSource().use();
    }
    currentTarget.blitToScreen();
  }
}
class FontTextInstance {
  constructor(font, text, color, maxWidth) {
    this.font = font;
    this.text = text;
    this.color = color;
    this.maxWidth = maxWidth;
    this._textFragments = [];
    this.disposed = false;
    this._dirty = true;
    this.canvas = document.createElement("canvas");
    const ctx = this.canvas.getContext("2d");
    if (!ctx) {
      throw new Error("Unable to create FontTextInstance, internal canvas failed to create");
    }
    this.ctx = ctx;
    this.dimensions = this.measureText(text);
    this._setDimension(this.dimensions, this.ctx);
    this._lastHashCode = this.getHashCode();
  }
  measureText(text, maxWidth) {
    if (this.disposed) {
      throw Error("Accessing disposed text instance! " + this.text);
    }
    let lines = null;
    if (maxWidth != null) {
      lines = this._getLinesFromText(text, maxWidth);
    } else {
      lines = text.split("\n");
    }
    const maxWidthLine = lines.reduce((a, b) => {
      return a.length > b.length ? a : b;
    });
    this._applyFont(this.ctx);
    const metrics = this.ctx.measureText(maxWidthLine);
    let textHeight = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);
    const lineAdjustedHeight = textHeight * lines.length;
    textHeight = lineAdjustedHeight;
    const bottomBounds = lineAdjustedHeight - Math.abs(metrics.actualBoundingBoxAscent);
    const x = 0;
    const y = 0;
    const measurement = new BoundingBox({
      left: x - Math.abs(metrics.actualBoundingBoxLeft) - this.font.padding,
      top: y - Math.abs(metrics.actualBoundingBoxAscent) - this.font.padding,
      bottom: y + bottomBounds + this.font.padding,
      right: x + Math.abs(metrics.actualBoundingBoxRight) + this.font.padding
    });
    return measurement;
  }
  _setDimension(textBounds, bitmap) {
    let lineHeightRatio = 1;
    if (this.font.lineHeight) {
      lineHeightRatio = this.font.lineHeight / this.font.size;
    }
    bitmap.canvas.width = (textBounds.width + this.font.padding * 2) * 2 * this.font.quality;
    bitmap.canvas.height = (textBounds.height + this.font.padding * 2) * 2 * this.font.quality * lineHeightRatio;
  }
  static getHashCode(font, text, color) {
    var _a;
    const hash = text + "__hashcode__" + font.fontString + font.showDebug + font.textAlign + font.baseAlign + font.direction + font.lineHeight + JSON.stringify(font.shadow) + (font.padding.toString() + font.smoothing.toString() + font.lineWidth.toString() + font.lineDash.toString() + ((_a = font.strokeColor) == null ? void 0 : _a.toString()) + (color ? color.toString() : font.color.toString()));
    return hash;
  }
  getHashCode(includeColor = true) {
    return FontTextInstance.getHashCode(this.font, this.text, includeColor ? this.color : void 0);
  }
  _applyRasterProperties(ctx) {
    var _a, _b, _c;
    ctx.translate(this.font.padding, this.font.padding);
    ctx.imageSmoothingEnabled = this.font.smoothing;
    ctx.lineWidth = this.font.lineWidth;
    ctx.setLineDash((_a = this.font.lineDash) != null ? _a : ctx.getLineDash());
    ctx.strokeStyle = (_c = (_b = this.font.strokeColor) == null ? void 0 : _b.toString()) != null ? _c : "";
    ctx.fillStyle = this.color.toString();
  }
  _applyFont(ctx) {
    ctx.resetTransform();
    ctx.translate(this.font.padding + ctx.canvas.width / 2, this.font.padding + ctx.canvas.height / 2);
    ctx.scale(this.font.quality, this.font.quality);
    ctx.textAlign = this.font.textAlign;
    ctx.textBaseline = this.font.baseAlign;
    ctx.font = this.font.fontString;
    ctx.direction = this.font.direction;
    if (this.font.shadow) {
      if (this.font.shadow.color) {
        ctx.shadowColor = this.font.shadow.color.toString();
      }
      if (this.font.shadow.blur) {
        ctx.shadowBlur = this.font.shadow.blur;
      }
      if (this.font.shadow.offset) {
        ctx.shadowOffsetX = this.font.shadow.offset.x;
        ctx.shadowOffsetY = this.font.shadow.offset.y;
      }
    }
  }
  _drawText(ctx, lines, lineHeight) {
    this._applyRasterProperties(ctx);
    this._applyFont(ctx);
    for (let i = 0; i < lines.length; i++) {
      const line2 = lines[i];
      if (this.color) {
        ctx.fillText(line2, 0, i * lineHeight);
      }
      if (this.font.strokeColor) {
        ctx.strokeText(line2, 0, i * lineHeight);
      }
    }
    if (this.font.showDebug) {
      line(ctx, Color.Green, -ctx.canvas.width / 2, 0, ctx.canvas.width / 2, 0, 2);
      line(ctx, Color.Red, 0, -ctx.canvas.height / 2, 0, ctx.canvas.height / 2, 2);
    }
  }
  _splitTextBitmap(bitmap) {
    const textImages = [];
    let currentX = 0;
    let currentY = 0;
    const width = Math.min(4096, bitmap.canvas.width);
    const height = Math.min(4096, bitmap.canvas.height);
    while (currentX < bitmap.canvas.width) {
      while (currentY < bitmap.canvas.height) {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          throw new Error("Unable to split internal FontTextInstance bitmap, failed to create internal canvas");
        }
        ctx.drawImage(bitmap.canvas, currentX, currentY, width, height, 0, 0, width, height);
        textImages.push({ x: currentX, y: currentY, canvas });
        currentY += height;
      }
      currentX += width;
      currentY = 0;
    }
    return textImages;
  }
  flagDirty() {
    this._dirty = true;
  }
  render(ex, x, y, maxWidth) {
    var _a;
    if (this.disposed) {
      throw Error("Accessing disposed text instance! " + this.text);
    }
    this._ex = ex;
    const hashCode = this.getHashCode();
    if (this._lastHashCode !== hashCode) {
      this._dirty = true;
    }
    if (this._dirty) {
      this.dimensions = this.measureText(this.text, maxWidth);
      this._setDimension(this.dimensions, this.ctx);
      const lines = this._getLinesFromText(this.text, maxWidth);
      const lineHeight = (_a = this.font.lineHeight) != null ? _a : this.dimensions.height / lines.length;
      this._drawText(this.ctx, lines, lineHeight);
      if (ex instanceof ExcaliburGraphicsContextWebGL) {
        for (const frag2 of this._textFragments) {
          ex.textureLoader.delete(frag2.canvas);
        }
      }
      this._textFragments = this._splitTextBitmap(this.ctx);
      if (ex instanceof ExcaliburGraphicsContextWebGL) {
        for (const frag2 of this._textFragments) {
          ex.textureLoader.load(frag2.canvas, { filtering: this.font.filtering }, true);
        }
      }
      this._lastHashCode = hashCode;
      this._dirty = false;
    }
    for (const frag2 of this._textFragments) {
      ex.drawImage(
        frag2.canvas,
        0,
        0,
        frag2.canvas.width,
        frag2.canvas.height,
        frag2.x / this.font.quality + x - this.ctx.canvas.width / this.font.quality / 2,
        frag2.y / this.font.quality + y - this.ctx.canvas.height / this.font.quality / 2,
        frag2.canvas.width / this.font.quality,
        frag2.canvas.height / this.font.quality
      );
    }
  }
  dispose() {
    this.disposed = true;
    this.dimensions = void 0;
    this.canvas = void 0;
    this.ctx = void 0;
    if (this._ex instanceof ExcaliburGraphicsContextWebGL) {
      for (const frag2 of this._textFragments) {
        this._ex.textureLoader.delete(frag2.canvas);
      }
    }
    this._textFragments.length = 0;
  }
  _getLinesFromText(text, maxWidth) {
    var _a;
    if (this._cachedText === text && this._cachedRenderWidth === maxWidth && ((_a = this._cachedLines) == null ? void 0 : _a.length)) {
      return this._cachedLines;
    }
    const lines = text.split("\n");
    if (maxWidth == null) {
      return lines;
    }
    for (let i = 0; i < lines.length; i++) {
      let line2 = lines[i];
      let newLine = "";
      if (this.measureText(line2).width > maxWidth) {
        while (this.measureText(line2).width > maxWidth) {
          newLine = line2[line2.length - 1] + newLine;
          line2 = line2.slice(0, -1);
        }
        lines[i] = line2;
        lines[i + 1] = newLine;
      }
    }
    this._cachedText = text;
    this._cachedLines = lines;
    this._cachedRenderWidth = maxWidth;
    return lines;
  }
}
class Font extends Graphic {
  constructor(options = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
    super(options);
    this.filtering = ImageFiltering.Blended;
    this.quality = 2;
    this.padding = 2;
    this.smoothing = false;
    this.lineWidth = 1;
    this.lineDash = [];
    this.color = Color.Black;
    this.family = "sans-serif";
    this.style = FontStyle.Normal;
    this.bold = false;
    this.unit = FontUnit.Px;
    this.textAlign = TextAlign.Left;
    this.baseAlign = BaseAlign.Top;
    this.direction = Direction.LeftToRight;
    this.lineHeight = void 0;
    this.size = 10;
    this._textBounds = new BoundingBox();
    this.smoothing = (_a = options == null ? void 0 : options.smoothing) != null ? _a : this.smoothing;
    this.padding = (_b = options == null ? void 0 : options.padding) != null ? _b : this.padding;
    this.color = (_c = options == null ? void 0 : options.color) != null ? _c : this.color;
    this.strokeColor = (_d = options == null ? void 0 : options.strokeColor) != null ? _d : this.strokeColor;
    this.lineDash = (_e = options == null ? void 0 : options.lineDash) != null ? _e : this.lineDash;
    this.lineWidth = (_f = options == null ? void 0 : options.lineWidth) != null ? _f : this.lineWidth;
    this.filtering = (_g = options == null ? void 0 : options.filtering) != null ? _g : this.filtering;
    this.family = (_h = options == null ? void 0 : options.family) != null ? _h : this.family;
    this.style = (_i = options == null ? void 0 : options.style) != null ? _i : this.style;
    this.bold = (_j = options == null ? void 0 : options.bold) != null ? _j : this.bold;
    this.size = (_k = options == null ? void 0 : options.size) != null ? _k : this.size;
    this.unit = (_l = options == null ? void 0 : options.unit) != null ? _l : this.unit;
    this.textAlign = (_m = options == null ? void 0 : options.textAlign) != null ? _m : this.textAlign;
    this.baseAlign = (_n = options == null ? void 0 : options.baseAlign) != null ? _n : this.baseAlign;
    this.direction = (_o = options == null ? void 0 : options.direction) != null ? _o : this.direction;
    this.lineHeight = (_p = options == null ? void 0 : options.lineHeight) != null ? _p : this.lineHeight;
    this.quality = (_q = options == null ? void 0 : options.quality) != null ? _q : this.quality;
    if (options == null ? void 0 : options.shadow) {
      this.shadow = {};
      this.shadow.blur = (_r = options.shadow.blur) != null ? _r : this.shadow.blur;
      this.shadow.offset = (_s = options.shadow.offset) != null ? _s : this.shadow.offset;
      this.shadow.color = (_t = options.shadow.color) != null ? _t : this.shadow.color;
    }
    this._textMeasurement = new FontTextInstance(this, "", Color.Black);
  }
  clone() {
    return new Font({
      ...this.cloneGraphicOptions(),
      size: this.size,
      unit: this.unit,
      family: this.family,
      style: this.style,
      bold: this.bold,
      textAlign: this.textAlign,
      baseAlign: this.baseAlign,
      direction: this.direction,
      shadow: this.shadow ? {
        blur: this.shadow.blur,
        offset: this.shadow.offset,
        color: this.shadow.color
      } : void 0
    });
  }
  get fontString() {
    return `${this.style} ${this.bold ? "bold" : ""} ${this.size}${this.unit} ${this.family}`;
  }
  get localBounds() {
    return this._textBounds;
  }
  _drawImage(_ex, _x, _y) {
  }
  _rotate(ex) {
    var _a;
    const origin = (_a = this.origin) != null ? _a : this._textBounds.center;
    ex.translate(origin.x, origin.y);
    ex.rotate(this.rotation);
    ex.translate(-origin.x, -origin.y);
  }
  _flip(ex) {
    if (this.flipHorizontal) {
      ex.translate(this._textBounds.width / this.scale.x, 0);
      ex.scale(-1, 1);
    }
    if (this.flipVertical) {
      ex.translate(0, -this._textBounds.height / 2 / this.scale.y);
      ex.scale(1, -1);
    }
  }
  measureTextWithoutCache(text, maxWidth) {
    return this._textMeasurement.measureText(text, maxWidth);
  }
  /**
   * Returns a BoundingBox that is the total size of the text including multiple lines
   *
   * Does not include any padding or adjustment
   * @param text
   * @returns BoundingBox
   */
  measureText(text, maxWidth) {
    return FontCache.measureText(text, this, maxWidth);
  }
  _postDraw(ex) {
    ex.restore();
  }
  render(ex, text, colorOverride, x, y, maxWidth) {
    const textInstance = FontCache.getTextInstance(text, this, colorOverride);
    this._textBounds = textInstance.dimensions;
    this._preDraw(ex, x, y);
    textInstance.render(ex, x, y, maxWidth);
    this._postDraw(ex);
  }
}
class Text extends Graphic {
  constructor(options) {
    var _a, _b;
    super(options);
    this._text = "";
    this._textWidth = 0;
    this._textHeight = 0;
    this.font = (_a = options.font) != null ? _a : new Font();
    this.color = (_b = options.color) != null ? _b : this.color;
    this.text = options.text;
    this.maxWidth = options.maxWidth;
  }
  clone() {
    var _a, _b;
    return new Text({
      text: this.text.slice(),
      color: (_b = (_a = this.color) == null ? void 0 : _a.clone()) != null ? _b : Color.Black,
      font: this.font.clone(),
      maxWidth: this.maxWidth
    });
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._calculateDimension();
  }
  get font() {
    return this._font;
  }
  set font(font) {
    this._font = font;
  }
  get width() {
    if (this._textWidth === 0) {
      this._calculateDimension();
    }
    return this._textWidth * this.scale.x;
  }
  get height() {
    if (this._textHeight === 0) {
      this._calculateDimension();
    }
    return this._textHeight * this.scale.y;
  }
  _calculateDimension() {
    const { width, height } = this.font.measureText(this._text, this.maxWidth);
    this._textWidth = width;
    this._textHeight = height;
  }
  get localBounds() {
    return this.font.measureText(this._text, this.maxWidth).scale(this.scale);
  }
  _rotate(_ex) {
  }
  _flip(_ex) {
  }
  _preDraw(ex, x, y) {
    if (this.isStale() || this.font.isStale()) {
      this.font.flipHorizontal = this.flipHorizontal;
      this.font.flipVertical = this.flipVertical;
      this.font.rotation = this.rotation;
      this.font.origin = this.origin;
      this.font.opacity = this.opacity;
    }
    this.font.tint = this.tint;
    super._preDraw(ex, x, y);
  }
  _drawImage(ex, x, y) {
    var _a;
    let color = Color.Black;
    if (this.font instanceof Font) {
      color = (_a = this.color) != null ? _a : this.font.color;
    }
    const { width, height } = this.font.measureText(this._text, this.maxWidth);
    this._textWidth = width;
    this._textHeight = height;
    this.font.render(ex, this._text, color, x, y, this.maxWidth);
    if (this.font.showDebug) {
      ex.debug.drawRect(x - width, y - height, width * 2, height * 2);
      if (this.maxWidth != null) {
        ex.debug.drawRect(x, y, this.maxWidth, this.height, {
          color: Color.Yellow
        });
      }
    }
  }
}
function hasGraphicsTick(graphic) {
  return !!graphic.tick;
}
class GraphicsComponent extends Component {
  constructor(options) {
    super();
    this._logger = Logger.getInstance();
    this._current = "default";
    this._graphics = {};
    this._options = {};
    this.material = null;
    this.isVisible = true;
    this.forceOnScreen = false;
    this.opacity = 1;
    this._offset = new WatchVector(Vector.Zero, () => this.recalculateBounds());
    this._anchor = new WatchVector(Vector.Half, () => this.recalculateBounds());
    this.flipHorizontal = false;
    this.flipVertical = false;
    this.copyGraphics = false;
    options = {
      visible: this.isVisible,
      graphics: {},
      ...options
    };
    const {
      current,
      anchor,
      color,
      opacity,
      visible,
      graphics,
      offset,
      copyGraphics,
      onPreDraw,
      onPostDraw,
      onPreTransformDraw,
      onPostTransformDraw
    } = options;
    for (const [key, graphicOrOptions] of Object.entries(graphics)) {
      if (graphicOrOptions instanceof Graphic) {
        this._graphics[key] = graphicOrOptions;
      } else {
        this._graphics[key] = graphicOrOptions.graphic;
        this._options[key] = graphicOrOptions.options;
      }
    }
    this.offset = offset != null ? offset : this.offset;
    this.opacity = opacity != null ? opacity : this.opacity;
    this.anchor = anchor != null ? anchor : this.anchor;
    this.color = color != null ? color : this.color;
    this.copyGraphics = copyGraphics != null ? copyGraphics : this.copyGraphics;
    this.onPreDraw = onPreDraw != null ? onPreDraw : this.onPreDraw;
    this.onPostDraw = onPostDraw != null ? onPostDraw : this.onPostDraw;
    this.onPreDraw = onPreTransformDraw != null ? onPreTransformDraw : this.onPreTransformDraw;
    this.onPostTransformDraw = onPostTransformDraw != null ? onPostTransformDraw : this.onPostTransformDraw;
    this.isVisible = !!visible;
    this._current = current != null ? current : this._current;
    if (current && this._graphics[current]) {
      this.use(current);
    }
  }
  /**
   * Sets or gets wether any drawing should be visible in this component
   * @deprecated use isVisible
   */
  get visible() {
    return this.isVisible;
  }
  /**
   * Sets or gets wether any drawing should be visible in this component
   * @deprecated use isVisible
   */
  set visible(val) {
    this.isVisible = val;
  }
  /**
   * Offset to apply to graphics by default
   */
  get offset() {
    return this._offset;
  }
  set offset(value) {
    this._offset = new WatchVector(value, () => this.recalculateBounds());
    this.recalculateBounds();
  }
  /**
   * Anchor to apply to graphics by default
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    this._anchor = new WatchVector(value, () => this.recalculateBounds());
    this.recalculateBounds();
  }
  /**
   * Sets the color of the actor's current graphic
   */
  get color() {
    return this._color;
  }
  set color(v) {
    if (v) {
      this._color = v.clone();
      const currentGraphic = this.current;
      if (currentGraphic instanceof Raster || currentGraphic instanceof Text) {
        currentGraphic.color = this._color;
      }
    }
  }
  getGraphic(name) {
    return this._graphics[name];
  }
  getOptions(name) {
    return this._options[name];
  }
  /**
   * Get registered graphics names
   */
  getNames() {
    return Object.keys(this._graphics);
  }
  /**
   * Returns the currently displayed graphic
   */
  get current() {
    return this._graphics[this._current];
  }
  /**
   * Returns the currently displayed graphic offsets
   */
  get currentOptions() {
    return this._options[this._current];
  }
  /**
   * Returns all graphics associated with this component
   */
  get graphics() {
    return this._graphics;
  }
  /**
   * Returns all graphics options associated with this component
   */
  get options() {
    return this._options;
  }
  add(nameOrGraphic, graphicOrOptions, options) {
    let name = "default";
    let graphicToSet = null;
    let optionsToSet = void 0;
    if (typeof nameOrGraphic === "string" && graphicOrOptions instanceof Graphic) {
      name = nameOrGraphic;
      graphicToSet = graphicOrOptions;
      optionsToSet = options;
    }
    if (nameOrGraphic instanceof Graphic && !(graphicOrOptions instanceof Graphic)) {
      graphicToSet = nameOrGraphic;
      optionsToSet = graphicOrOptions;
    }
    if (!graphicToSet) {
      throw new Error("Need to provide a graphic or valid graphic string");
    }
    this._graphics[name] = this.copyGraphics ? graphicToSet.clone() : graphicToSet;
    this._options[name] = this.copyGraphics ? { ...optionsToSet } : optionsToSet;
    if (name === "default") {
      this.use("default");
    }
    return graphicToSet;
  }
  /**
   * Removes a registered graphic, if the removed graphic is the current it will switch to the default
   * @param name
   */
  remove(name) {
    delete this._graphics[name];
    delete this._options[name];
    if (this._current === name) {
      this._current = "default";
      this.recalculateBounds();
    }
  }
  /**
   * Use a graphic only, will set the default graphic. Returns the new {@apilink Graphic}
   *
   * Optionally override the stored options
   * @param nameOrGraphic
   * @param options
   */
  use(nameOrGraphic, options) {
    var _a;
    if (nameOrGraphic instanceof Graphic) {
      let graphic = nameOrGraphic;
      if (this.copyGraphics) {
        graphic = nameOrGraphic.clone();
      }
      this._current = "default";
      this._graphics[this._current] = graphic;
      this._options[this._current] = options;
    } else {
      this._current = nameOrGraphic;
      this._options[this._current] = options;
      if (!(this._current in this._graphics)) {
        this._logger.warn(
          `Graphic ${this._current} is not registered with the graphics component owned by ${(_a = this.owner) == null ? void 0 : _a.name}. Nothing will be drawn.`
        );
      }
    }
    this.recalculateBounds();
    return this.current;
  }
  /**
   * Hide currently shown graphic
   */
  hide() {
    this._current = "ex.none";
  }
  set localBounds(bounds) {
    this._localBounds = bounds;
  }
  recalculateBounds() {
    let bb = new BoundingBox();
    const graphic = this._graphics[this._current];
    const options = this._options[this._current];
    if (!graphic) {
      this._localBounds = bb;
      return;
    }
    let anchor = this.anchor;
    let offset = this.offset;
    if (options == null ? void 0 : options.anchor) {
      anchor = options.anchor;
    }
    if (options == null ? void 0 : options.offset) {
      offset = options.offset;
    }
    const bounds = graphic.localBounds;
    const offsetX = -bounds.width * anchor.x + offset.x;
    const offsetY = -bounds.height * anchor.y + offset.y;
    if (graphic instanceof GraphicsGroup && !graphic.useAnchor) {
      bb = graphic == null ? void 0 : graphic.localBounds.combine(bb);
    } else {
      bb = graphic == null ? void 0 : graphic.localBounds.translate(vec(offsetX, offsetY)).combine(bb);
    }
    this._localBounds = bb;
  }
  /**
   * Get local bounds of graphics component
   */
  get localBounds() {
    if (!this._localBounds || this._localBounds.hasZeroDimensions()) {
      this.recalculateBounds();
    }
    return this._localBounds;
  }
  /**
   * Get world bounds of graphics component
   */
  get bounds() {
    let bounds = this.localBounds;
    if (this.owner) {
      const tx = this.owner.get(TransformComponent);
      if (tx) {
        bounds = bounds.transform(tx.get().matrix);
      }
    }
    return bounds;
  }
  /**
   * Update underlying graphics if necessary, called internally
   * @param elapsed
   * @internal
   */
  update(elapsed, idempotencyToken = 0) {
    const graphic = this.current;
    if (graphic && hasGraphicsTick(graphic)) {
      graphic.tick(elapsed, idempotencyToken);
    }
  }
  clone() {
    const graphics = new GraphicsComponent();
    graphics._graphics = { ...this._graphics };
    graphics._options = { ...this._options };
    graphics.offset = this.offset.clone();
    if (this.color) {
      graphics.color = this.color.clone();
    }
    graphics.opacity = this.opacity;
    graphics.anchor = this.anchor.clone();
    graphics.copyGraphics = this.copyGraphics;
    graphics.onPreDraw = this.onPreDraw;
    graphics.onPostDraw = this.onPostDraw;
    graphics.isVisible = this.isVisible;
    return graphics;
  }
}
class PointerComponent extends Component {
  constructor(options) {
    var _a, _b;
    super();
    this.useColliderShape = true;
    this.useGraphicsBounds = true;
    this.useColliderShape = (_a = options == null ? void 0 : options.useColliderShape) != null ? _a : this.useColliderShape;
    this.useGraphicsBounds = (_b = options == null ? void 0 : options.useGraphicsBounds) != null ? _b : this.useGraphicsBounds;
    this.localBounds = options == null ? void 0 : options.localBounds;
  }
}
const _EasingFunctions = class _EasingFunctions2 {
  static CreateReversibleEasingFunction(easing) {
    return (time, start, end, duration) => {
      if (end < start) {
        return start - (easing(time, end, start, duration) - end);
      } else {
        return easing(time, start, end, duration);
      }
    };
  }
  static CreateVectorEasingFunction(easing) {
    return (time, start, end, duration) => {
      return new Vector(easing(time, start.x, end.x, duration), easing(time, start.y, end.y, duration));
    };
  }
};
_EasingFunctions.Linear = _EasingFunctions.CreateReversibleEasingFunction(
  (currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    return endValue * currentTime / duration + startValue;
  }
);
_EasingFunctions.EaseInQuad = _EasingFunctions.CreateReversibleEasingFunction(
  (currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime + startValue;
  }
);
_EasingFunctions.EaseOutQuad = _EasingFunctions.CreateReversibleEasingFunction(
  (currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return -endValue * currentTime * (currentTime - 2) + startValue;
  }
);
_EasingFunctions.EaseInOutQuad = _EasingFunctions.CreateReversibleEasingFunction(
  (currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
      return endValue / 2 * currentTime * currentTime + startValue;
    }
    currentTime--;
    return -endValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
  }
);
_EasingFunctions.EaseInCubic = _EasingFunctions.CreateReversibleEasingFunction(
  (currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime * currentTime + startValue;
  }
);
_EasingFunctions.EaseOutCubic = _EasingFunctions.CreateReversibleEasingFunction(
  (currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    currentTime--;
    return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
  }
);
_EasingFunctions.EaseInOutCubic = _EasingFunctions.CreateReversibleEasingFunction(
  (currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
      return endValue / 2 * currentTime * currentTime * currentTime + startValue;
    }
    currentTime -= 2;
    return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;
  }
);
let EasingFunctions = _EasingFunctions;
class ActionQueue {
  constructor(entity) {
    this._actions = [];
    this._currentAction = null;
    this._completedActions = [];
    this._entity = entity;
  }
  /**
   * Add an action to the sequence
   * @param action
   */
  add(action) {
    this._actions.push(action);
  }
  /**
   * Remove an action by reference from the sequence
   * @param action
   */
  remove(action) {
    const index = this._actions.indexOf(action);
    this._actions.splice(index, 1);
  }
  /**
   * Removes all actions from this sequence
   */
  clearActions() {
    this._actions.length = 0;
    this._completedActions.length = 0;
    if (this._currentAction) {
      this._currentAction.stop();
    }
  }
  /**
   *
   * @returns The total list of actions in this sequence complete or not
   */
  getActions() {
    return this._actions.concat(this._completedActions);
  }
  getIncompleteActions() {
    return this._actions;
  }
  getCurrentAction() {
    return this._currentAction;
  }
  /**
   *
   * @returns `true` if there are more actions to process in the sequence
   */
  hasNext() {
    return this._actions.length > 0;
  }
  /**
   * @returns `true` if the current sequence of actions is done
   */
  isComplete() {
    return this._actions.length === 0;
  }
  /**
   * Resets the sequence of actions, this is used to restart a sequence from the beginning
   */
  reset() {
    this._actions = this.getActions();
    const len = this._actions.length;
    for (let i = 0; i < len; i++) {
      this._actions[i].reset();
    }
    this._completedActions = [];
  }
  /**
   * Update the queue which updates actions and handles completing actions
   * @param elapsed
   */
  update(elapsed) {
    if (this._actions.length > 0) {
      if (this._currentAction !== this._actions[0]) {
        this._currentAction = this._actions[0];
        this._entity.emit("actionstart", new ActionStartEvent(this._currentAction, this._entity));
      }
      this._currentAction.update(elapsed);
      if (this._currentAction.isComplete(this._entity)) {
        this._entity.emit("actioncomplete", new ActionCompleteEvent(this._currentAction, this._entity));
        const complete = this._actions.shift();
        if (complete) {
          this._completedActions.push(complete);
        }
      }
    }
  }
}
let _ACTION_ID = 0;
function nextActionId() {
  return _ACTION_ID++;
}
class Repeat {
  constructor(entity, repeatBuilder, repeat) {
    this.id = nextActionId();
    this._stopped = false;
    this._repeatBuilder = repeatBuilder;
    this._repeatContext = new ActionContext(entity);
    this._actionQueue = this._repeatContext.getQueue();
    this._repeat = repeat;
    this._originalRepeat = repeat;
    this._repeatBuilder(this._repeatContext);
    this._repeat--;
  }
  update(elapsed) {
    if (this._actionQueue.isComplete()) {
      this._actionQueue.clearActions();
      this._repeatBuilder(this._repeatContext);
      this._repeat--;
    }
    this._actionQueue.update(elapsed);
  }
  isComplete() {
    return this._stopped || this._repeat <= 0 && this._actionQueue.isComplete();
  }
  stop() {
    this._stopped = true;
  }
  reset() {
    this._repeat = this._originalRepeat;
  }
}
class RepeatForever {
  constructor(entity, repeatBuilder) {
    this.id = nextActionId();
    this._stopped = false;
    this._repeatBuilder = repeatBuilder;
    this._repeatContext = new ActionContext(entity);
    this._actionQueue = this._repeatContext.getQueue();
    this._repeatBuilder(this._repeatContext);
  }
  update(elapsed) {
    if (this._stopped) {
      return;
    }
    if (this._actionQueue.isComplete()) {
      this._actionQueue.clearActions();
      this._repeatBuilder(this._repeatContext);
    }
    this._actionQueue.update(elapsed);
  }
  isComplete() {
    return this._stopped;
  }
  stop() {
    this._stopped = true;
    this._actionQueue.clearActions();
  }
  reset() {
    return;
  }
}
function isMoveByOptions(x) {
  return x.offset instanceof Vector && typeof x.duration === "number";
}
class MoveByWithOptions {
  constructor(entity, options) {
    this.entity = entity;
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._easing = EasingFunctions.Linear;
    var _a;
    this._offset = options.offset;
    this._easing = (_a = options.easing) != null ? _a : this._easing;
    this._tx = entity.get(TransformComponent);
    this._motion = entity.get(MotionComponent);
    if (!this._tx) {
      throw new Error(`Entity ${entity.name} has no TransformComponent, can only MoveBy on Entities with TransformComponents.`);
    }
    this._durationMs = options.duration;
    this._currentMs = this._durationMs;
  }
  update(elapsed) {
    if (!this._started) {
      this._start = this._tx.pos.clone();
      this._end = this._start.add(this._offset);
      this._started = true;
    }
    this._currentMs -= elapsed;
    const t = clamp(remap(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
    const currentPos = this._tx.pos;
    const newPosX = this._easing(t, this._start.x, this._end.x, 1);
    const newPosY = this._easing(t, this._start.y, this._end.y, 1);
    const seconds = elapsed / 1e3;
    const velX = seconds === 0 ? 0 : (newPosX - currentPos.x) / seconds;
    const velY = seconds === 0 ? 0 : (newPosY - currentPos.y) / seconds;
    this._motion.vel.x = velX;
    this._motion.vel.y = velY;
    if (this.isComplete(this.entity)) {
      this._tx.pos = vec(this._end.x, this._end.y);
      this._motion.vel = vec(0, 0);
    }
  }
  isComplete(entity) {
    return this._stopped || this._currentMs < 0;
  }
  stop() {
    this._motion.vel = vec(0, 0);
    this._stopped = true;
    this._currentMs = 0;
  }
  reset() {
    this._currentMs = this._durationMs;
    this._started = false;
    this._stopped = false;
  }
}
class MoveBy {
  constructor(entity, offsetX, offsetY, speed) {
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._entity = entity;
    this._tx = entity.get(TransformComponent);
    this._motion = entity.get(MotionComponent);
    this._speed = speed;
    this._offset = new Vector(offsetX, offsetY);
    if (speed <= 0) {
      Logger.getInstance().error("Attempted to moveBy with speed less than or equal to zero : " + speed);
      throw new Error("Speed must be greater than 0 pixels per second");
    }
  }
  update(elapsed) {
    if (!this._started) {
      this._started = true;
      this._start = new Vector(this._tx.pos.x, this._tx.pos.y);
      this._end = this._start.add(this._offset);
      this._distance = this._offset.magnitude;
      this._dir = this._end.sub(this._start).normalize();
    }
    if (this.isComplete(this._entity)) {
      this._tx.pos = vec(this._end.x, this._end.y);
      this._motion.vel = vec(0, 0);
    } else {
      this._motion.vel = this._dir.scale(this._speed);
    }
  }
  isComplete(entity) {
    const tx = entity.get(TransformComponent);
    return this._stopped || tx.pos.distance(this._start) >= this._distance;
  }
  stop() {
    this._motion.vel = vec(0, 0);
    this._stopped = true;
  }
  reset() {
    this._started = false;
    this._stopped = false;
  }
}
function isMoveToOptions(x) {
  return x.pos instanceof Vector && typeof x.duration === "number";
}
class MoveToWithOptions {
  constructor(entity, options) {
    this.entity = entity;
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._easing = EasingFunctions.Linear;
    var _a;
    this._end = options.pos;
    this._easing = (_a = options.easing) != null ? _a : this._easing;
    this._tx = entity.get(TransformComponent);
    this._motion = entity.get(MotionComponent);
    if (!this._tx) {
      throw new Error(`Entity ${entity.name} has no TransformComponent, can only moveTo on Entities with TransformComponents.`);
    }
    this._durationMs = options.duration;
    this._currentMs = this._durationMs;
  }
  update(elapsed) {
    if (!this._started) {
      this._start = this._tx.pos.clone();
      this._started = true;
    }
    this._currentMs -= elapsed;
    const t = clamp(remap(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
    const currentPos = this._tx.pos;
    const newPosX = this._easing(t, this._start.x, this._end.x, 1);
    const newPosY = this._easing(t, this._start.y, this._end.y, 1);
    const seconds = elapsed / 1e3;
    const velX = seconds === 0 ? 0 : (newPosX - currentPos.x) / seconds;
    const velY = seconds === 0 ? 0 : (newPosY - currentPos.y) / seconds;
    this._motion.vel.x = velX;
    this._motion.vel.y = velY;
    if (this.isComplete(this.entity)) {
      this._tx.pos = vec(this._end.x, this._end.y);
      this._motion.vel = vec(0, 0);
    }
  }
  isComplete(entity) {
    return this._stopped || this._currentMs < 0;
  }
  stop() {
    this._motion.vel = vec(0, 0);
    this._stopped = true;
    this._currentMs = 0;
  }
  reset() {
    this._currentMs = this._durationMs;
    this._started = false;
    this._stopped = false;
  }
}
class MoveTo {
  constructor(entity, destX, destY, speed) {
    this.entity = entity;
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._tx = entity.get(TransformComponent);
    this._motion = entity.get(MotionComponent);
    this._end = new Vector(destX, destY);
    this._speed = speed;
  }
  update(elapsed) {
    if (!this._started) {
      this._started = true;
      this._start = new Vector(this._tx.pos.x, this._tx.pos.y);
      this._distance = this._start.distance(this._end);
      this._dir = this._end.sub(this._start).normalize();
    }
    const m = this._dir.scale(this._speed);
    this._motion.vel = vec(m.x, m.y);
    if (this.isComplete(this.entity)) {
      this._tx.pos = vec(this._end.x, this._end.y);
      this._motion.vel = vec(0, 0);
    }
  }
  isComplete(entity) {
    const tx = entity.get(TransformComponent);
    return this._stopped || new Vector(tx.pos.x, tx.pos.y).distance(this._start) >= this._distance;
  }
  stop() {
    this._motion.vel = vec(0, 0);
    this._stopped = true;
  }
  reset() {
    this._started = false;
    this._stopped = false;
  }
}
function isRotateToOptions(x) {
  return typeof x.angle === "number" && typeof x.duration === "number";
}
class RotateToWithOptions {
  constructor(entity, options) {
    this.entity = entity;
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._endAngle = 0;
    this._startAngle = 0;
    var _a;
    this._endAngle = options.angle;
    this._tx = entity.get(TransformComponent);
    this._motion = entity.get(MotionComponent);
    if (!this._tx) {
      throw new Error(`Entity ${entity.name} has no TransformComponent, can only RotateTo on Entities with TransformComponents.`);
    }
    this._durationMs = options.duration;
    this._rotationType = (_a = options.rotationType) != null ? _a : RotationType.ShortestPath;
    this._currentMs = this._durationMs;
  }
  update(elapsed) {
    if (!this._started) {
      this._startAngle = this._tx.rotation;
      this._started = true;
    }
    this._currentMs -= elapsed;
    const t = clamp(remap(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
    const newAngle = lerpAngle(this._startAngle, this._endAngle, this._rotationType, t);
    const currentAngle = this._tx.rotation;
    const seconds = elapsed / 1e3;
    const rx = seconds === 0 ? 0 : (newAngle - currentAngle) / seconds;
    this._motion.angularVelocity = rx;
    if (this.isComplete(this.entity)) {
      this._tx.rotation = this._endAngle;
      this._motion.angularVelocity = 0;
    }
  }
  isComplete(entity) {
    return this._stopped || this._currentMs < 0;
  }
  stop() {
    this._motion.angularVelocity = 0;
    this._stopped = true;
    this._currentMs = 0;
  }
  reset() {
    this._currentMs = this._durationMs;
    this._started = false;
    this._stopped = false;
  }
}
class RotateTo {
  constructor(entity, angle, speed, rotationType) {
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._tx = entity.get(TransformComponent);
    this._motion = entity.get(MotionComponent);
    this._end = angle;
    this._speed = speed;
    this._rotationType = rotationType || RotationType.ShortestPath;
  }
  update(elapsed) {
    if (!this._started) {
      this._started = true;
      this._start = this._tx.rotation;
      this._currentNonCannonAngle = this._tx.rotation;
      const distance1 = Math.abs(this._end - this._start);
      const distance2 = TwoPI - distance1;
      if (distance1 > distance2) {
        this._shortDistance = distance2;
        this._longDistance = distance1;
      } else {
        this._shortDistance = distance1;
        this._longDistance = distance2;
      }
      this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;
      switch (this._rotationType) {
        case RotationType.ShortestPath:
          this._distance = this._shortDistance;
          if (this._shortestPathIsPositive) {
            this._direction = 1;
          } else {
            this._direction = -1;
          }
          break;
        case RotationType.LongestPath:
          this._distance = this._longDistance;
          if (this._shortestPathIsPositive) {
            this._direction = -1;
          } else {
            this._direction = 1;
          }
          break;
        case RotationType.Clockwise:
          this._direction = 1;
          if (this._shortestPathIsPositive) {
            this._distance = this._shortDistance;
          } else {
            this._distance = this._longDistance;
          }
          break;
        case RotationType.CounterClockwise:
          this._direction = -1;
          if (!this._shortestPathIsPositive) {
            this._distance = this._shortDistance;
          } else {
            this._distance = this._longDistance;
          }
          break;
      }
    }
    this._motion.angularVelocity = this._direction * this._speed;
    this._currentNonCannonAngle += this._direction * this._speed * (elapsed / 1e3);
    if (this.isComplete()) {
      this._tx.rotation = this._end;
      this._motion.angularVelocity = 0;
      this._stopped = true;
    }
  }
  isComplete() {
    const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);
    return this._stopped || distanceTraveled >= Math.abs(this._distance);
  }
  stop() {
    this._motion.angularVelocity = 0;
    this._stopped = true;
  }
  reset() {
    this._started = false;
    this._stopped = false;
  }
}
function isRotateByOptions(x) {
  return typeof x.angleRadiansOffset === "number" && typeof x.duration === "number";
}
class RotateByWithOptions {
  constructor(entity, options) {
    this.entity = entity;
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._offset = 0;
    this._startAngle = 0;
    this._endAngle = 0;
    var _a;
    this._offset = options.angleRadiansOffset;
    this._tx = entity.get(TransformComponent);
    this._motion = entity.get(MotionComponent);
    if (!this._tx) {
      throw new Error(`Entity ${entity.name} has no TransformComponent, can only RotateBy on Entities with TransformComponents.`);
    }
    this._durationMs = options.duration;
    this._rotationType = (_a = options.rotationType) != null ? _a : RotationType.ShortestPath;
    this._currentMs = this._durationMs;
  }
  update(elapsed) {
    if (!this._started) {
      this._startAngle = this._tx.rotation;
      this._endAngle = canonicalizeAngle(this._startAngle + this._offset);
      this._started = true;
    }
    this._currentMs -= elapsed;
    const t = clamp(remap(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
    const newAngle = lerpAngle(this._startAngle, this._endAngle, this._rotationType, t);
    const currentAngle = this._tx.rotation;
    const seconds = elapsed / 1e3;
    const rx = seconds === 0 ? 0 : (newAngle - currentAngle) / seconds;
    this._motion.angularVelocity = rx;
    if (this.isComplete()) {
      this._tx.rotation = this._endAngle;
      this._motion.angularVelocity = 0;
    }
  }
  isComplete() {
    return this._stopped || this._currentMs < 0;
  }
  stop() {
    this._motion.angularVelocity = 0;
    this._stopped = true;
    this._currentMs = 0;
  }
  reset() {
    this._currentMs = this._durationMs;
    this._started = false;
    this._stopped = false;
  }
}
class RotateBy {
  constructor(entity, angleRadiansOffset, speed, rotationType) {
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._tx = entity.get(TransformComponent);
    this._motion = entity.get(MotionComponent);
    this._speed = speed;
    this._offset = angleRadiansOffset;
    this._rotationType = rotationType || RotationType.ShortestPath;
  }
  update(elapsed) {
    if (!this._started) {
      this._started = true;
      this._start = this._tx.rotation;
      this._currentNonCannonAngle = this._tx.rotation;
      this._end = this._start + this._offset;
      const distance1 = Math.abs(this._end - this._start);
      const distance2 = TwoPI - distance1;
      if (distance1 > distance2) {
        this._shortDistance = distance2;
        this._longDistance = distance1;
      } else {
        this._shortDistance = distance1;
        this._longDistance = distance2;
      }
      this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;
      switch (this._rotationType) {
        case RotationType.ShortestPath:
          this._distance = this._shortDistance;
          if (this._shortestPathIsPositive) {
            this._direction = 1;
          } else {
            this._direction = -1;
          }
          break;
        case RotationType.LongestPath:
          this._distance = this._longDistance;
          if (this._shortestPathIsPositive) {
            this._direction = -1;
          } else {
            this._direction = 1;
          }
          break;
        case RotationType.Clockwise:
          this._direction = 1;
          if (this._shortDistance >= 0) {
            this._distance = this._shortDistance;
          } else {
            this._distance = this._longDistance;
          }
          break;
        case RotationType.CounterClockwise:
          this._direction = -1;
          if (this._shortDistance <= 0) {
            this._distance = this._shortDistance;
          } else {
            this._distance = this._longDistance;
          }
          break;
      }
    }
    this._motion.angularVelocity = this._direction * this._speed;
    this._currentNonCannonAngle += this._direction * this._speed * (elapsed / 1e3);
    if (this.isComplete()) {
      this._tx.rotation = this._end;
      this._motion.angularVelocity = 0;
      this._stopped = true;
    }
  }
  isComplete() {
    const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);
    return this._stopped || distanceTraveled >= Math.abs(this._distance);
  }
  stop() {
    this._motion.angularVelocity = 0;
    this._stopped = true;
  }
  reset() {
    this._started = false;
    this._stopped = false;
    this._start = void 0;
    this._currentNonCannonAngle = void 0;
    this._distance = void 0;
  }
}
function isScaleToOptions(x) {
  return typeof x.scale === "object" && typeof x.duration === "number";
}
class ScaleToWithOptions {
  constructor(entity, options) {
    this.entity = entity;
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._endScale = vec(1, 1);
    this._startScale = vec(1, 1);
    this._endScale = options.scale;
    this._tx = entity.get(TransformComponent);
    this._motion = entity.get(MotionComponent);
    if (!this._tx) {
      throw new Error(`Entity ${entity.name} has no TransformComponent, can only ScaleTo on Entities with TransformComponents.`);
    }
    this._durationMs = options.duration;
    this._currentMs = this._durationMs;
  }
  update(elapsed) {
    if (!this._started) {
      this._startScale = this._tx.scale;
      this._started = true;
    }
    this._currentMs -= elapsed;
    const t = clamp(remap(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
    const newScale = lerpVector(this._startScale, this._endScale, t);
    const currentScale = this._tx.scale;
    const seconds = elapsed / 1e3;
    const sx = newScale.sub(currentScale).scale(seconds === 0 ? 0 : 1 / seconds);
    this._motion.scaleFactor = sx;
    if (this.isComplete()) {
      this._tx.scale = this._endScale;
      this._motion.angularVelocity = 0;
    }
  }
  isComplete() {
    return this._stopped || this._currentMs < 0;
  }
  stop() {
    this._motion.scaleFactor = Vector.Zero;
    this._stopped = true;
    this._currentMs = 0;
  }
  reset() {
    this._currentMs = this._durationMs;
    this._started = false;
    this._stopped = false;
  }
}
class ScaleTo {
  constructor(entity, scaleX, scaleY, speedX, speedY) {
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._tx = entity.get(TransformComponent);
    this._motion = entity.get(MotionComponent);
    this._endX = scaleX;
    this._endY = scaleY;
    this._speedX = speedX;
    this._speedY = speedY;
  }
  update(elapsed) {
    if (!this._started) {
      this._started = true;
      this._startX = this._tx.scale.x;
      this._startY = this._tx.scale.y;
      this._distanceX = Math.abs(this._endX - this._startX);
      this._distanceY = Math.abs(this._endY - this._startY);
    }
    if (!(Math.abs(this._tx.scale.x - this._startX) >= this._distanceX)) {
      const directionX = this._endY < this._startY ? -1 : 1;
      this._motion.scaleFactor.x = this._speedX * directionX;
    } else {
      this._motion.scaleFactor.x = 0;
    }
    if (!(Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)) {
      const directionY = this._endY < this._startY ? -1 : 1;
      this._motion.scaleFactor.y = this._speedY * directionY;
    } else {
      this._motion.scaleFactor.y = 0;
    }
    if (this.isComplete()) {
      this._tx.scale = vec(this._endX, this._endY);
      this._motion.scaleFactor.x = 0;
      this._motion.scaleFactor.y = 0;
    }
  }
  isComplete() {
    return this._stopped || Math.abs(this._tx.scale.x - this._startX) >= this._distanceX - 0.01 && Math.abs(this._tx.scale.y - this._startY) >= this._distanceY - 0.01;
  }
  stop() {
    this._motion.scaleFactor.x = 0;
    this._motion.scaleFactor.y = 0;
    this._stopped = true;
  }
  reset() {
    this._started = false;
    this._stopped = false;
  }
}
function isScaleByOptions(x) {
  return typeof x.scaleOffset === "object" && typeof x.duration === "number";
}
class ScaleByWithOptions {
  constructor(entity, options) {
    this.entity = entity;
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._endScale = vec(1, 1);
    this._scaleOffset = vec(0, 0);
    this._startScale = vec(1, 1);
    this._scaleOffset = options.scaleOffset;
    this._tx = entity.get(TransformComponent);
    this._motion = entity.get(MotionComponent);
    if (!this._tx) {
      throw new Error(`Entity ${entity.name} has no TransformComponent, can only ScaleBy on Entities with TransformComponents.`);
    }
    this._durationMs = options.duration;
    this._currentMs = this._durationMs;
  }
  update(elapsed) {
    if (!this._started) {
      this._startScale = this._tx.scale;
      this._endScale = this._startScale.add(this._scaleOffset);
      this._started = true;
    }
    this._currentMs -= elapsed;
    const t = clamp(remap(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
    const newScale = lerpVector(this._startScale, this._endScale, t);
    const currentScale = this._tx.scale;
    const seconds = elapsed / 1e3;
    const sx = newScale.sub(currentScale).scale(seconds === 0 ? 0 : 1 / seconds);
    this._motion.scaleFactor = sx;
    if (this.isComplete()) {
      this._tx.scale = this._endScale;
      this._motion.angularVelocity = 0;
    }
  }
  isComplete() {
    return this._stopped || this._currentMs < 0;
  }
  stop() {
    this._motion.scaleFactor = Vector.Zero;
    this._stopped = true;
    this._currentMs = 0;
  }
  reset() {
    this._currentMs = this._durationMs;
    this._started = false;
    this._stopped = false;
  }
}
class ScaleBy {
  constructor(entity, scaleOffsetX, scaleOffsetY, speed) {
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._tx = entity.get(TransformComponent);
    this._motion = entity.get(MotionComponent);
    this._offset = new Vector(scaleOffsetX, scaleOffsetY);
    this._speedX = this._speedY = speed;
  }
  update(elapsed) {
    if (!this._started) {
      this._started = true;
      this._startScale = this._tx.scale.clone();
      this._endScale = this._startScale.add(this._offset);
      this._distanceX = Math.abs(this._endScale.x - this._startScale.x);
      this._distanceY = Math.abs(this._endScale.y - this._startScale.y);
      this._directionX = this._endScale.x < this._startScale.x ? -1 : 1;
      this._directionY = this._endScale.y < this._startScale.y ? -1 : 1;
    }
    this._motion.scaleFactor.x = this._speedX * this._directionX;
    this._motion.scaleFactor.y = this._speedY * this._directionY;
    if (this.isComplete()) {
      this._tx.scale = this._endScale;
      this._motion.scaleFactor.x = 0;
      this._motion.scaleFactor.y = 0;
    }
  }
  isComplete() {
    return this._stopped || Math.abs(this._tx.scale.x - this._startScale.x) >= this._distanceX - 0.01 && Math.abs(this._tx.scale.y - this._startScale.y) >= this._distanceY - 0.01;
  }
  stop() {
    this._motion.scaleFactor.x = 0;
    this._motion.scaleFactor.y = 0;
    this._stopped = true;
  }
  reset() {
    this._started = false;
    this._stopped = false;
  }
}
class CallMethod {
  constructor(method) {
    this.id = nextActionId();
    this._hasBeenCalled = false;
    this._method = method;
  }
  update(elapsed) {
    this._method();
    this._hasBeenCalled = true;
  }
  isComplete() {
    return this._hasBeenCalled;
  }
  reset() {
    this._hasBeenCalled = false;
  }
  stop() {
    this._hasBeenCalled = true;
  }
}
class EaseTo {
  constructor(entity, x, y, duration, easingFcn) {
    this.easingFcn = easingFcn;
    this.id = nextActionId();
    this._currentLerpTime = 0;
    this._lerpDuration = 1 * 1e3;
    this._lerpStart = new Vector(0, 0);
    this._lerpEnd = new Vector(0, 0);
    this._initialized = false;
    this._stopped = false;
    this._tx = entity.get(TransformComponent);
    this._motion = entity.get(MotionComponent);
    this._lerpDuration = duration;
    this._lerpEnd = new Vector(x, y);
  }
  _initialize() {
    this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);
    this._currentLerpTime = 0;
  }
  update(elapsed) {
    if (!this._initialized) {
      this._initialize();
      this._initialized = true;
    }
    this._currentLerpTime += elapsed;
    let newX = this._tx.pos.x;
    let newY = this._tx.pos.y;
    if (this._currentLerpTime < this._lerpDuration) {
      if (this._lerpEnd.x < this._lerpStart.x) {
        newX = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
      } else {
        newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
      }
      if (this._lerpEnd.y < this._lerpStart.y) {
        newY = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
      } else {
        newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
      }
      const seconds = elapsed / 1e3;
      this._motion.vel = vec(seconds === 0 ? 0 : (newX - this._tx.pos.x) / seconds, seconds === 0 ? 0 : (newY - this._tx.pos.y) / seconds);
    } else {
      this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);
      this._motion.vel = Vector.Zero;
    }
  }
  isComplete() {
    return this._stopped || this._currentLerpTime >= this._lerpDuration;
  }
  reset() {
    this._initialized = false;
    this._stopped = false;
    this._currentLerpTime = 0;
  }
  stop() {
    this._motion.vel = vec(0, 0);
    this._stopped = true;
  }
}
class EaseBy {
  constructor(entity, offsetX, offsetY, duration, easingFcn) {
    this.easingFcn = easingFcn;
    this.id = nextActionId();
    this._currentLerpTime = 0;
    this._lerpDuration = 1 * 1e3;
    this._lerpStart = new Vector(0, 0);
    this._lerpEnd = new Vector(0, 0);
    this._initialized = false;
    this._stopped = false;
    this._tx = entity.get(TransformComponent);
    this._motion = entity.get(MotionComponent);
    this._lerpDuration = duration;
    this._offset = new Vector(offsetX, offsetY);
  }
  _initialize() {
    this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);
    this._currentLerpTime = 0;
    this._lerpEnd = this._lerpStart.add(this._offset);
  }
  update(elapsed) {
    if (!this._initialized) {
      this._initialize();
      this._initialized = true;
    }
    this._currentLerpTime += elapsed;
    let newX = this._tx.pos.x;
    let newY = this._tx.pos.y;
    if (this._currentLerpTime < this._lerpDuration) {
      if (this._lerpEnd.x < this._lerpStart.x) {
        newX = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
      } else {
        newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
      }
      if (this._lerpEnd.y < this._lerpStart.y) {
        newY = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
      } else {
        newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
      }
      const seconds = elapsed / 1e3;
      this._motion.vel = vec(seconds === 0 ? 0 : (newX - this._tx.pos.x) / seconds, seconds === 0 ? 0 : (newY - this._tx.pos.y) / seconds);
    } else {
      this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);
      this._motion.vel = Vector.Zero;
    }
  }
  isComplete() {
    return this._stopped || this._currentLerpTime >= this._lerpDuration;
  }
  reset() {
    this._initialized = false;
    this._stopped = false;
    this._currentLerpTime = 0;
  }
  stop() {
    this._motion.vel = vec(0, 0);
    this._stopped = true;
  }
}
class Blink {
  constructor(entity, timeVisible, timeNotVisible, numBlinks = 1) {
    this.id = nextActionId();
    this._timeVisible = 0;
    this._timeNotVisible = 0;
    this._elapsedTime = 0;
    this._totalTime = 0;
    this._stopped = false;
    this._started = false;
    this._graphics = entity.get(GraphicsComponent);
    this._timeVisible = timeVisible;
    this._timeNotVisible = timeNotVisible;
    this._duration = (timeVisible + timeNotVisible) * numBlinks;
  }
  update(elapsed) {
    if (!this._started) {
      this._started = true;
      this._elapsedTime = 0;
      this._totalTime = 0;
    }
    if (!this._graphics) {
      return;
    }
    this._elapsedTime += elapsed;
    this._totalTime += elapsed;
    if (this._graphics.isVisible && this._elapsedTime >= this._timeVisible) {
      this._graphics.isVisible = false;
      this._elapsedTime = 0;
    }
    if (!this._graphics.isVisible && this._elapsedTime >= this._timeNotVisible) {
      this._graphics.isVisible = true;
      this._elapsedTime = 0;
    }
    if (this.isComplete()) {
      this._graphics.isVisible = true;
    }
  }
  isComplete() {
    return this._stopped || this._totalTime >= this._duration;
  }
  stop() {
    if (this._graphics) {
      this._graphics.isVisible = true;
    }
    this._stopped = true;
  }
  reset() {
    this._started = false;
    this._stopped = false;
    this._elapsedTime = 0;
    this._totalTime = 0;
  }
}
class Fade {
  constructor(entity, endOpacity, duration) {
    this.id = nextActionId();
    this._multiplier = 1;
    this._started = false;
    this._stopped = false;
    this._graphics = entity.get(GraphicsComponent);
    this._endOpacity = endOpacity;
    this._remainingTime = this._originalTime = duration;
  }
  update(elapsed) {
    if (!this._graphics) {
      return;
    }
    if (!this._started) {
      this._started = true;
      this._remainingTime = this._originalTime;
      if (this._endOpacity < this._graphics.opacity) {
        this._multiplier = -1;
      } else {
        this._multiplier = 1;
      }
    }
    if (this._remainingTime > 0) {
      this._graphics.opacity += this._multiplier * (Math.abs(this._graphics.opacity - this._endOpacity) * elapsed) / this._remainingTime;
    }
    this._remainingTime -= elapsed;
    if (this.isComplete()) {
      this._graphics.opacity = this._endOpacity;
    }
    Logger.getInstance().debug("[Action fade] Actor opacity:", this._graphics.opacity);
  }
  isComplete() {
    return this._stopped || this._remainingTime <= 0;
  }
  stop() {
    this._stopped = true;
  }
  reset() {
    this._started = false;
    this._stopped = false;
    this._remainingTime = this._originalTime;
  }
}
class Delay {
  constructor(duration) {
    this.id = nextActionId();
    this._elapsedTime = 0;
    this._started = false;
    this._stopped = false;
    this._delay = duration;
  }
  update(elapsed) {
    if (!this._started) {
      this._started = true;
    }
    this._elapsedTime += elapsed;
  }
  isComplete() {
    return this._stopped || this._elapsedTime >= this._delay;
  }
  stop() {
    this._stopped = true;
  }
  reset() {
    this._elapsedTime = 0;
    this._started = false;
    this._stopped = false;
  }
}
class Die {
  constructor(entity) {
    this.id = nextActionId();
    this._stopped = false;
    this._entity = entity;
  }
  update(elapsed) {
    this._entity.get(ActionsComponent).clearActions();
    this._entity.kill();
    this._stopped = true;
  }
  isComplete() {
    return this._stopped;
  }
  stop() {
    return;
  }
  reset() {
    return;
  }
}
class Follow {
  constructor(entity, entityToFollow, followDistance) {
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._tx = entity.get(TransformComponent);
    this._motion = entity.get(MotionComponent);
    this._followTx = entityToFollow.get(TransformComponent);
    this._followMotion = entityToFollow.get(MotionComponent);
    this._current = new Vector(this._tx.pos.x, this._tx.pos.y);
    this._end = new Vector(this._followTx.pos.x, this._followTx.pos.y);
    this._maximumDistance = followDistance !== void 0 ? followDistance : this._current.distance(this._end);
    this._speed = 0;
  }
  update(elapsed) {
    if (!this._started) {
      this._started = true;
      this._distanceBetween = this._current.distance(this._end);
      this._dir = this._end.sub(this._current).normalize();
    }
    const actorToFollowSpeed = Math.sqrt(Math.pow(this._followMotion.vel.x, 2) + Math.pow(this._followMotion.vel.y, 2));
    if (actorToFollowSpeed !== 0) {
      this._speed = actorToFollowSpeed;
    }
    this._current = vec(this._tx.pos.x, this._tx.pos.y);
    this._end = vec(this._followTx.pos.x, this._followTx.pos.y);
    this._distanceBetween = this._current.distance(this._end);
    this._dir = this._end.sub(this._current).normalize();
    if (this._distanceBetween >= this._maximumDistance) {
      const m = this._dir.scale(this._speed);
      this._motion.vel = vec(m.x, m.y);
    } else {
      this._motion.vel = vec(0, 0);
    }
    if (this.isComplete()) {
      this._tx.pos = vec(this._end.x, this._end.y);
      this._motion.vel = vec(0, 0);
    }
  }
  stop() {
    this._motion.vel = vec(0, 0);
    this._stopped = true;
  }
  isComplete() {
    return this._stopped;
  }
  reset() {
    this._started = false;
    this._stopped = false;
  }
}
class Meet {
  constructor(actor, actorToMeet, speed, tolerance) {
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._speedWasSpecified = false;
    this._tolerance = 1;
    this._tx = actor.get(TransformComponent);
    this._motion = actor.get(MotionComponent);
    this._meetTx = actorToMeet.get(TransformComponent);
    this._meetMotion = actorToMeet.get(MotionComponent);
    this._current = new Vector(this._tx.pos.x, this._tx.pos.y);
    this._end = new Vector(this._meetTx.pos.x, this._meetTx.pos.y);
    this._speed = speed || 0;
    if (speed !== void 0) {
      this._speedWasSpecified = true;
    }
    if (tolerance !== void 0) {
      this._tolerance = tolerance;
    }
  }
  update(elapsed) {
    if (!this._started) {
      this._started = true;
      this._distanceBetween = this._current.distance(this._end);
      this._dir = this._end.sub(this._current).normalize();
    }
    const actorToMeetSpeed = Math.sqrt(Math.pow(this._meetMotion.vel.x, 2) + Math.pow(this._meetMotion.vel.y, 2));
    if (actorToMeetSpeed !== 0 && !this._speedWasSpecified) {
      this._speed = actorToMeetSpeed;
    }
    this._current = vec(this._tx.pos.x, this._tx.pos.y);
    this._end = vec(this._meetTx.pos.x, this._meetTx.pos.y);
    this._distanceBetween = this._current.distance(this._end);
    this._dir = this._end.sub(this._current).normalize();
    const m = this._dir.scale(this._speed);
    this._motion.vel = vec(m.x, m.y);
    if (this.isComplete()) {
      this._tx.pos = vec(this._end.x, this._end.y);
      this._motion.vel = vec(0, 0);
    }
  }
  isComplete() {
    return this._stopped || this._distanceBetween <= this._tolerance;
  }
  stop() {
    this._motion.vel = vec(0, 0);
    this._stopped = true;
  }
  reset() {
    this._started = false;
    this._stopped = false;
    this._distanceBetween = Infinity;
  }
}
class Flash {
  constructor(entity, color, duration = 1e3) {
    this.id = nextActionId();
    this._stopped = false;
    this._started = false;
    this._total = 0;
    this._currentDuration = 0;
    var _a;
    this._graphics = entity.get(GraphicsComponent);
    this._duration = duration;
    this._entity = entity;
    this._material = (_a = entity.scene) == null ? void 0 : _a.engine.graphicsContext.createMaterial({
      name: "flash-material",
      color,
      fragmentSource: `#version 300 es
    
        precision mediump float;
        uniform float u_blend;
        uniform sampler2D u_graphic;
        uniform vec4 u_color;
    
        in vec2 v_uv; 
        out vec4 color;
    
        void main() { 
            vec4 textureColor = texture(u_graphic, v_uv); 
            color = mix(textureColor, u_color, u_blend * textureColor.a);
            color.rgb = color.rgb * color.a;
        }`
    });
    this._total = duration;
  }
  update(elapsed) {
    var _a;
    if (!this._started) {
      this._started = true;
      this._total = this._duration;
      this._currentDuration = this._duration;
      this._entity.graphics.material = this._material;
    }
    if (!this._graphics) {
      return;
    }
    this._currentDuration -= elapsed;
    if (this._graphics) {
      (_a = this._material) == null ? void 0 : _a.update((shader) => {
        shader.trySetUniformFloat("u_blend", this._currentDuration / this._total);
      });
    }
    if (this.isComplete()) {
      this._entity.graphics.material = null;
    }
  }
  isComplete() {
    return this._stopped || this._currentDuration <= 0;
  }
  stop() {
    if (this._graphics) {
      this._graphics.isVisible = true;
    }
    this._stopped = true;
  }
  reset() {
    this._started = false;
    this._stopped = false;
  }
}
class CurveTo {
  constructor(entity, options) {
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._mode = "dynamic";
    var _a;
    this._entity = entity;
    this._tx = this._entity.get(TransformComponent);
    if (!this._tx) {
      throw new Error(`Entity ${entity.name} has no TransformComponent, can only curveTo on Entities with TransformComponents.`);
    }
    this._curve = new BezierCurve({
      controlPoints: [vec(0, 0), ...options.controlPoints],
      quality: options.quality
    });
    this._durationMs = options.duration;
    this._mode = (_a = options.mode) != null ? _a : this._mode;
    this._currentMs = this._durationMs;
  }
  update(elapsed) {
    if (!this._started) {
      this._curve.setControlPoint(0, this._tx.globalPos.clone());
      this._started = true;
    }
    this._currentMs -= elapsed;
    const t = clamp(remap(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
    if (this._mode === "dynamic") {
      this._tx.pos = this._curve.getPoint(t);
    } else {
      this._tx.pos = this._curve.getUniformPoint(t);
    }
    if (this.isComplete(this._entity)) {
      if (this._mode === "dynamic") {
        this._tx.pos = this._curve.getPoint(1);
      } else {
        this._tx.pos = this._curve.getUniformPoint(1);
      }
    }
  }
  isComplete(entity) {
    return this._stopped || this._currentMs < 0;
  }
  reset() {
    this._currentMs = this._durationMs;
    this._started = false;
    this._stopped = false;
  }
  stop() {
    this._stopped = true;
    this._currentMs = 0;
  }
}
class CurveBy {
  constructor(entity, options) {
    this.id = nextActionId();
    this._started = false;
    this._stopped = false;
    this._mode = "dynamic";
    var _a;
    this._entity = entity;
    this._tx = this._entity.get(TransformComponent);
    if (!this._tx) {
      throw new Error(`Entity ${entity.name} has no TransformComponent, can only curveTo on Entities with TransformComponents.`);
    }
    this._curve = this._curve = new BezierCurve({
      controlPoints: [vec(0, 0), ...options.controlPoints],
      quality: options.quality
    });
    this._durationMs = options.duration;
    this._mode = (_a = options.mode) != null ? _a : this._mode;
    this._currentMs = this._durationMs;
  }
  update(elapsed) {
    if (!this._started) {
      this._curve.setControlPoint(0, this._tx.globalPos);
      this._curve.setControlPoint(1, this._curve.controlPoints[1].add(this._tx.globalPos));
      this._curve.setControlPoint(2, this._curve.controlPoints[2].add(this._tx.globalPos));
      this._curve.setControlPoint(3, this._curve.controlPoints[3].add(this._tx.globalPos));
      this._started = true;
    }
    this._currentMs -= elapsed;
    const t = clamp(remap(0, this._durationMs, 0, 1, this._durationMs - this._currentMs), 0, 1);
    if (this._mode === "dynamic") {
      this._tx.pos = this._curve.getPoint(t);
    } else {
      this._tx.pos = this._curve.getUniformPoint(t);
    }
    if (this.isComplete(this._entity)) {
      if (this._mode === "dynamic") {
        this._tx.pos = this._curve.getPoint(1);
      } else {
        this._tx.pos = this._curve.getUniformPoint(1);
      }
    }
  }
  isComplete(entity) {
    return this._stopped || this._currentMs < 0;
  }
  reset() {
    this._currentMs = this._durationMs;
    this._started = false;
    this._stopped = false;
  }
  stop() {
    this._stopped = true;
  }
}
class ActionContext {
  constructor(entity) {
    this._entity = entity;
    this._queue = new ActionQueue(entity);
  }
  getQueue() {
    return this._queue;
  }
  update(elapsed) {
    this._queue.update(elapsed);
  }
  /**
   * Clears all queued actions from the Actor
   */
  clearActions() {
    this._queue.clearActions();
  }
  runAction(action) {
    action.reset();
    this._queue.add(action);
    return this;
  }
  /**
   * Animates an actor with a specified bezier curve by an offset to the current position, the start point is assumed
   * to be the actors current position
   * @param options
   */
  curveBy(options) {
    this._queue.add(new CurveBy(this._entity, options));
    return this;
  }
  /**
   * Animates an actor with a specified bezier curve to an absolute world space coordinate, the start point is assumed
   * to be the actors current position
   * @param options
   */
  curveTo(options) {
    this._queue.add(new CurveTo(this._entity, options));
    return this;
  }
  easeTo(...args) {
    var _a, _b;
    let x = 0;
    let y = 0;
    let duration = 0;
    let easingFcn = EasingFunctions.Linear;
    if (args[0] instanceof Vector) {
      x = args[0].x;
      y = args[0].y;
      duration = args[1];
      easingFcn = (_a = args[2]) != null ? _a : easingFcn;
    } else {
      x = args[0];
      y = args[1];
      duration = args[2];
      easingFcn = (_b = args[3]) != null ? _b : easingFcn;
    }
    this._queue.add(new EaseTo(this._entity, x, y, duration, easingFcn));
    return this;
  }
  easeBy(...args) {
    var _a, _b;
    let offsetX = 0;
    let offsetY = 0;
    let duration = 0;
    let easingFcn = EasingFunctions.Linear;
    if (args[0] instanceof Vector) {
      offsetX = args[0].x;
      offsetY = args[0].y;
      duration = args[1];
      easingFcn = (_a = args[2]) != null ? _a : easingFcn;
    } else {
      offsetX = args[0];
      offsetY = args[1];
      duration = args[2];
      easingFcn = (_b = args[3]) != null ? _b : easingFcn;
    }
    this._queue.add(new EaseBy(this._entity, offsetX, offsetY, duration, easingFcn));
    return this;
  }
  moveTo(xOrPosOrOptions, yOrSpeed, speedOrUndefined) {
    let x = 0;
    let y = 0;
    let speed = 0;
    if (xOrPosOrOptions instanceof Vector) {
      x = xOrPosOrOptions.x;
      y = xOrPosOrOptions.y;
      speed = +(yOrSpeed != null ? yOrSpeed : 0);
      this._queue.add(new MoveTo(this._entity, x, y, speed));
    } else if (typeof xOrPosOrOptions === "number" && typeof yOrSpeed === "number" && typeof speedOrUndefined === "number") {
      x = xOrPosOrOptions;
      y = yOrSpeed;
      speed = speedOrUndefined;
      this._queue.add(new MoveTo(this._entity, x, y, speed));
    } else if (isMoveToOptions(xOrPosOrOptions)) {
      this._queue.add(new MoveToWithOptions(this._entity, xOrPosOrOptions));
    }
    return this;
  }
  moveBy(xOffsetOrVectorOrOptions, yOffsetOrSpeed, speedOrUndefined) {
    let xOffset = 0;
    let yOffset = 0;
    let speed = 0;
    if (xOffsetOrVectorOrOptions instanceof Vector && typeof yOffsetOrSpeed === "number") {
      xOffset = xOffsetOrVectorOrOptions.x;
      yOffset = xOffsetOrVectorOrOptions.y;
      speed = yOffsetOrSpeed;
      this._queue.add(new MoveBy(this._entity, xOffset, yOffset, speed));
    } else if (typeof xOffsetOrVectorOrOptions === "number" && typeof yOffsetOrSpeed === "number" && typeof speedOrUndefined === "number") {
      xOffset = xOffsetOrVectorOrOptions;
      yOffset = yOffsetOrSpeed;
      speed = speedOrUndefined;
      this._queue.add(new MoveBy(this._entity, xOffset, yOffset, speed));
    } else if (isMoveByOptions(xOffsetOrVectorOrOptions)) {
      this._queue.add(new MoveByWithOptions(this._entity, xOffsetOrVectorOrOptions));
    }
    return this;
  }
  rotateTo(angleRadiansOrOptions, speed, rotationType) {
    if (typeof angleRadiansOrOptions === "number" && typeof speed === "number") {
      this._queue.add(new RotateTo(this._entity, angleRadiansOrOptions, speed, rotationType));
    } else if (typeof angleRadiansOrOptions === "object") {
      this._queue.add(new RotateToWithOptions(this._entity, angleRadiansOrOptions));
    }
    return this;
  }
  rotateBy(angleRadiansOffsetOrOptions, speed, rotationType) {
    if (typeof angleRadiansOffsetOrOptions === "object") {
      this._queue.add(new RotateByWithOptions(this._entity, angleRadiansOffsetOrOptions));
    } else {
      this._queue.add(new RotateBy(this._entity, angleRadiansOffsetOrOptions, speed, rotationType));
    }
    return this;
  }
  scaleTo(sizeXOrVectorOrOptions, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
    let sizeX = 1;
    let sizeY = 1;
    let speedX = 0;
    let speedY = 0;
    if (isScaleToOptions(sizeXOrVectorOrOptions)) {
      this._queue.add(new ScaleToWithOptions(this._entity, sizeXOrVectorOrOptions));
      return this;
    }
    if (sizeXOrVectorOrOptions instanceof Vector && sizeYOrSpeed instanceof Vector) {
      sizeX = sizeXOrVectorOrOptions.x;
      sizeY = sizeXOrVectorOrOptions.y;
      speedX = sizeYOrSpeed.x;
      speedY = sizeYOrSpeed.y;
    }
    if (typeof sizeXOrVectorOrOptions === "number" && typeof sizeYOrSpeed === "number") {
      sizeX = sizeXOrVectorOrOptions;
      sizeY = sizeYOrSpeed;
      speedX = speedXOrUndefined;
      speedY = speedYOrUndefined;
    }
    this._queue.add(new ScaleTo(this._entity, sizeX, sizeY, speedX, speedY));
    return this;
  }
  scaleBy(sizeOffsetXOrVectorOrOptions, sizeOffsetYOrSpeed, speed) {
    if (isScaleByOptions(sizeOffsetXOrVectorOrOptions)) {
      this._queue.add(new ScaleByWithOptions(this._entity, sizeOffsetXOrVectorOrOptions));
      return this;
    }
    let sizeOffsetX = 1;
    let sizeOffsetY = 1;
    if (sizeOffsetXOrVectorOrOptions instanceof Vector) {
      sizeOffsetX = sizeOffsetXOrVectorOrOptions.x;
      sizeOffsetY = sizeOffsetXOrVectorOrOptions.y;
      speed = sizeOffsetYOrSpeed;
    }
    if (typeof sizeOffsetXOrVectorOrOptions === "number" && typeof sizeOffsetYOrSpeed === "number") {
      sizeOffsetX = sizeOffsetXOrVectorOrOptions;
      sizeOffsetY = sizeOffsetYOrSpeed;
    }
    this._queue.add(new ScaleBy(this._entity, sizeOffsetX, sizeOffsetY, speed));
    return this;
  }
  /**
   * This method will cause an actor to blink (become visible and not
   * visible). Optionally, you may specify the number of blinks. Specify the amount of time
   * the actor should be visible per blink, and the amount of time not visible.
   * This method is part of the actor 'Action' fluent API allowing action chaining.
   * @param timeVisible     The amount of time to stay visible per blink in milliseconds
   * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
   * @param numBlinks       The number of times to blink
   */
  blink(timeVisible, timeNotVisible, numBlinks = 1) {
    this._queue.add(new Blink(this._entity, timeVisible, timeNotVisible, numBlinks));
    return this;
  }
  /**
   * This method will cause an actor's opacity to change from its current value
   * to the provided value by a specified time (in milliseconds). This method is
   * part of the actor 'Action' fluent API allowing action chaining.
   * @param opacity  The ending opacity
   * @param duration     The time it should take to fade the actor (in milliseconds)
   */
  fade(opacity, duration) {
    this._queue.add(new Fade(this._entity, opacity, duration));
    return this;
  }
  /**
   * This will cause an actor to flash a specific color for a period of time
   * @param color
   * @param duration The duration in milliseconds
   */
  flash(color, duration = 1e3) {
    this._queue.add(new Flash(this._entity, color, duration));
    return this;
  }
  /**
   * This method will delay the next action from executing for a certain
   * amount of time (in milliseconds). This method is part of the actor
   * 'Action' fluent API allowing action chaining.
   * @param duration  The amount of time to delay the next action in the queue from executing in milliseconds
   */
  delay(duration) {
    this._queue.add(new Delay(duration));
    return this;
  }
  /**
   * This method will add an action to the queue that will remove the actor from the
   * scene once it has completed its previous  Any actions on the
   * action queue after this action will not be executed.
   */
  die() {
    this._queue.add(new Die(this._entity));
    return this;
  }
  /**
   * This method allows you to call an arbitrary method as the next action in the
   * action queue. This is useful if you want to execute code in after a specific
   * action, i.e An actor arrives at a destination after traversing a path
   */
  callMethod(method) {
    this._queue.add(new CallMethod(method));
    return this;
  }
  /**
   * This method will cause the actor to repeat all of the actions built in
   * the `repeatBuilder` callback. If the number of repeats
   * is not specified it will repeat forever. This method is part of
   * the actor 'Action' fluent API allowing action chaining
   *
   * ```typescript
   * // Move up in a zig-zag by repeated moveBy's
   * actor.actions.repeat(repeatCtx => {
   * repeatCtx.moveBy(10, 0, 10);
   * repeatCtx.moveBy(0, 10, 10);
   * }, 5);
   * ```
   * @param repeatBuilder The builder to specify the repeatable list of actions
   * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
   * will repeat forever
   */
  repeat(repeatBuilder, times) {
    if (!times) {
      this.repeatForever(repeatBuilder);
      return this;
    }
    this._queue.add(new Repeat(this._entity, repeatBuilder, times));
    return this;
  }
  /**
   * This method will cause the actor to repeat all of the actions built in
   * the `repeatBuilder` callback. If the number of repeats
   * is not specified it will repeat forever. This method is part of
   * the actor 'Action' fluent API allowing action chaining
   *
   * ```typescript
   * // Move up in a zig-zag by repeated moveBy's
   * actor.actions.repeat(repeatCtx => {
   * repeatCtx.moveBy(10, 0, 10);
   * repeatCtx.moveBy(0, 10, 10);
   * }, 5);
   * ```
   * @param repeatBuilder The builder to specify the repeatable list of actions
   */
  repeatForever(repeatBuilder) {
    this._queue.add(new RepeatForever(this._entity, repeatBuilder));
    return this;
  }
  /**
   * This method will cause the entity to follow another at a specified distance
   * @param entity           The entity to follow
   * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
   */
  follow(entity, followDistance) {
    if (followDistance === void 0) {
      this._queue.add(new Follow(this._entity, entity));
    } else {
      this._queue.add(new Follow(this._entity, entity, followDistance));
    }
    return this;
  }
  /**
   * This method will cause the entity to move towards another until they
   * collide "meet" at a specified speed.
   * @param entity  The entity to meet
   * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
   * @param tolerance  The tolerance in pixels to meet, if not specified it will be 1 pixel
   */
  meet(entity, speed, tolerance) {
    if (speed === void 0 && tolerance === void 0) {
      this._queue.add(new Meet(this._entity, entity));
    } else if (tolerance === void 0) {
      this._queue.add(new Meet(this._entity, entity, speed));
    } else {
      this._queue.add(new Meet(this._entity, entity, speed, tolerance));
    }
    return this;
  }
  /**
   * Returns a promise that resolves when the current action queue up to now
   * is finished.
   */
  toPromise() {
    const temp = new Promise((resolve) => {
      this._queue.add(
        new CallMethod(() => {
          resolve();
        })
      );
    });
    return temp;
  }
}
class ActionsComponent extends Component {
  constructor() {
    super(...arguments);
    this.dependencies = [TransformComponent, MotionComponent];
    this._ctx = null;
  }
  onAdd(entity) {
    this._ctx = new ActionContext(entity);
  }
  onRemove() {
    this._ctx = null;
  }
  _getCtx() {
    if (!this._ctx) {
      throw new Error("Actions component not attached to an entity, no context available");
    }
    return this._ctx;
  }
  /**
   * Returns the internal action queue
   * @returns action queue
   */
  getQueue() {
    if (!this._ctx) {
      throw new Error("Actions component not attached to an entity, no queue available");
    }
    return this._ctx.getQueue();
  }
  /**
   * Runs a specific action in the action queue
   * @param action
   */
  runAction(action) {
    if (!this._ctx) {
      throw new Error("Actions component not attached to an entity, cannot run action");
    }
    return this._ctx.runAction(action);
  }
  /**
   * Updates the internal action context, performing action and moving through the internal queue
   * @param elapsed
   */
  update(elapsed) {
    var _a;
    return (_a = this._ctx) == null ? void 0 : _a.update(elapsed);
  }
  /**
   * Clears all queued actions from the Actor
   */
  clearActions() {
    var _a;
    (_a = this._ctx) == null ? void 0 : _a.clearActions();
  }
  /**
   * Animates an actor with a specified bezier curve by an offset to the current position, the start point is assumed
   * to be the actors current position
   * @param options
   */
  curveBy(options) {
    return this._getCtx().curveBy.apply(this._ctx, [options]);
  }
  /**
   * Animates an actor with a specified bezier curve to an absolute world space coordinate, the start point is assumed
   * to be the actors current position
   * @param options
   */
  curveTo(options) {
    return this._getCtx().curveTo.apply(this._ctx, [options]);
  }
  easeTo(...args) {
    return this._getCtx().easeTo.apply(this._ctx, args);
  }
  easeBy(...args) {
    return this._getCtx().easeBy.apply(this._ctx, args);
  }
  moveTo(xOrPosOrOptions, yOrSpeed, speedOrUndefined) {
    return this._getCtx().moveTo.apply(this._ctx, [xOrPosOrOptions, yOrSpeed, speedOrUndefined]);
  }
  moveBy(xOffsetOrVectorOptions, yOffsetOrSpeed, speedOrUndefined) {
    return this._getCtx().moveBy.apply(this._ctx, [xOffsetOrVectorOptions, yOffsetOrSpeed, speedOrUndefined]);
  }
  rotateTo(angle, speed, rotationType) {
    return this._getCtx().rotateTo.apply(this._ctx, [angle, speed, rotationType]);
  }
  rotateBy(angleRadiansOffsetOrOptions, speed, rotationType) {
    return this._getCtx().rotateBy.apply(this._ctx, [angleRadiansOffsetOrOptions, speed, rotationType]);
  }
  scaleTo(sizeXOrVectorOrOptions, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
    return this._getCtx().scaleTo.apply(this._ctx, [sizeXOrVectorOrOptions, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined]);
  }
  scaleBy(sizeOffsetXOrVectorOrOptions, sizeOffsetYOrSpeed, speed) {
    return this._getCtx().scaleBy.apply(this._ctx, [sizeOffsetXOrVectorOrOptions, sizeOffsetYOrSpeed, speed]);
  }
  /**
   * This method will cause an actor to blink (become visible and not
   * visible). Optionally, you may specify the number of blinks. Specify the amount of time
   * the actor should be visible per blink, and the amount of time not visible.
   * This method is part of the actor 'Action' fluent API allowing action chaining.
   * @param timeVisible     The amount of time to stay visible per blink in milliseconds
   * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
   * @param numBlinks       The number of times to blink
   */
  blink(timeVisible, timeNotVisible, numBlinks) {
    return this._getCtx().blink(timeVisible, timeNotVisible, numBlinks);
  }
  /**
   * This method will cause an actor's opacity to change from its current value
   * to the provided value by a specified time (in milliseconds). This method is
   * part of the actor 'Action' fluent API allowing action chaining.
   * @param opacity  The ending opacity
   * @param duration     The time it should take to fade the actor (in milliseconds)
   */
  fade(opacity, duration) {
    return this._getCtx().fade(opacity, duration);
  }
  /**
   * This will cause an actor to flash a specific color for a period of time
   * @param color
   * @param duration The duration in milliseconds
   */
  flash(color, duration = 1e3) {
    return this._getCtx().flash(color, duration);
  }
  /**
   * This method will delay the next action from executing for a certain
   * amount of time (in milliseconds). This method is part of the actor
   * 'Action' fluent API allowing action chaining.
   * @param duration  The amount of time to delay the next action in the queue from executing in milliseconds
   */
  delay(duration) {
    return this._getCtx().delay(duration);
  }
  /**
   * This method will add an action to the queue that will remove the actor from the
   * scene once it has completed its previous  Any actions on the
   * action queue after this action will not be executed.
   */
  die() {
    return this._getCtx().die();
  }
  /**
   * This method allows you to call an arbitrary method as the next action in the
   * action queue. This is useful if you want to execute code in after a specific
   * action, i.e An actor arrives at a destination after traversing a path
   */
  callMethod(method) {
    return this._getCtx().callMethod(method);
  }
  /**
   * This method will cause the actor to repeat all of the actions built in
   * the `repeatBuilder` callback. If the number of repeats
   * is not specified it will repeat forever. This method is part of
   * the actor 'Action' fluent API allowing action chaining
   *
   * ```typescript
   * // Move up in a zig-zag by repeated moveBy's
   * actor.actions.repeat(repeatCtx => {
   * repeatCtx.moveBy(10, 0, 10);
   * repeatCtx.moveBy(0, 10, 10);
   * }, 5);
   * ```
   * @param repeatBuilder The builder to specify the repeatable list of actions
   * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
   * will repeat forever
   */
  repeat(repeatBuilder, times) {
    return this._getCtx().repeat(repeatBuilder, times);
  }
  /**
   * This method will cause the actor to repeat all of the actions built in
   * the `repeatBuilder` callback. If the number of repeats
   * is not specified it will repeat forever. This method is part of
   * the actor 'Action' fluent API allowing action chaining
   *
   * ```typescript
   * // Move up in a zig-zag by repeated moveBy's
   * actor.actions.repeat(repeatCtx => {
   * repeatCtx.moveBy(10, 0, 10);
   * repeatCtx.moveBy(0, 10, 10);
   * }, 5);
   * ```
   * @param repeatBuilder The builder to specify the repeatable list of actions
   */
  repeatForever(repeatBuilder) {
    return this._getCtx().repeatForever(repeatBuilder);
  }
  /**
   * This method will cause the entity to follow another at a specified distance
   * @param entity           The entity to follow
   * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
   */
  follow(entity, followDistance) {
    return this._getCtx().follow(entity, followDistance);
  }
  /**
   * This method will cause the entity to move towards another until they
   * collide "meet" at a specified speed.
   * @param entity  The entity to meet
   * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
   */
  meet(entity, speed) {
    return this._getCtx().meet(entity, speed);
  }
  /**
   * Returns a promise that resolves when the current action queue up to now
   * is finished.
   */
  toPromise() {
    return this._getCtx().toPromise();
  }
}
function isActor(x) {
  return x instanceof Actor;
}
const ActorEvents = {
  CollisionStart: "collisionstart",
  CollisionEnd: "collisionend",
  PreCollision: "precollision",
  PostCollision: "postcollision",
  Kill: "kill",
  PreKill: "prekill",
  PostKill: "postkill",
  PreDraw: "predraw",
  PostDraw: "postdraw",
  PreTransformDraw: "pretransformdraw",
  PostTransformDraw: "posttransformdraw",
  PreDebugDraw: "predebugdraw",
  PostDebugDraw: "postdebugdraw",
  PointerUp: "pointerup",
  PointerDown: "pointerdown",
  PointerEnter: "pointerenter",
  PointerLeave: "pointerleave",
  PointerMove: "pointermove",
  PointerCancel: "pointercancel",
  Wheel: "pointerwheel",
  PointerDrag: "pointerdragstart",
  PointerDragEnd: "pointerdragend",
  PointerDragEnter: "pointerdragenter",
  PointerDragLeave: "pointerdragleave",
  PointerDragMove: "pointerdragmove",
  EnterViewPort: "enterviewport",
  ExitViewPort: "exitviewport",
  ActionStart: "actionstart",
  ActionComplete: "actioncomplete"
};
const _Actor = class _Actor2 extends Entity {
  // #endregion
  /**
   *
   * @param config
   */
  constructor(config) {
    super();
    this.events = new EventEmitter();
    this._anchor = watch(Vector.Half, (v) => this._handleAnchorChange(v));
    this._offset = watch(Vector.Zero, (v) => this._handleOffsetChange(v));
    this.logger = Logger.getInstance();
    this._draggable = false;
    this._dragging = false;
    this._pointerDragStartHandler = () => {
      this._dragging = true;
    };
    this._pointerDragEndHandler = () => {
      this._dragging = false;
    };
    this._pointerDragMoveHandler = (pe) => {
      if (this._dragging) {
        this.pos = pe.worldPos;
      }
    };
    this._pointerDragLeaveHandler = (pe) => {
      if (this._dragging) {
        this.pos = pe.worldPos;
      }
    };
    const {
      name,
      x,
      y,
      pos,
      coordPlane,
      scale,
      width,
      height,
      radius,
      collider,
      vel,
      acc,
      rotation,
      angularVelocity,
      z,
      color,
      visible,
      opacity,
      anchor,
      offset,
      collisionType,
      collisionGroup
    } = {
      ...config
    };
    this.name = name != null ? name : this.name;
    this.anchor = anchor != null ? anchor : _Actor2.defaults.anchor.clone();
    this.offset = offset != null ? offset : Vector.Zero;
    this.transform = new TransformComponent();
    this.addComponent(this.transform);
    this.pos = pos != null ? pos : vec(x != null ? x : 0, y != null ? y : 0);
    this.rotation = rotation != null ? rotation : 0;
    this.scale = scale != null ? scale : vec(1, 1);
    this.z = z != null ? z : 0;
    this.transform.coordPlane = coordPlane != null ? coordPlane : CoordPlane.World;
    this.pointer = new PointerComponent();
    this.addComponent(this.pointer);
    this.graphics = new GraphicsComponent({
      anchor: this.anchor,
      offset: this.offset,
      opacity
    });
    this.addComponent(this.graphics);
    this.motion = new MotionComponent();
    this.addComponent(this.motion);
    this.vel = vel != null ? vel : Vector.Zero;
    this.acc = acc != null ? acc : Vector.Zero;
    this.angularVelocity = angularVelocity != null ? angularVelocity : 0;
    this.actions = new ActionsComponent();
    this.addComponent(this.actions);
    this.body = new BodyComponent();
    this.addComponent(this.body);
    this.body.collisionType = collisionType != null ? collisionType : CollisionType.Passive;
    if (collisionGroup) {
      this.body.group = collisionGroup;
    }
    if (color) {
      this.color = color;
    }
    if (collider) {
      this.collider = new ColliderComponent(collider);
      this.addComponent(this.collider);
    } else if (radius) {
      this.collider = new ColliderComponent(Shape.Circle(radius));
      this.addComponent(this.collider);
      if (color) {
        this.graphics.add(
          new Circle({
            color,
            radius
          })
        );
      }
    } else {
      if (width > 0 && height > 0) {
        this.collider = new ColliderComponent(Shape.Box(width, height, this.anchor));
        this.addComponent(this.collider);
        if (color && width && height) {
          this.graphics.add(
            new Rectangle({
              color,
              width,
              height
            })
          );
        }
      } else {
        this.collider = new ColliderComponent();
        this.addComponent(this.collider);
      }
    }
    this.graphics.isVisible = visible != null ? visible : true;
  }
  /**
   * Gets the position vector of the actor in pixels
   */
  get pos() {
    return this.transform.pos;
  }
  /**
   * Sets the position vector of the actor in pixels
   */
  set pos(thePos) {
    this.transform.pos = thePos.clone();
  }
  /**
   * Gets the position vector of the actor from the last frame
   */
  get oldPos() {
    return this.body.oldPos;
  }
  /**
   * Gets the global position vector of the actor from the last frame
   */
  get oldGlobalPos() {
    return this.body.oldGlobalPos;
  }
  /**
   * Sets the position vector of the actor in the last frame
   */
  set oldPos(thePos) {
    this.body.oldPos.setTo(thePos.x, thePos.y);
  }
  /**
   * Gets the velocity vector of the actor in pixels/sec
   */
  get vel() {
    return this.motion.vel;
  }
  /**
   * Sets the velocity vector of the actor in pixels/sec
   */
  set vel(theVel) {
    this.motion.vel = theVel.clone();
  }
  /**
   * Gets the velocity vector of the actor from the last frame
   */
  get oldVel() {
    return this.body.oldVel;
  }
  /**
   * Sets the velocity vector of the actor from the last frame
   */
  set oldVel(theVel) {
    this.body.oldVel.setTo(theVel.x, theVel.y);
  }
  /**
   * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be
   * useful to simulate a gravitational effect.
   */
  get acc() {
    return this.motion.acc;
  }
  /**
   * Sets the acceleration vector of teh actor in pixels/second/second
   */
  set acc(theAcc) {
    this.motion.acc = theAcc.clone();
  }
  /**
   * Sets the acceleration of the actor from the last frame. This does not include the global acc {@apilink Physics.acc}.
   */
  set oldAcc(theAcc) {
    this.body.oldAcc.setTo(theAcc.x, theAcc.y);
  }
  /**
   * Gets the acceleration of the actor from the last frame. This does not include the global acc {@apilink Physics.acc}.
   */
  get oldAcc() {
    return this.body.oldAcc;
  }
  /**
   * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
   */
  get rotation() {
    return this.transform.rotation;
  }
  /**
   * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
   */
  set rotation(theAngle) {
    this.transform.rotation = theAngle;
  }
  /**
   * Gets the rotational velocity of the actor in radians/second
   */
  get angularVelocity() {
    return this.motion.angularVelocity;
  }
  /**
   * Sets the rotational velocity of the actor in radians/sec
   */
  set angularVelocity(angularVelocity) {
    this.motion.angularVelocity = angularVelocity;
  }
  get scale() {
    return this.get(TransformComponent).scale;
  }
  set scale(scale) {
    this.get(TransformComponent).scale = scale;
  }
  /**
   * The anchor to apply all actor related transformations like rotation,
   * translation, and scaling. By default the anchor is in the center of
   * the actor. By default it is set to the center of the actor (.5, .5)
   *
   * An anchor of (.5, .5) will ensure that drawings are centered.
   *
   * Use `anchor.setTo` to set the anchor to a different point using
   * values between 0 and 1. For example, anchoring to the top-left would be
   * `Actor.anchor.setTo(0, 0)` and top-right would be `Actor.anchor.setTo(0, 1)`.
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(vec2) {
    this._anchor = watch(vec2, (v) => this._handleAnchorChange(v));
    this._handleAnchorChange(vec2);
  }
  _handleAnchorChange(v) {
    if (this.graphics) {
      this.graphics.anchor = v;
    }
  }
  /**
   * The offset in pixels to apply to all actor graphics
   *
   * Default offset of (0, 0)
   */
  get offset() {
    return this._offset;
  }
  set offset(vec2) {
    this._offset = watch(vec2, (v) => this._handleOffsetChange(v));
    this._handleOffsetChange(vec2);
  }
  _handleOffsetChange(v) {
    if (this.graphics) {
      this.graphics.offset = v;
    }
  }
  /**
   * Indicates whether the actor is physically in the viewport
   */
  get isOffScreen() {
    return this.hasTag("ex.offscreen");
  }
  get draggable() {
    return this._draggable;
  }
  set draggable(isDraggable) {
    if (isDraggable) {
      if (isDraggable && !this._draggable) {
        this.events.on("pointerdragstart", this._pointerDragStartHandler);
        this.events.on("pointerdragend", this._pointerDragEndHandler);
        this.events.on("pointerdragmove", this._pointerDragMoveHandler);
        this.events.on("pointerdragleave", this._pointerDragLeaveHandler);
      } else if (!isDraggable && this._draggable) {
        this.events.off("pointerdragstart", this._pointerDragStartHandler);
        this.events.off("pointerdragend", this._pointerDragEndHandler);
        this.events.off("pointerdragmove", this._pointerDragMoveHandler);
        this.events.off("pointerdragleave", this._pointerDragLeaveHandler);
      }
      this._draggable = isDraggable;
    }
  }
  /**
   * Sets the color of the actor's current graphic
   */
  get color() {
    return this.graphics.color;
  }
  set color(v) {
    this.graphics.color = v;
  }
  clone() {
    const clone = new _Actor2({
      color: this.color.clone(),
      anchor: this.anchor.clone(),
      offset: this.offset.clone()
    });
    clone.clearComponents();
    clone.processComponentRemoval();
    clone.addComponent(clone.transform = this.transform.clone(), true);
    clone.addComponent(clone.pointer = this.pointer.clone(), true);
    clone.addComponent(clone.graphics = this.graphics.clone(), true);
    clone.addComponent(clone.motion = this.motion.clone(), true);
    clone.addComponent(clone.actions = this.actions.clone(), true);
    clone.addComponent(clone.body = this.body.clone(), true);
    if (this.collider.get()) {
      clone.addComponent(clone.collider = this.collider.clone(), true);
    }
    const builtInComponents = [
      this.transform,
      this.pointer,
      this.graphics,
      this.motion,
      this.actions,
      this.body,
      this.collider
    ];
    const components = this.getComponents();
    for (const c of components) {
      if (!builtInComponents.includes(c)) {
        clone.addComponent(c.clone(), true);
      }
    }
    return clone;
  }
  /**
   * `onInitialize` is called before the first update of the actor. This method is meant to be
   * overridden. This is where initialization of child actors should take place.
   *
   * Synonymous with the event handler `.on('initialize', (evt) => {...})`
   */
  onInitialize(engine) {
  }
  /**
   * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.
   *
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   * @internal
   */
  _initialize(engine) {
    super._initialize(engine);
    for (const child of this.children) {
      child._initialize(engine);
    }
  }
  emit(eventName, event) {
    this.events.emit(eventName, event);
  }
  on(eventName, handler) {
    return this.events.on(eventName, handler);
  }
  once(eventName, handler) {
    return this.events.once(eventName, handler);
  }
  off(eventName, handler) {
    this.events.off(eventName, handler);
  }
  // #endregion
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _prekill handler for {@apilink onPreKill} lifecycle event
   * @internal
   */
  _prekill(scene) {
    this.events.emit("prekill", new PreKillEvent(this));
    this.onPreKill(scene);
  }
  /**
   * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`
   *
   * `onPreKill` is called directly before an actor is killed and removed from its current {@apilink Scene}.
   */
  onPreKill(scene) {
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _prekill handler for {@apilink onPostKill} lifecycle event
   * @internal
   */
  _postkill(scene) {
    this.events.emit("postkill", new PostKillEvent(this));
    this.onPostKill(scene);
  }
  /**
   * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`
   *
   * `onPostKill` is called directly after an actor is killed and remove from its current {@apilink Scene}.
   */
  onPostKill(scene) {
  }
  /**
   * If the current actor is a member of the scene, this will remove
   * it from the scene graph. It will no longer be drawn or updated.
   */
  kill() {
    if (this.scene) {
      this._prekill(this.scene);
      this.events.emit("kill", new KillEvent(this));
      super.kill();
      this._postkill(this.scene);
    } else {
      {
        this.logger.warn(`Cannot kill actor named "${this.name}", it was never added to the Scene`);
      }
    }
  }
  /**
   * If the current actor is killed, it will now not be killed.
   */
  unkill() {
    this.isActive = true;
  }
  /**
   * Indicates wether the actor has been killed.
   */
  isKilled() {
    return !this.isActive;
  }
  /**
   * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.
   * Actors with a higher z-index are drawn on top of actors with a lower z-index
   */
  get z() {
    return this.get(TransformComponent).z;
  }
  /**
   * Sets the z-index of an actor and updates it in the drawing list for the scene.
   * The z-index determines the relative order an actor is drawn in.
   * Actors with a higher z-index are drawn on top of actors with a lower z-index
   * @param newZ new z-index to assign
   */
  set z(newZ) {
    this.get(TransformComponent).z = newZ;
  }
  /**
   * Get the center point of an actor (global position)
   */
  get center() {
    const globalPos = this.getGlobalPos();
    return new Vector(
      globalPos.x + this.width / 2 - this.anchor.x * this.width,
      globalPos.y + this.height / 2 - this.anchor.y * this.height
    );
  }
  /**
   * Get the local center point of an actor
   */
  get localCenter() {
    return new Vector(this.pos.x + this.width / 2 - this.anchor.x * this.width, this.pos.y + this.height / 2 - this.anchor.y * this.height);
  }
  get width() {
    return this.collider.localBounds.width * this.getGlobalScale().x;
  }
  get height() {
    return this.collider.localBounds.height * this.getGlobalScale().y;
  }
  /**
   * Gets this actor's rotation taking into account any parent relationships
   * @returns Rotation angle in radians
   * @deprecated Use {@apilink globalRotation} instead
   */
  getGlobalRotation() {
    return this.get(TransformComponent).globalRotation;
  }
  /**
   * The actor's rotation (in radians) taking into account any parent relationships
   */
  get globalRotation() {
    return this.get(TransformComponent).globalRotation;
  }
  /**
   * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation
   * @returns Position in world coordinates
   * @deprecated Use {@apilink globalPos} instead
   */
  getGlobalPos() {
    return this.get(TransformComponent).globalPos;
  }
  /**
   * The actor's world position taking into account parent relationships, scaling, rotation, and translation
   */
  get globalPos() {
    return this.get(TransformComponent).globalPos;
  }
  /**
   * Gets the global scale of the Actor
   * @deprecated Use {@apilink globalScale} instead
   */
  getGlobalScale() {
    return this.get(TransformComponent).globalScale;
  }
  /**
   * The global scale of the Actor
   */
  get globalScale() {
    return this.get(TransformComponent).globalScale;
  }
  /**
   * The global z-index of the actor
   */
  get globalZ() {
    return this.get(TransformComponent).globalZ;
  }
  // #region Collision
  /**
   * Tests whether the x/y specified are contained in the actor
   * @param x  X coordinate to test (in world coordinates)
   * @param y  Y coordinate to test (in world coordinates)
   * @param recurse checks whether the x/y are contained in any child actors (if they exist).
   */
  contains(x, y, recurse = false) {
    const point2 = vec(x, y);
    const collider = this.get(ColliderComponent);
    collider.update();
    const geom = collider.get();
    if (!geom) {
      return false;
    }
    const containment = geom.contains(point2);
    if (recurse) {
      return containment || this.children.some((child) => {
        return child.contains(x, y, true);
      });
    }
    return containment;
  }
  /**
   * Returns true if the two actor.collider's surfaces are less than or equal to the distance specified from each other
   * @param actor     Actor to test
   * @param distance  Distance in pixels to test
   */
  within(actor, distance) {
    const collider = this.get(ColliderComponent);
    const otherCollider = actor.get(ColliderComponent);
    const me = collider.get();
    const other = otherCollider.get();
    if (me && other) {
      return me.getClosestLineBetween(other).getLength() <= distance;
    }
    return false;
  }
  // #endregion
  // #region Update
  /**
   * Called by the Engine, updates the state of the actor
   * @internal
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   */
  update(engine, elapsed) {
    this._initialize(engine);
    this._add(engine);
    this._preupdate(engine, elapsed);
    this._postupdate(engine, elapsed);
    this._remove(engine);
  }
  /**
   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPreUpdate` is called directly before an actor is updated.
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   */
  onPreUpdate(engine, elapsed) {
  }
  /**
   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
   *
   * `onPostUpdate` is called directly after an actor is updated.
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   */
  onPostUpdate(engine, elapsed) {
  }
  /**
   * Fires before every collision resolution for a confirmed contact
   * @param self
   * @param other
   * @param side
   * @param contact
   */
  onPreCollisionResolve(self, other, side, contact) {
  }
  /**
   * Fires after every resolution for a confirmed contact.
   * @param self
   * @param other
   * @param side
   * @param contact
   */
  onPostCollisionResolve(self, other, side, contact) {
  }
  /**
   * Fires once when 2 entities with a ColliderComponent first start colliding or touching, if the Colliders stay in contact this
   * does not continue firing until they separate and re-collide.
   * @param self
   * @param other
   * @param side
   * @param contact
   */
  onCollisionStart(self, other, side, contact) {
  }
  /**
   * Fires once when 2 entities with a ColliderComponent separate after having been in contact.
   * @param self
   * @param other
   * @param side
   * @param lastContact
   */
  onCollisionEnd(self, other, side, lastContact) {
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPreUpdate} lifecycle event
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   * @internal
   */
  _preupdate(engine, elapsed) {
    this.events.emit("preupdate", new PreUpdateEvent(engine, elapsed, this));
    this.onPreUpdate(engine, elapsed);
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPostUpdate} lifecycle event
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   * @internal
   */
  _postupdate(engine, elapsed) {
    this.events.emit("postupdate", new PostUpdateEvent(engine, elapsed, this));
    this.onPostUpdate(engine, elapsed);
  }
  // endregion
};
_Actor.defaults = {
  anchor: Vector.Half
};
let Actor = _Actor;
class ColliderComponent extends Component {
  constructor(collider) {
    super();
    this.events = new EventEmitter();
    this.$colliderAdded = new Observable();
    this.$colliderRemoved = new Observable();
    this._collidersToRemove = [];
    this.set(collider);
  }
  /**
   * Get the current collider geometry
   */
  get() {
    return this._collider;
  }
  /**
   * Set the collider geometry
   * @param collider
   * @returns the collider you set
   */
  set(collider) {
    this.clear();
    if (collider) {
      this._collider = collider;
      this._collider.owner = this.owner;
      collider.events.pipe(this.events);
      this.$colliderAdded.notifyAll(collider);
      this.update();
    }
    return collider;
  }
  /**
   * Remove collider geometry from collider component
   */
  clear() {
    if (this._collider) {
      this._collidersToRemove.push(this._collider);
      this._collider = null;
    }
  }
  processColliderRemoval() {
    for (const collider of this._collidersToRemove) {
      collider.events.unpipe(this.events);
      this.$colliderRemoved.notifyAll(collider);
      collider.owner = null;
    }
  }
  clone() {
    const clone = new ColliderComponent(this._collider.clone());
    return clone;
  }
  /**
   * Return world space bounds
   */
  get bounds() {
    var _a, _b;
    return (_b = (_a = this._collider) == null ? void 0 : _a.bounds) != null ? _b : new BoundingBox();
  }
  /**
   * Return local space bounds
   */
  get localBounds() {
    var _a, _b;
    return (_b = (_a = this._collider) == null ? void 0 : _a.localBounds) != null ? _b : new BoundingBox();
  }
  /**
   * Update the collider's transformed geometry
   */
  update() {
    var _a;
    const tx = (_a = this.owner) == null ? void 0 : _a.get(TransformComponent);
    if (this._collider) {
      this._collider.owner = this.owner;
      if (tx) {
        this._collider.update(tx.get());
      }
    }
  }
  /**
   * Collide component with another
   * @param other
   */
  collide(other) {
    let colliderA = this._collider;
    let colliderB = other._collider;
    if (!colliderA || !colliderB) {
      return [];
    }
    let flipped = false;
    if (colliderB instanceof CompositeCollider) {
      colliderA = colliderB;
      colliderB = this._collider;
      flipped = true;
    }
    if (this._collider) {
      const contacts = colliderA.collide(colliderB);
      if (contacts) {
        if (flipped) {
          contacts.forEach((contact) => {
            contact.mtv = contact.mtv.negate();
            contact.normal = contact.normal.negate();
            contact.tangent = contact.normal.perpendicular();
            contact.colliderA = this._collider;
            contact.colliderB = other._collider;
          });
        }
        return contacts;
      }
      return [];
    }
    return [];
  }
  onAdd(entity) {
    if (this._collider) {
      this.update();
    }
    this.events.on("precollision", (evt) => {
      const precollision = evt;
      entity.events.emit(
        "precollision",
        new PreCollisionEvent(precollision.self, precollision.other, precollision.side, precollision.intersection, precollision.contact)
      );
      if (entity instanceof Actor) {
        entity.onPreCollisionResolve(precollision.self, precollision.other, precollision.side, precollision.contact);
      }
    });
    this.events.on("postcollision", (evt) => {
      const postcollision = evt;
      entity.events.emit(
        "postcollision",
        new PostCollisionEvent(
          postcollision.self,
          postcollision.other,
          postcollision.side,
          postcollision.intersection,
          postcollision.contact
        )
      );
      if (entity instanceof Actor) {
        entity.onPostCollisionResolve(postcollision.self, postcollision.other, postcollision.side, postcollision.contact);
      }
    });
    this.events.on("collisionstart", (evt) => {
      const start = evt;
      entity.events.emit("collisionstart", new CollisionStartEvent(start.self, start.other, start.side, start.contact));
      if (entity instanceof Actor) {
        entity.onCollisionStart(start.self, start.other, start.side, start.contact);
      }
    });
    this.events.on("collisionend", (evt) => {
      const end = evt;
      entity.events.emit("collisionend", new CollisionEndEvent(end.self, end.other, end.side, end.lastContact));
      if (entity instanceof Actor) {
        entity.onCollisionEnd(end.self, end.other, end.side, end.lastContact);
      }
    });
  }
  onRemove() {
    this.events.clear();
    this.$colliderRemoved.notifyAll(this._collider);
  }
  /**
   * Sets up a box geometry based on the current bounds of the associated actor of this physics body.
   *
   * If no width/height are specified the body will attempt to use the associated actor's width/height.
   *
   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
   */
  useBoxCollider(width, height, anchor = Vector.Half, center = Vector.Zero) {
    const collider = Shape.Box(width, height, anchor, center);
    return this.set(collider);
  }
  /**
   * Sets up a {@apilink PolygonCollider | `polygon`} collision geometry based on a list of of points relative
   *  to the anchor of the associated actor
   * of this physics body.
   *
   * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.
   *
   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
   */
  usePolygonCollider(points, center = Vector.Zero) {
    const poly = Shape.Polygon(points, center);
    return this.set(poly);
  }
  /**
   * Sets up a {@apilink Circle | `circle collision geometry`} as the only collider with a specified radius in pixels.
   *
   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
   */
  useCircleCollider(radius, center = Vector.Zero) {
    const collider = Shape.Circle(radius, center);
    return this.set(collider);
  }
  /**
   * Sets up an {@apilink Edge | `edge collision geometry`} with a start point and an end point relative to the anchor of the associated actor
   * of this physics body.
   *
   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
   */
  useEdgeCollider(begin, end) {
    const collider = Shape.Edge(begin, end);
    return this.set(collider);
  }
  /**
   * Setups up a {@apilink CompositeCollider} which can define any arbitrary set of excalibur colliders
   * @param colliders
   */
  useCompositeCollider(colliders) {
    return this.set(new CompositeCollider(colliders));
  }
}
var DegreeOfFreedom = /* @__PURE__ */ ((DegreeOfFreedom2) => {
  DegreeOfFreedom2["Rotation"] = "rotation";
  DegreeOfFreedom2["X"] = "x";
  DegreeOfFreedom2["Y"] = "y";
  return DegreeOfFreedom2;
})(DegreeOfFreedom || {});
const _BodyComponent = class _BodyComponent2 extends Component {
  constructor(options) {
    var _a, _b, _c;
    super();
    this.dependencies = [TransformComponent, MotionComponent];
    this.id = createId("body", _BodyComponent2._ID++);
    this.events = new EventEmitter();
    this.oldTransform = new Transform();
    this.__oldTransformCaptured = false;
    this.enableFixedUpdateInterpolate = true;
    this.collisionType = CollisionType.PreventCollision;
    this.group = CollisionGroup.All;
    this._sleeping = false;
    this.bounciness = 0.2;
    this.friction = 0.99;
    this.useGravity = true;
    this.limitDegreeOfFreedom = [];
    this._oldGlobalPos = Vector.Zero;
    this.oldVel = new Vector(0, 0);
    this.oldAcc = Vector.Zero;
    this._impulseScratch = vec(0, 0);
    this._distanceFromCenterScratch = vec(0, 0);
    if (options) {
      this.collisionType = (_a = options.type) != null ? _a : this.collisionType;
      this.group = (_b = options.group) != null ? _b : this.group;
      this.useGravity = (_c = options.useGravity) != null ? _c : this.useGravity;
      this._bodyConfig = {
        ...getDefaultPhysicsConfig().bodies,
        ...options.config
      };
    } else {
      this._bodyConfig = {
        ...getDefaultPhysicsConfig().bodies
      };
    }
    this.updatePhysicsConfig(this._bodyConfig);
    this._mass = _BodyComponent2._DEFAULT_CONFIG.defaultMass;
  }
  get matrix() {
    return this.transform.get().matrix;
  }
  /**
   * Called by excalibur to update physics config defaults if they change
   * @param config
   */
  updatePhysicsConfig(config) {
    this._bodyConfig = {
      ...getDefaultPhysicsConfig().bodies,
      ...config
    };
    this.canSleep = this._bodyConfig.canSleepByDefault;
    this.sleepMotion = this._bodyConfig.sleepEpsilon * 5;
    this.wakeThreshold = this._bodyConfig.wakeThreshold;
  }
  /**
   * Called by excalibur to update defaults
   * @param config
   */
  static updateDefaultPhysicsConfig(config) {
    _BodyComponent2._DEFAULT_CONFIG = config;
  }
  get mass() {
    return this._mass;
  }
  set mass(newMass) {
    this._mass = newMass;
    this._cachedInertia = void 0;
    this._cachedInverseInertia = void 0;
  }
  /**
   * The inverse mass (1/mass) of the body. If {@apilink CollisionType.Fixed} this is 0, meaning "infinite" mass
   */
  get inverseMass() {
    return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.mass;
  }
  /**
   * Whether this body is sleeping or not
   * @deprecated use isSleeping
   */
  get sleeping() {
    return this.isSleeping;
  }
  /**
   * Whether this body is sleeping or not
   */
  get isSleeping() {
    return this._sleeping;
  }
  /**
   * Set the sleep state of the body
   * @param sleeping
   * @deprecated use isSleeping
   */
  setSleeping(sleeping) {
    this.isSleeping = sleeping;
  }
  set isSleeping(sleeping) {
    this._sleeping = sleeping;
    if (!sleeping) {
      this.sleepMotion = this._bodyConfig.sleepEpsilon * 5;
    } else {
      this.vel = Vector.Zero;
      this.acc = Vector.Zero;
      this.angularVelocity = 0;
      this.sleepMotion = 0;
    }
  }
  /**
   * Update body's {@apilink BodyComponent.sleepMotion} for the purpose of sleeping
   */
  updateMotion() {
    if (this._sleeping) {
      this.isSleeping = true;
    }
    const currentMotion = this.vel.magnitude * this.vel.magnitude + Math.abs(this.angularVelocity * this.angularVelocity);
    const bias = this._bodyConfig.sleepBias;
    this.sleepMotion = bias * this.sleepMotion + (1 - bias) * currentMotion;
    this.sleepMotion = clamp(this.sleepMotion, 0, 10 * this._bodyConfig.sleepEpsilon);
    if (this.canSleep && this.sleepMotion < this._bodyConfig.sleepEpsilon) {
      this.isSleeping = true;
    }
  }
  /**
   * Get the moment of inertia from the {@apilink ColliderComponent}
   */
  get inertia() {
    if (this._cachedInertia) {
      return this._cachedInertia;
    }
    const collider = this.owner.get(ColliderComponent);
    if (collider) {
      collider.$colliderAdded.subscribe(() => {
        this._cachedInertia = null;
      });
      collider.$colliderRemoved.subscribe(() => {
        this._cachedInertia = null;
      });
      const maybeCollider = collider.get();
      if (maybeCollider) {
        return this._cachedInertia = maybeCollider.getInertia(this.mass);
      }
    }
    return 0;
  }
  /**
   * Get the inverse moment of inertial from the {@apilink ColliderComponent}. If {@apilink CollisionType.Fixed} this is 0, meaning "infinite" mass
   */
  get inverseInertia() {
    if (this._cachedInverseInertia) {
      return this._cachedInverseInertia;
    }
    return this._cachedInverseInertia = this.collisionType === CollisionType.Fixed ? 0 : 1 / this.inertia;
  }
  /**
   * Returns if the owner is active
   * @deprecated use isActive
   */
  get active() {
    var _a;
    return !!((_a = this.owner) == null ? void 0 : _a.isActive);
  }
  /**
   * Returns if the owner is active
   */
  get isActive() {
    var _a;
    return !!((_a = this.owner) == null ? void 0 : _a.isActive);
  }
  /**
   * @deprecated Use globalPos
   */
  get center() {
    return this.globalPos;
  }
  onAdd(owner) {
    var _a, _b;
    this.transform = (_a = this.owner) == null ? void 0 : _a.get(TransformComponent);
    this.motion = (_b = this.owner) == null ? void 0 : _b.get(MotionComponent);
  }
  get pos() {
    return this.transform.pos;
  }
  set pos(val) {
    this.transform.pos = val;
  }
  /**
   * The (x, y) position of the actor this will be in the middle of the actor if the
   * {@apilink Actor.anchor} is set to (0.5, 0.5) which is default.
   * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).
   */
  get globalPos() {
    return this.transform.globalPos;
  }
  set globalPos(val) {
    this.transform.globalPos = val;
  }
  /**
   * The position of the actor last frame (x, y) in pixels
   */
  get oldPos() {
    return this.oldTransform.pos;
  }
  /**
   * The global position of the actor last frame (x, y) in pixels
   */
  get oldGlobalPos() {
    return this._oldGlobalPos;
  }
  /**
   * The current velocity vector (vx, vy) of the actor in pixels/second
   */
  get vel() {
    return this.motion.vel;
  }
  set vel(val) {
    this.motion.vel = val;
  }
  /**
   * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may
   * be useful to simulate a gravitational effect.
   */
  get acc() {
    return this.motion.acc;
  }
  set acc(val) {
    this.motion.acc = val;
  }
  /**
   * The current torque applied to the actor
   */
  get torque() {
    return this.motion.torque;
  }
  set torque(val) {
    this.motion.torque = val;
  }
  /**
   * Gets/sets the rotation of the body from the last frame.
   */
  get oldRotation() {
    return this.oldTransform.rotation;
  }
  /**
   * The rotation of the body in radians
   */
  get rotation() {
    return this.transform.globalRotation;
  }
  set rotation(val) {
    this.transform.globalRotation = val;
  }
  /**
   * The scale vector of the actor
   */
  get scale() {
    return this.transform.globalScale;
  }
  set scale(val) {
    this.transform.globalScale = val;
  }
  /**
   * The scale of the actor last frame
   */
  get oldScale() {
    return this.oldTransform.scale;
  }
  /**
   * The scale rate of change of the actor in scale/second
   */
  get scaleFactor() {
    return this.motion.scaleFactor;
  }
  set scaleFactor(scaleFactor) {
    this.motion.scaleFactor = scaleFactor;
  }
  /**
   * Get the angular velocity in radians/second
   */
  get angularVelocity() {
    return this.motion.angularVelocity;
  }
  /**
   * Set the angular velocity in radians/second
   */
  set angularVelocity(value) {
    this.motion.angularVelocity = value;
  }
  /**
   * Apply a specific impulse to the body
   * @param point
   * @param impulse
   */
  applyImpulse(point2, impulse) {
    if (this.collisionType !== CollisionType.Active) {
      return;
    }
    const finalImpulse = impulse.scale(this.inverseMass, this._impulseScratch);
    if (this.limitDegreeOfFreedom.indexOf(
      "x"
      /* X */
    ) > -1) {
      finalImpulse.x = 0;
    }
    if (this.limitDegreeOfFreedom.indexOf(
      "y"
      /* Y */
    ) > -1) {
      finalImpulse.y = 0;
    }
    this.vel.addEqual(finalImpulse);
    if (!this.limitDegreeOfFreedom.includes(
      "rotation"
      /* Rotation */
    )) {
      const distanceFromCenter = point2.sub(this.globalPos, this._distanceFromCenterScratch);
      this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
    }
  }
  /**
   * Apply only linear impulse to the body
   * @param impulse
   */
  applyLinearImpulse(impulse) {
    if (this.collisionType !== CollisionType.Active) {
      return;
    }
    const finalImpulse = impulse.scale(this.inverseMass);
    if (this.limitDegreeOfFreedom.includes(
      "x"
      /* X */
    )) {
      finalImpulse.x = 0;
    }
    if (this.limitDegreeOfFreedom.includes(
      "y"
      /* Y */
    )) {
      finalImpulse.y = 0;
    }
    this.vel = this.vel.add(finalImpulse);
  }
  /**
   * Apply only angular impulse to the body
   * @param point
   * @param impulse
   */
  applyAngularImpulse(point2, impulse) {
    if (this.collisionType !== CollisionType.Active) {
      return;
    }
    if (!this.limitDegreeOfFreedom.includes(
      "rotation"
      /* Rotation */
    )) {
      const distanceFromCenter = point2.sub(this.globalPos);
      this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
    }
  }
  /**
   * Sets the old versions of pos, vel, acc, and scale.
   */
  captureOldTransform() {
    this.__oldTransformCaptured = true;
    const tx = this.transform.get();
    tx.clone(this.oldTransform);
    this.oldTransform.parent = tx.parent;
    this.oldVel.setTo(this.vel.x, this.vel.y);
    this.oldAcc.setTo(this.acc.x, this.acc.y);
    this.oldGlobalPos.setTo(this.globalPos.x, this.globalPos.y);
  }
  clone() {
    const component = super.clone();
    return component;
  }
};
_BodyComponent._ID = 0;
_BodyComponent._DEFAULT_CONFIG = {
  ...getDefaultPhysicsConfig().bodies
};
let BodyComponent = _BodyComponent;
class HashGridProxy {
  constructor(object, gridSize) {
    this.object = object;
    this.id = -1;
    this.cells = [];
    this.hasZeroBounds = false;
    this.gridSize = gridSize;
    this.bounds = object.bounds;
    this.hasZeroBounds = this.bounds.hasZeroDimensions();
    this.leftX = Math.floor(this.bounds.left / this.gridSize);
    this.rightX = Math.floor(this.bounds.right / this.gridSize);
    this.bottomY = Math.floor(this.bounds.bottom / this.gridSize);
    this.topY = Math.floor(this.bounds.top / this.gridSize);
  }
  /**
   * Has the hashed bounds changed
   */
  hasChanged() {
    const bounds = this.object.bounds;
    const leftX = Math.floor(bounds.left / this.gridSize);
    const rightX = Math.floor(bounds.right / this.gridSize);
    const bottomY = Math.floor(bounds.bottom / this.gridSize);
    const topY = Math.floor(bounds.top / this.gridSize);
    if (this.leftX !== leftX || this.rightX !== rightX || this.bottomY !== bottomY || this.topY !== topY) {
      return true;
    }
    return false;
  }
  /**
   * Clears all collider references
   */
  clear() {
    for (const cell of this.cells) {
      const index = cell.proxies.indexOf(this);
      if (index > -1) {
        cell.proxies.splice(index, 1);
      }
    }
  }
  /**
   * Update bounds of the proxy
   */
  updateBounds() {
    this.bounds = this.object.bounds;
  }
  /**
   * Updates the hashed bounds coordinates
   */
  update() {
    this.bounds = this.object.bounds;
    this.leftX = Math.floor(this.bounds.left / this.gridSize);
    this.rightX = Math.floor(this.bounds.right / this.gridSize);
    this.bottomY = Math.floor(this.bounds.bottom / this.gridSize);
    this.topY = Math.floor(this.bounds.top / this.gridSize);
    this.hasZeroBounds = this.object.bounds.hasZeroDimensions();
  }
}
class HashGridCell {
  constructor() {
    this.proxies = [];
  }
  configure(x, y) {
    this.x = x;
    this.y = y;
    this.key = HashGridCell.calculateHashKey(x, y);
  }
  static calculateHashKey(x, y) {
    return `${x}+${y}`;
  }
}
class SparseHashGrid {
  constructor(options) {
    this.bounds = new BoundingBox();
    this._hashGridCellPool = new RentalPool(
      () => new HashGridCell(),
      (instance) => {
        instance.configure(0, 0);
        instance.proxies.length = 0;
        return instance;
      },
      1e3
    );
    this.gridSize = options.size;
    this.sparseHashGrid = /* @__PURE__ */ new Map();
    this.objectToProxy = /* @__PURE__ */ new Map();
    if (options.proxyFactory) {
      this._buildProxy = (object) => options.proxyFactory(object, this.gridSize);
    } else {
      this._buildProxy = (object) => new HashGridProxy(object, this.gridSize);
    }
  }
  query(boundsOrPoint) {
    const results = /* @__PURE__ */ new Set();
    if (boundsOrPoint instanceof BoundingBox) {
      const bounds = boundsOrPoint;
      const leftX = Math.floor(bounds.left / this.gridSize);
      const rightX = Math.floor(bounds.right / this.gridSize);
      const bottomY = Math.floor(bounds.bottom / this.gridSize);
      const topY = Math.floor(bounds.top / this.gridSize);
      for (let x = leftX; x <= rightX; x++) {
        for (let y = topY; y <= bottomY; y++) {
          const key = HashGridCell.calculateHashKey(x, y);
          const cell = this.sparseHashGrid.get(key);
          if (cell) {
            for (let i = 0; i < cell.proxies.length; i++) {
              cell.proxies[i].updateBounds();
              if (cell.proxies[i].bounds.intersect(bounds)) {
                results.add(cell.proxies[i].object);
              }
            }
          }
        }
      }
    } else {
      const point2 = boundsOrPoint;
      const key = HashGridCell.calculateHashKey(Math.floor(point2.x / this.gridSize), Math.floor(point2.y / this.gridSize));
      const cell = this.sparseHashGrid.get(key);
      if (cell) {
        for (let i = 0; i < cell.proxies.length; i++) {
          cell.proxies[i].updateBounds();
          if (cell.proxies[i].bounds.contains(point2)) {
            results.add(cell.proxies[i].object);
          }
        }
      }
    }
    return Array.from(results);
  }
  get(xCoord, yCoord) {
    const key = HashGridCell.calculateHashKey(xCoord, yCoord);
    const cell = this.sparseHashGrid.get(key);
    return cell;
  }
  _insert(x, y, proxy) {
    const key = HashGridCell.calculateHashKey(x, y);
    let cell = this.sparseHashGrid.get(key);
    if (!cell) {
      cell = this._hashGridCellPool.rent();
      cell.configure(x, y);
      this.sparseHashGrid.set(cell.key, cell);
    }
    cell.proxies.push(proxy);
    proxy.cells.push(cell);
    this.bounds.combine(proxy.bounds, this.bounds);
  }
  _remove(x, y, proxy) {
    const key = HashGridCell.calculateHashKey(x, y);
    const cell = this.sparseHashGrid.get(key);
    if (cell) {
      const proxyIndex = cell.proxies.indexOf(proxy);
      if (proxyIndex > -1) {
        cell.proxies.splice(proxyIndex, 1);
      }
      const cellIndex = proxy.cells.indexOf(cell);
      if (cellIndex > -1) {
        proxy.cells.splice(cellIndex, 1);
      }
      if (cell.proxies.length === 0) {
        this._hashGridCellPool.return(cell);
        this.sparseHashGrid.delete(key);
      }
    }
  }
  track(target) {
    const proxy = this._buildProxy(target);
    this.objectToProxy.set(target, proxy);
    for (let x = proxy.leftX; x <= proxy.rightX; x++) {
      for (let y = proxy.topY; y <= proxy.bottomY; y++) {
        this._insert(x, y, proxy);
      }
    }
  }
  untrack(target) {
    const proxy = this.objectToProxy.get(target);
    if (proxy) {
      proxy.clear();
      this.objectToProxy.delete(target);
    }
  }
  update(targets) {
    let updated = 0;
    for (const target of targets) {
      const proxy = this.objectToProxy.get(target);
      if (!proxy) {
        continue;
      }
      if (proxy.hasChanged()) {
        for (let x = proxy.leftX; x <= proxy.rightX; x++) {
          for (let y = proxy.topY; y <= proxy.bottomY; y++) {
            this._remove(x, y, proxy);
          }
        }
        proxy.update();
        for (let x = proxy.leftX; x <= proxy.rightX; x++) {
          for (let y = proxy.topY; y <= proxy.bottomY; y++) {
            this._insert(x, y, proxy);
          }
        }
        updated++;
      }
    }
    return updated;
  }
  debug(ex, elapsed) {
    const transparent = Color.Transparent;
    const color = Color.White;
    for (const cell of this.sparseHashGrid.values()) {
      ex.drawRectangle(vec(cell.x * this.gridSize, cell.y * this.gridSize), this.gridSize, this.gridSize, transparent, color, 2);
    }
  }
}
class HashColliderProxy extends HashGridProxy {
  constructor(collider, gridSize) {
    var _a, _b, _c;
    super(collider, gridSize);
    this.collider = collider;
    this.id = -1;
    this.hasZeroBounds = false;
    this.cells = [];
    this.gridSize = gridSize;
    const bounds = collider.bounds;
    this.hasZeroBounds = bounds.hasZeroDimensions();
    this.leftX = Math.floor(bounds.left / this.gridSize);
    this.rightX = Math.floor(bounds.right / this.gridSize);
    this.bottomY = Math.floor(bounds.bottom / this.gridSize);
    this.topY = Math.floor(bounds.top / this.gridSize);
    this.owner = collider.owner;
    this.body = (_a = this.owner) == null ? void 0 : _a.get(BodyComponent);
    this.collisionType = (_c = (_b = this.body) == null ? void 0 : _b.collisionType) != null ? _c : CollisionType.PreventCollision;
  }
  /**
   * Updates the hashed bounds coordinates
   */
  update() {
    var _a, _b, _c;
    super.update();
    this.body = (_a = this.owner) == null ? void 0 : _a.get(BodyComponent);
    this.collisionType = (_c = (_b = this.body) == null ? void 0 : _b.collisionType) != null ? _c : CollisionType.PreventCollision;
    this.hasZeroBounds = this.collider.localBounds.hasZeroDimensions();
  }
}
class SparseHashGridCollisionProcessor {
  constructor(options) {
    this._pairs = /* @__PURE__ */ new Set();
    this._nonPairs = /* @__PURE__ */ new Set();
    this._pairPool = new Pool(
      () => new Pair({ id: createId("collider", 0) }, { id: createId("collider", 0) }),
      (instance) => {
        instance.colliderA = null;
        instance.colliderB = null;
        return instance;
      },
      200
    );
    this.gridSize = options.size;
    this.hashGrid = new SparseHashGrid({
      size: this.gridSize,
      proxyFactory: (collider, size) => new HashColliderProxy(collider, size)
    });
    this._pairPool.disableWarnings = true;
  }
  getColliders() {
    return Array.from(this.hashGrid.objectToProxy.keys());
  }
  query(boundsOrPoint) {
    return this.hashGrid.query(boundsOrPoint);
  }
  rayCast(ray, options) {
    var _a, _b, _c;
    const results = [];
    const maxDistance = (_a = options == null ? void 0 : options.maxDistance) != null ? _a : Infinity;
    const collisionGroup = options == null ? void 0 : options.collisionGroup;
    const collisionMask = !collisionGroup ? (_b = options == null ? void 0 : options.collisionMask) != null ? _b : CollisionGroup.All.category : collisionGroup.category;
    const searchAllColliders = (_c = options == null ? void 0 : options.searchAllColliders) != null ? _c : false;
    const unitRay = ray.dir.normalize();
    const dydx = unitRay.y / unitRay.x;
    const dxdy = unitRay.x / unitRay.y;
    const unitStepX = Math.sqrt(1 + dydx * dydx) * this.gridSize;
    const unitStepY = Math.sqrt(1 + dxdy * dxdy) * this.gridSize;
    const startXCoord = ray.pos.x / this.gridSize;
    const startYCoord = ray.pos.y / this.gridSize;
    const stepDir = vec(1, 1);
    let currentXCoord = ~~startXCoord;
    let currentYCoord = ~~startYCoord;
    let currentRayLengthX = 0;
    let currentRayLengthY = 0;
    if (unitRay.x < 0) {
      stepDir.x = -1;
      currentRayLengthX = (startXCoord - currentXCoord) * unitStepX;
    } else {
      stepDir.x = 1;
      currentRayLengthX = (currentXCoord + 1 - startXCoord) * unitStepX;
    }
    if (unitRay.y < 0) {
      stepDir.y = -1;
      currentRayLengthY = (startYCoord - currentYCoord) * unitStepY;
    } else {
      stepDir.y = 1;
      currentRayLengthY = (currentYCoord + 1 - startYCoord) * unitStepY;
    }
    const collidersVisited = /* @__PURE__ */ new Set();
    let done = false;
    let maxIterations = 9999;
    while (!done && maxIterations > 0) {
      maxIterations--;
      if (!this.hashGrid.bounds.contains(vec(currentXCoord * this.gridSize, currentYCoord * this.gridSize))) {
        break;
      }
      const key = HashGridCell.calculateHashKey(currentXCoord, currentYCoord);
      const cell = this.hashGrid.sparseHashGrid.get(key);
      if (cell) {
        const cellHits = [];
        for (let colliderIndex = 0; colliderIndex < cell.proxies.length; colliderIndex++) {
          const collider = cell.proxies[colliderIndex];
          if (!collidersVisited.has(collider.collider.id.value)) {
            collidersVisited.add(collider.collider.id.value);
            if (collider.body) {
              if ((options == null ? void 0 : options.ignoreCollisionGroupAll) && collider.body.group === CollisionGroup.All) {
                continue;
              }
              const canCollide = (collisionMask & collider.body.group.category) !== 0;
              if (collider.body.group && !canCollide) {
                continue;
              }
            }
            const hit = collider.collider.rayCast(ray, maxDistance);
            if (hit) {
              cellHits.push(hit);
            }
          }
        }
        cellHits.sort((hit1, hit2) => hit1.distance - hit2.distance);
        for (let i = 0; i < cellHits.length; i++) {
          const hit = cellHits[i];
          if (options == null ? void 0 : options.filter) {
            if (options.filter(hit)) {
              results.push(hit);
              if (!searchAllColliders) {
                done = true;
                break;
              }
            }
          } else {
            results.push(hit);
            if (!searchAllColliders) {
              done = true;
              break;
            }
          }
        }
      }
      if (currentRayLengthX < currentRayLengthY) {
        currentXCoord += stepDir.x;
        currentRayLengthX += unitStepX;
      } else {
        currentYCoord += stepDir.y;
        currentRayLengthY += unitStepY;
      }
    }
    results.sort((hit1, hit2) => hit1.distance - hit2.distance);
    if (!searchAllColliders && results.length) {
      return [results[0]];
    }
    return results;
  }
  /**
   * Adds the collider to the internal data structure for collision tracking
   * @param target
   */
  track(target) {
    let colliders = [target];
    if (target instanceof CompositeCollider) {
      const compColliders = target.getColliders();
      for (const c of compColliders) {
        c.owner = target.owner;
      }
      colliders = compColliders;
    }
    for (const target2 of colliders) {
      this.hashGrid.track(target2);
    }
  }
  /**
   * Removes a collider from the internal data structure for tracking collisions
   * @param target
   */
  untrack(target) {
    let colliders = [target];
    if (target instanceof CompositeCollider) {
      colliders = target.getColliders();
    }
    for (const target2 of colliders) {
      this.hashGrid.untrack(target2);
    }
  }
  _canCollide(colliderA, colliderB) {
    if (colliderA.collider.id === colliderB.collider.id) {
      return false;
    }
    if (colliderA.owner && colliderB.owner && colliderA.owner.id === colliderB.owner.id) {
      return false;
    }
    if (colliderA.hasZeroBounds || colliderB.hasZeroBounds) {
      return false;
    }
    if (colliderA.body && colliderB.body && !colliderA.body.group.canCollide(colliderB.body.group)) {
      return false;
    }
    if (colliderA.collisionType === CollisionType.Fixed && colliderB.collisionType === CollisionType.Fixed) {
      return false;
    }
    if (colliderA.collisionType === CollisionType.PreventCollision || colliderB.collisionType === CollisionType.PreventCollision) {
      return false;
    }
    if (!colliderA.owner.isActive || !colliderB.owner.isActive) {
      return false;
    }
    return true;
  }
  /**
   * Runs the broadphase sweep over tracked colliders and returns possible collision pairs
   * @param targets
   * @param elapsed
   */
  broadphase(targets, elapsed) {
    const pairs = [];
    this._pairs.clear();
    this._nonPairs.clear();
    let proxyId = 0;
    for (const proxy of this.hashGrid.objectToProxy.values()) {
      proxy.id = proxyId++;
      if (!proxy.owner.isActive || proxy.collisionType === CollisionType.PreventCollision) {
        continue;
      }
      for (let cellIndex = 0; cellIndex < proxy.cells.length; cellIndex++) {
        const cell = proxy.cells[cellIndex];
        for (let otherIndex = 0; otherIndex < cell.proxies.length; otherIndex++) {
          const other = cell.proxies[otherIndex];
          if (other.id === proxy.id) {
            continue;
          }
          const id = Pair.calculatePairHash(proxy.collider.id, other.collider.id);
          if (this._nonPairs.has(id)) {
            continue;
          }
          if (!this._pairs.has(id) && this._canCollide(proxy, other) && proxy.object.bounds.overlaps(other.object.bounds)) {
            const pair = this._pairPool.get();
            pair.colliderA = proxy.collider;
            pair.colliderB = other.collider;
            pair.id = id;
            this._pairs.add(id);
            pairs.push(pair);
          } else {
            this._nonPairs.add(id);
          }
        }
      }
    }
    return pairs;
  }
  /**
   * Runs a fine grain pass on collision pairs and does geometry intersection tests producing any contacts
   * @param pairs
   * @param stats
   */
  narrowphase(pairs, stats) {
    const contacts = [];
    for (let i = 0; i < pairs.length; i++) {
      const newContacts = pairs[i].collide();
      for (let j = 0; j < newContacts.length; j++) {
        const c = newContacts[j];
        contacts.push(c);
        if (stats) {
          stats.physics.contacts.set(c.id, c);
        }
      }
    }
    this._pairPool.done();
    if (stats) {
      stats.physics.collisions += contacts.length;
    }
    return contacts;
  }
  /**
   * Perform data structure maintenance, returns number of colliders updated
   */
  update(targets, elapsed) {
    return this.hashGrid.update(targets);
  }
  /**
   * Draws the internal data structure
   * @param ex
   * @param elapsed
   */
  debug(ex, elapsed) {
    this.hashGrid.debug(ex, elapsed);
  }
}
class QuadTree {
  constructor(bounds, options) {
    this.bounds = bounds;
    this.options = options;
    this._defaultOptions = {
      maxDepth: 10,
      capacity: 10,
      level: 0
    };
    this.items = [];
    this._isDivided = false;
    this.topLeft = null;
    this.topRight = null;
    this.bottomLeft = null;
    this.bottomRight = null;
    this.options = { ...this._defaultOptions, ...options };
    this.halfWidth = bounds.width / 2;
    this.halfHeight = bounds.height / 2;
  }
  /**
   * Splits the quad tree one level deeper
   */
  _split() {
    this._isDivided = true;
    const newLevelOptions = {
      maxDepth: this.options.maxDepth,
      capacity: this.options.capacity,
      level: this.options.level + 1
    };
    this.topLeft = new QuadTree(
      new BoundingBox({
        left: this.bounds.left,
        top: this.bounds.top,
        right: this.bounds.left + this.halfWidth,
        bottom: this.bounds.top + this.halfHeight
      }),
      newLevelOptions
    );
    this.topRight = new QuadTree(
      new BoundingBox({
        left: this.bounds.left + this.halfWidth,
        top: this.bounds.top,
        right: this.bounds.right,
        bottom: this.bounds.top + this.halfHeight
      }),
      newLevelOptions
    );
    this.bottomLeft = new QuadTree(
      new BoundingBox({
        left: this.bounds.left,
        top: this.bounds.top + this.halfHeight,
        right: this.bounds.left + this.halfWidth,
        bottom: this.bounds.bottom
      }),
      newLevelOptions
    );
    this.bottomRight = new QuadTree(
      new BoundingBox({
        left: this.bounds.left + this.halfWidth,
        top: this.bounds.top + this.halfHeight,
        right: this.bounds.right,
        bottom: this.bounds.bottom
      }),
      newLevelOptions
    );
  }
  _insertIntoSubNodes(item) {
    var _a, _b, _c, _d;
    if ((_a = this.topLeft) == null ? void 0 : _a.bounds.overlaps(item.bounds)) {
      this.topLeft.insert(item);
    }
    if ((_b = this.topRight) == null ? void 0 : _b.bounds.overlaps(item.bounds)) {
      this.topRight.insert(item);
    }
    if ((_c = this.bottomLeft) == null ? void 0 : _c.bounds.overlaps(item.bounds)) {
      this.bottomLeft.insert(item);
    }
    if ((_d = this.bottomRight) == null ? void 0 : _d.bounds.overlaps(item.bounds)) {
      this.bottomRight.insert(item);
    }
  }
  /**
   * Insert an item to be tracked in the QuadTree
   * @param item
   */
  insert(item) {
    if (this._isDivided) {
      this._insertIntoSubNodes(item);
      return;
    }
    this.items.push(item);
    if (this.items.length > this.options.capacity && this.options.level < this.options.maxDepth) {
      if (!this._isDivided) {
        this._split();
      }
      for (const item2 of this.items) {
        this._insertIntoSubNodes(item2);
      }
      this.items.length = 0;
    }
  }
  /**
   * Remove a tracked item in the QuadTree
   * @param item
   */
  remove(item) {
    var _a, _b, _c, _d;
    if (!this.bounds.overlaps(item.bounds)) {
      return;
    }
    if (!this._isDivided) {
      const index = this.items.indexOf(item);
      if (index > -1) {
        this.items.splice(index, 1);
      }
      return;
    }
    if ((_a = this.topLeft) == null ? void 0 : _a.bounds.overlaps(item.bounds)) {
      this.topLeft.remove(item);
    }
    if ((_b = this.topRight) == null ? void 0 : _b.bounds.overlaps(item.bounds)) {
      this.topRight.remove(item);
    }
    if ((_c = this.bottomLeft) == null ? void 0 : _c.bounds.overlaps(item.bounds)) {
      this.bottomLeft.remove(item);
    }
    if ((_d = this.bottomRight) == null ? void 0 : _d.bounds.overlaps(item.bounds)) {
      this.bottomRight.remove(item);
    }
  }
  /**
   * Query the structure for all objects that intersect the bounding box
   * @param boundingBox
   * @returns items
   */
  query(boundingBox) {
    let results = this.items;
    if (this._isDivided) {
      if (this.topLeft.bounds.overlaps(boundingBox)) {
        results = results.concat(this.topLeft.query(boundingBox));
      }
      if (this.topRight.bounds.overlaps(boundingBox)) {
        results = results.concat(this.topRight.query(boundingBox));
      }
      if (this.bottomLeft.bounds.overlaps(boundingBox)) {
        results = results.concat(this.bottomLeft.query(boundingBox));
      }
      if (this.bottomRight.bounds.overlaps(boundingBox)) {
        results = results.concat(this.bottomRight.query(boundingBox));
      }
    }
    results = results.filter((item, index) => {
      return results.indexOf(item) >= index;
    });
    return results;
  }
  clear() {
    this.items = [];
    this._isDivided = false;
    this.topLeft = null;
    this.topRight = null;
    this.bottomLeft = null;
    this.bottomRight = null;
  }
  getAllItems() {
    let results = this.items;
    if (this._isDivided) {
      results = results.concat(this.topLeft.getAllItems());
      results = results.concat(this.topRight.getAllItems());
      results = results.concat(this.bottomLeft.getAllItems());
      results = results.concat(this.bottomRight.getAllItems());
    }
    results = results.filter((item, index) => {
      return results.indexOf(item) >= index;
    });
    return results;
  }
  getTreeDepth() {
    if (!this._isDivided) {
      return 0;
    }
    return 1 + Math.max(this.topLeft.getTreeDepth(), this.topRight.getTreeDepth(), this.bottomLeft.getTreeDepth(), this.bottomRight.getTreeDepth());
  }
  debug(ctx) {
    this.bounds.draw(ctx, Color.Yellow);
    if (this._isDivided) {
      this.topLeft.bounds.draw(ctx, Color.Yellow);
      this.topRight.bounds.draw(ctx, Color.Yellow);
      this.bottomLeft.bounds.draw(ctx, Color.Yellow);
      this.bottomRight.bounds.draw(ctx, Color.Yellow);
    }
  }
}
class ArcadeSolver {
  constructor(config) {
    this.config = config;
    this.directionMap = /* @__PURE__ */ new Map();
    this.distanceMap = /* @__PURE__ */ new Map();
    this._compositeContactsIds = /* @__PURE__ */ new Set();
  }
  solve(contacts) {
    this.preSolve(contacts);
    contacts = contacts.filter((c) => !c.isCanceled());
    let bias;
    switch (this.config.contactSolveBias) {
      case ContactSolveBias.HorizontalFirst: {
        bias = HorizontalFirst;
        break;
      }
      case ContactSolveBias.VerticalFirst: {
        bias = VerticalFirst;
        break;
      }
      default: {
        bias = None;
      }
    }
    contacts.sort((a, b) => {
      const aDir = this.directionMap.get(a.id);
      const bDir = this.directionMap.get(b.id);
      const aDist = this.distanceMap.get(a.id);
      const bDist = this.distanceMap.get(b.id);
      return bias[aDir] - bias[bDir] || aDist - bDist;
    });
    for (const contact of contacts) {
      this.solvePosition(contact);
      this.solveVelocity(contact);
    }
    this.postSolve(contacts);
    return contacts;
  }
  preSolve(contacts) {
    const epsilon = 1e-4;
    for (let i = 0; i < contacts.length; i++) {
      const contact = contacts[i];
      const index = contact.id.indexOf("|");
      if (index > 0) {
        const compositeId = contact.id.substring(index + 1);
        if (this._compositeContactsIds.has(compositeId)) {
          contact.cancel();
          continue;
        }
        this._compositeContactsIds.add(compositeId);
      }
      if (Math.abs(contact.mtv.x) < epsilon && Math.abs(contact.mtv.y) < epsilon) {
        contact.cancel();
        continue;
      }
      const side = Side.fromDirection(contact.mtv);
      const mtv = contact.mtv.negate();
      const distance = Math.abs(contact.info.separation);
      this.distanceMap.set(contact.id, distance);
      this.directionMap.set(contact.id, side === Side.Left || side === Side.Right ? "horizontal" : "vertical");
      contact.colliderA.events.emit("precollision", new PreCollisionEvent(contact.colliderA, contact.colliderB, side, mtv, contact));
      contact.colliderB.events.emit(
        "precollision",
        new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate(), contact)
      );
    }
    this._compositeContactsIds.clear();
  }
  postSolve(contacts) {
    var _a, _b;
    for (let i = 0; i < contacts.length; i++) {
      const contact = contacts[i];
      if (contact.isCanceled()) {
        continue;
      }
      const colliderA = contact.colliderA;
      const colliderB = contact.colliderB;
      const bodyA = (_a = colliderA.owner) == null ? void 0 : _a.get(BodyComponent);
      const bodyB = (_b = colliderB.owner) == null ? void 0 : _b.get(BodyComponent);
      if (bodyA && bodyB) {
        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
          continue;
        }
      }
      const side = Side.fromDirection(contact.mtv);
      const mtv = contact.mtv.negate();
      contact.colliderA.events.emit("postcollision", new PostCollisionEvent(contact.colliderA, contact.colliderB, side, mtv, contact));
      contact.colliderB.events.emit(
        "postcollision",
        new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate(), contact)
      );
    }
  }
  solvePosition(contact) {
    var _a, _b;
    const epsilon = 1e-4;
    if (!contact.colliderA.bounds.overlaps(contact.colliderB.bounds, epsilon)) {
      contact.cancel();
      return;
    }
    if (Math.abs(contact.mtv.x) < epsilon && Math.abs(contact.mtv.y) < epsilon) {
      contact.cancel();
      return;
    }
    let mtv = contact.mtv;
    const colliderA = contact.colliderA;
    const colliderB = contact.colliderB;
    const bodyA = (_a = colliderA.owner) == null ? void 0 : _a.get(BodyComponent);
    const bodyB = (_b = colliderB.owner) == null ? void 0 : _b.get(BodyComponent);
    if (bodyA && bodyB) {
      if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
        return;
      }
      if (bodyA.collisionType === CollisionType.Active && bodyB.collisionType === CollisionType.Active) {
        mtv = mtv.scale(0.5);
      }
      if (bodyA.collisionType === CollisionType.Active) {
        bodyA.globalPos.x -= mtv.x;
        bodyA.globalPos.y -= mtv.y;
        colliderA.update(bodyA.transform.get());
      }
      if (bodyB.collisionType === CollisionType.Active) {
        bodyB.globalPos.x += mtv.x;
        bodyB.globalPos.y += mtv.y;
        colliderB.update(bodyB.transform.get());
      }
    }
  }
  solveVelocity(contact) {
    var _a, _b;
    if (contact.isCanceled()) {
      return;
    }
    const colliderA = contact.colliderA;
    const colliderB = contact.colliderB;
    const bodyA = (_a = colliderA.owner) == null ? void 0 : _a.get(BodyComponent);
    const bodyB = (_b = colliderB.owner) == null ? void 0 : _b.get(BodyComponent);
    if (bodyA && bodyB) {
      if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
        return;
      }
      const normal = contact.normal;
      const opposite = normal.negate();
      if (bodyA.collisionType === CollisionType.Active) {
        if (bodyA.vel.normalize().dot(opposite) < 0) {
          const velAdj = normal.scale(normal.dot(bodyA.vel.negate()));
          bodyA.vel = bodyA.vel.add(velAdj);
        }
      }
      if (bodyB.collisionType === CollisionType.Active) {
        if (bodyB.vel.normalize().dot(normal) < 0) {
          const velAdj = opposite.scale(opposite.dot(bodyB.vel.negate()));
          bodyB.vel = bodyB.vel.add(velAdj);
        }
      }
    }
  }
}
class ContactConstraintPoint {
  constructor(point2, local, contact) {
    this.point = point2;
    this.local = local;
    this.contact = contact;
    this.normalImpulse = 0;
    this.tangentImpulse = 0;
    this.normalMass = 0;
    this.tangentMass = 0;
    this.aToContact = new Vector(0, 0);
    this.bToContact = new Vector(0, 0);
    this.originalVelocityAndRestitution = 0;
    this.update();
  }
  /**
   * Updates the contact information
   */
  update() {
    const bodyA = this.contact.bodyA;
    const colliderA = this.contact.colliderA;
    const bodyB = this.contact.bodyB;
    const colliderB = this.contact.colliderB;
    if (bodyA && bodyB) {
      const normal = this.contact.normal;
      const tangent = this.contact.tangent;
      this.aToContact = this.point.sub(colliderA.center);
      this.bToContact = this.point.sub(colliderB.center);
      const aToContactNormal = this.aToContact.cross(normal);
      const bToContactNormal = this.bToContact.cross(normal);
      this.normalMass = bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * aToContactNormal * aToContactNormal + bodyB.inverseInertia * bToContactNormal * bToContactNormal;
      const aToContactTangent = this.aToContact.cross(tangent);
      const bToContactTangent = this.bToContact.cross(tangent);
      this.tangentMass = bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * aToContactTangent * aToContactTangent + bodyB.inverseInertia * bToContactTangent * bToContactTangent;
    }
    return this;
  }
  /**
   * Returns the relative velocity between bodyA and bodyB
   */
  getRelativeVelocity() {
    const bodyA = this.contact.bodyA;
    const bodyB = this.contact.bodyB;
    if (bodyA && bodyB) {
      const velA = bodyA.vel.add(Vector.cross(bodyA.angularVelocity, this.aToContact));
      const velB = bodyB.vel.add(Vector.cross(bodyB.angularVelocity, this.bToContact));
      return velB.sub(velA);
    }
    return Vector.Zero;
  }
}
class RealisticSolver {
  constructor(config) {
    this.config = config;
    this.directionMap = /* @__PURE__ */ new Map();
    this.distanceMap = /* @__PURE__ */ new Map();
    this.lastFrameContacts = /* @__PURE__ */ new Map();
    this.idToContactConstraint = /* @__PURE__ */ new Map();
  }
  getContactConstraints(id) {
    var _a;
    return (_a = this.idToContactConstraint.get(id)) != null ? _a : [];
  }
  solve(contacts) {
    this.preSolve(contacts);
    contacts = contacts.filter((c) => !c.isCanceled());
    let bias;
    switch (this.config.contactSolveBias) {
      case ContactSolveBias.HorizontalFirst: {
        bias = HorizontalFirst;
        break;
      }
      case ContactSolveBias.VerticalFirst: {
        bias = VerticalFirst;
        break;
      }
      default: {
        bias = None;
      }
    }
    contacts.sort((a, b) => {
      const aDir = this.directionMap.get(a.id);
      const bDir = this.directionMap.get(b.id);
      const aDist = this.distanceMap.get(a.id);
      const bDist = this.distanceMap.get(b.id);
      return bias[aDir] - bias[bDir] || aDist - bDist;
    });
    this.solveVelocity(contacts);
    this.solvePosition(contacts);
    this.postSolve(contacts);
    return contacts;
  }
  preSolve(contacts) {
    var _a, _b, _c, _d;
    const epsilon = 1e-4;
    for (let i = 0; i < contacts.length; i++) {
      const contact = contacts[i];
      if (Math.abs(contact.mtv.x) < epsilon && Math.abs(contact.mtv.y) < epsilon) {
        contact.cancel();
        continue;
      }
      const side = Side.fromDirection(contact.mtv);
      const distance = Math.abs(((_a = contact == null ? void 0 : contact.info) == null ? void 0 : _a.separation) || 0);
      this.distanceMap.set(contact.id, distance);
      this.directionMap.set(contact.id, side === Side.Left || side === Side.Right ? "horizontal" : "vertical");
      contact.colliderA.events.emit(
        "precollision",
        new PreCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact)
      );
      contact.colliderA.events.emit(
        "beforecollisionresolve",
        new CollisionPreSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact)
      );
      contact.colliderB.events.emit(
        "precollision",
        new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact)
      );
      contact.colliderB.events.emit(
        "beforecollisionresolve",
        new CollisionPreSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact)
      );
      contact.matchAwake();
    }
    const finishedContactIds = Array.from(this.idToContactConstraint.keys());
    for (let i = 0; i < contacts.length; i++) {
      const contact = contacts[i];
      const index = finishedContactIds.indexOf(contact.id);
      if (index > -1) {
        finishedContactIds.splice(index, 1);
      }
      const contactPoints = (_b = this.idToContactConstraint.get(contact.id)) != null ? _b : [];
      let pointIndex = 0;
      const bodyA = contact.bodyA;
      const colliderA = contact.colliderA;
      const bodyB = contact.bodyB;
      const colliderB = contact.colliderB;
      if (bodyA && bodyB) {
        for (let j = 0; j < contact.points.length; j++) {
          const point2 = contact.points[j];
          const normal = contact.normal;
          const tangent = contact.tangent;
          const aToContact = point2.sub(colliderA.center);
          const bToContact = point2.sub(colliderB.center);
          const aToContactNormal = aToContact.cross(normal);
          const bToContactNormal = bToContact.cross(normal);
          const normalMass = bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * aToContactNormal * aToContactNormal + bodyB.inverseInertia * bToContactNormal * bToContactNormal;
          const aToContactTangent = aToContact.cross(tangent);
          const bToContactTangent = bToContact.cross(tangent);
          const tangentMass = bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * aToContactTangent * aToContactTangent + bodyB.inverseInertia * bToContactTangent * bToContactTangent;
          if (contactPoints[pointIndex] && ((_d = (_c = contactPoints[pointIndex]) == null ? void 0 : _c.point) == null ? void 0 : _d.squareDistance(point2)) < 4) {
            contactPoints[pointIndex].point = point2;
            contactPoints[pointIndex].local = contact.localPoints[pointIndex];
          } else {
            contactPoints[pointIndex] = new ContactConstraintPoint(point2, contact.localPoints[pointIndex], contact);
          }
          contactPoints[pointIndex].aToContact = aToContact;
          contactPoints[pointIndex].bToContact = bToContact;
          contactPoints[pointIndex].normalMass = 1 / normalMass;
          contactPoints[pointIndex].tangentMass = 1 / tangentMass;
          const restitution = bodyA.bounciness > bodyB.bounciness ? bodyA.bounciness : bodyB.bounciness;
          const relativeVelocity = contact.normal.dot(contactPoints[pointIndex].getRelativeVelocity());
          contactPoints[pointIndex].originalVelocityAndRestitution = 0;
          if (relativeVelocity < -0.1) {
            contactPoints[pointIndex].originalVelocityAndRestitution = -restitution * relativeVelocity;
          }
          pointIndex++;
        }
      }
      this.idToContactConstraint.set(contact.id, contactPoints);
    }
    for (const id of finishedContactIds) {
      this.idToContactConstraint.delete(id);
    }
    if (this.config.warmStart) {
      this.warmStart(contacts);
    } else {
      for (let i = 0; i < contacts.length; i++) {
        const contact = contacts[i];
        const contactPoints = this.getContactConstraints(contact.id);
        for (const point2 of contactPoints) {
          point2.normalImpulse = 0;
          point2.tangentImpulse = 0;
        }
      }
    }
  }
  postSolve(contacts) {
    for (let i = 0; i < contacts.length; i++) {
      const contact = contacts[i];
      const bodyA = contact.bodyA;
      const bodyB = contact.bodyB;
      if (bodyA && bodyB) {
        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
          continue;
        }
        bodyA.updateMotion();
        bodyB.updateMotion();
      }
      const side = Side.fromDirection(contact.mtv);
      contact.colliderA.events.emit(
        "postcollision",
        new PostCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact)
      );
      contact.colliderA.events.emit(
        "aftercollisionresolve",
        new CollisionPostSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact)
      );
      contact.colliderB.events.emit(
        "postcollision",
        new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact)
      );
      contact.colliderB.events.emit(
        "aftercollisionresolve",
        new CollisionPostSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact)
      );
    }
    this.lastFrameContacts.clear();
    for (let i = 0; i < contacts.length; i++) {
      const c = contacts[i];
      this.lastFrameContacts.set(c.id, c);
    }
  }
  /**
   * Warm up body's based on previous frame contact points
   * @param contacts
   */
  warmStart(contacts) {
    var _a;
    for (let i = 0; i < contacts.length; i++) {
      const contact = contacts[i];
      const bodyA = contact.bodyA;
      const bodyB = contact.bodyB;
      if (bodyA && bodyB) {
        const contactPoints = (_a = this.idToContactConstraint.get(contact.id)) != null ? _a : [];
        for (const point2 of contactPoints) {
          if (this.config.warmStart) {
            const normalImpulse = contact.normal.scale(point2.normalImpulse);
            const tangentImpulse = contact.tangent.scale(point2.tangentImpulse);
            const impulse = normalImpulse.add(tangentImpulse);
            bodyA.applyImpulse(point2.point, impulse.negate());
            bodyB.applyImpulse(point2.point, impulse);
          } else {
            point2.normalImpulse = 0;
            point2.tangentImpulse = 0;
          }
        }
      }
    }
  }
  /**
   * Iteratively solve the position overlap constraint
   * @param contacts
   */
  solvePosition(contacts) {
    var _a;
    for (let i = 0; i < this.config.positionIterations; i++) {
      for (let i2 = 0; i2 < contacts.length; i2++) {
        const contact = contacts[i2];
        const bodyA = contact.bodyA;
        const bodyB = contact.bodyB;
        if (bodyA && bodyB) {
          if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
            continue;
          }
          const constraints = (_a = this.idToContactConstraint.get(contact.id)) != null ? _a : [];
          for (const point2 of constraints) {
            const normal = contact.normal;
            const separation = CollisionJumpTable.FindContactSeparation(contact, point2.local);
            const steeringConstant = this.config.steeringFactor;
            const maxCorrection = -5;
            const slop = this.config.slop;
            const steeringForce = clamp(steeringConstant * (separation + slop), maxCorrection, 0);
            const impulse = normal.scale(-steeringForce * point2.normalMass);
            if (bodyA.collisionType === CollisionType.Active) {
              const impulseForce = impulse.negate().scale(bodyA.inverseMass);
              if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
                impulseForce.x = 0;
              }
              if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
                impulseForce.y = 0;
              }
              bodyA.globalPos = bodyA.globalPos.add(impulseForce);
              if (!bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
                bodyA.rotation -= point2.aToContact.cross(impulse) * bodyA.inverseInertia;
              }
            }
            if (bodyB.collisionType === CollisionType.Active) {
              const impulseForce = impulse.scale(bodyB.inverseMass);
              if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
                impulseForce.x = 0;
              }
              if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
                impulseForce.y = 0;
              }
              bodyB.globalPos = bodyB.globalPos.add(impulseForce);
              if (!bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
                bodyB.rotation += point2.bToContact.cross(impulse) * bodyB.inverseInertia;
              }
            }
          }
        }
      }
    }
  }
  solveVelocity(contacts) {
    var _a;
    for (let i = 0; i < this.config.velocityIterations; i++) {
      for (let i2 = 0; i2 < contacts.length; i2++) {
        const contact = contacts[i2];
        const bodyA = contact.bodyA;
        const bodyB = contact.bodyB;
        if (bodyA && bodyB) {
          if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
            continue;
          }
          const friction = Math.min(bodyA.friction, bodyB.friction);
          const constraints = (_a = this.idToContactConstraint.get(contact.id)) != null ? _a : [];
          for (const point2 of constraints) {
            const relativeVelocity = point2.getRelativeVelocity();
            const tangentVelocity = -relativeVelocity.dot(contact.tangent);
            let impulseDelta = tangentVelocity * point2.tangentMass;
            const maxFriction = friction * point2.normalImpulse;
            const newImpulse = clamp(point2.tangentImpulse + impulseDelta, -maxFriction, maxFriction);
            impulseDelta = newImpulse - point2.tangentImpulse;
            point2.tangentImpulse = newImpulse;
            const impulse = contact.tangent.scale(impulseDelta);
            bodyA.applyImpulse(point2.point, impulse.negate());
            bodyB.applyImpulse(point2.point, impulse);
          }
          for (const point2 of constraints) {
            const relativeVelocity = point2.getRelativeVelocity();
            const normalVelocity = relativeVelocity.dot(contact.normal);
            let impulseDelta = -point2.normalMass * (normalVelocity - point2.originalVelocityAndRestitution);
            const newImpulse = Math.max(point2.normalImpulse + impulseDelta, 0);
            impulseDelta = newImpulse - point2.normalImpulse;
            point2.normalImpulse = newImpulse;
            const impulse = contact.normal.scale(impulseDelta);
            bodyA.applyImpulse(point2.point, impulse.negate());
            bodyB.applyImpulse(point2.point, impulse);
          }
        }
      }
    }
  }
}
class MotionSystem extends System {
  constructor(world, physics) {
    super();
    this.world = world;
    this.physics = physics;
    this.systemType = SystemType.Update;
    this._physicsConfigDirty = false;
    physics.$configUpdate.subscribe(() => this._physicsConfigDirty = true);
    this.query = this.world.query([TransformComponent, MotionComponent]);
  }
  update(elapsed) {
    let transform;
    let motion;
    const entities = this.query.entities;
    const substep = this.physics.config.substep;
    for (let i = 0; i < entities.length; i++) {
      transform = entities[i].get(TransformComponent);
      motion = entities[i].get(MotionComponent);
      const optionalBody = entities[i].get(BodyComponent);
      if (this._physicsConfigDirty && optionalBody) {
        optionalBody.updatePhysicsConfig(this.physics.config.bodies);
      }
      if (optionalBody == null ? void 0 : optionalBody.isSleeping) {
        continue;
      }
      const totalAcc = motion.acc.clone();
      if ((optionalBody == null ? void 0 : optionalBody.collisionType) === CollisionType.Active && (optionalBody == null ? void 0 : optionalBody.useGravity)) {
        totalAcc.addEqual(this.physics.config.gravity);
      }
      if (!entities[i].parent) {
        this.captureOldTransformWithChildren(entities[i]);
      }
      EulerIntegrator.integrate(transform, motion, totalAcc, elapsed / substep);
    }
    this._physicsConfigDirty = false;
  }
  captureOldTransformWithChildren(entity) {
    var _a;
    (_a = entity.get(BodyComponent)) == null ? void 0 : _a.captureOldTransform();
    for (let i = 0; i < entity.children.length; i++) {
      this.captureOldTransformWithChildren(entity.children[i]);
    }
  }
}
MotionSystem.priority = SystemPriority.Higher;
class CollisionSystem extends System {
  constructor(world, _physics) {
    super();
    this._physics = _physics;
    this.systemType = SystemType.Update;
    this._configDirty = false;
    this._lastFrameContacts = /* @__PURE__ */ new Map();
    this._currentFrameContacts = /* @__PURE__ */ new Map();
    this._arcadeSolver = new ArcadeSolver(_physics.config.arcade);
    this._realisticSolver = new RealisticSolver(_physics.config.realistic);
    this._physics.$configUpdate.subscribe(() => this._configDirty = true);
    this._trackCollider = (c) => this._processor.track(c);
    this._untrackCollider = (c) => this._processor.untrack(c);
    this.query = world.query([TransformComponent, ColliderComponent]);
    this.query.entityAdded$.subscribe((e) => {
      const colliderComponent = e.get(ColliderComponent);
      colliderComponent.$colliderAdded.subscribe(this._trackCollider);
      colliderComponent.$colliderRemoved.subscribe(this._untrackCollider);
      const collider = colliderComponent.get();
      if (collider) {
        this._processor.track(collider);
      }
    });
    this.query.entityRemoved$.subscribe((e) => {
      const colliderComponent = e.get(ColliderComponent);
      const collider = colliderComponent.get();
      if (colliderComponent && collider) {
        this._processor.untrack(collider);
      }
    });
    this._motionSystem = world.get(MotionSystem);
  }
  get _processor() {
    return this._physics.collisionProcessor;
  }
  initialize(world, scene) {
    this._engine = scene.engine;
  }
  update(elapsed) {
    var _a, _b, _c, _d;
    if (!this._physics.config.enabled) {
      return;
    }
    let colliders = [];
    for (let entityIndex = 0; entityIndex < this.query.entities.length; entityIndex++) {
      const entity = this.query.entities[entityIndex];
      const colliderComp = entity.get(ColliderComponent);
      const collider = colliderComp == null ? void 0 : colliderComp.get();
      if (colliderComp && ((_a = colliderComp.owner) == null ? void 0 : _a.isActive) && collider) {
        colliderComp.update();
        if (collider instanceof CompositeCollider) {
          const compositeColliders = collider.getColliders();
          if (!collider.compositeStrategy) {
            collider.compositeStrategy = this._physics.config.colliders.compositeStrategy;
          }
          colliders = colliders.concat(compositeColliders);
        } else {
          colliders.push(collider);
        }
      }
    }
    this._processor.update(colliders, elapsed);
    let pairs = this._processor.broadphase(colliders, elapsed);
    this._currentFrameContacts.clear();
    let contacts = [];
    const solver = this.getSolver();
    const substep = this._physics.config.substep;
    for (let step = 0; step < substep; step++) {
      if (step > 0) {
        this._motionSystem.update(elapsed);
      }
      if (contacts.length) {
        pairs = contacts.map((c) => new Pair(c.colliderA, c.colliderB));
      }
      if (pairs.length) {
        contacts = this._processor.narrowphase(pairs, (_d = (_c = (_b = this._engine) == null ? void 0 : _b.debug) == null ? void 0 : _c.stats) == null ? void 0 : _d.currFrame);
        contacts = solver.solve(contacts);
        for (const contact of contacts) {
          if (contact.isCanceled()) {
            continue;
          }
          const index = contact.id.indexOf("|");
          if (index > 0) {
            const compositeId = contact.id.substring(index + 1);
            this._currentFrameContacts.set(compositeId, contact);
          } else {
            this._currentFrameContacts.set(contact.id, contact);
          }
        }
      }
    }
    this.runContactStartEnd();
    this._lastFrameContacts.clear();
    this._lastFrameContacts = new Map(this._currentFrameContacts);
    for (const entity of this.query.entities) {
      const collider = entity.get(ColliderComponent);
      if (collider) {
        collider.processColliderRemoval();
      }
    }
  }
  postupdate() {
    SeparatingAxis.SeparationPool.done();
  }
  getSolver() {
    if (this._configDirty) {
      this._configDirty = false;
      this._arcadeSolver = new ArcadeSolver(this._physics.config.arcade);
      this._realisticSolver = new RealisticSolver(this._physics.config.realistic);
    }
    return this._physics.config.solver === SolverStrategy.Realistic ? this._realisticSolver : this._arcadeSolver;
  }
  debug(ex) {
    this._processor.debug(ex, 0);
  }
  runContactStartEnd() {
    for (const [id, c] of this._currentFrameContacts) {
      if (!this._lastFrameContacts.has(id)) {
        const colliderA = c.colliderA;
        const colliderB = c.colliderB;
        const side = Side.fromDirection(c.mtv);
        const opposite = Side.getOpposite(side);
        colliderA.events.emit("collisionstart", new CollisionStartEvent(colliderA, colliderB, side, c));
        colliderA.events.emit("contactstart", new ContactStartEvent(colliderA, colliderB, side, c));
        colliderB.events.emit("collisionstart", new CollisionStartEvent(colliderB, colliderA, opposite, c));
        colliderB.events.emit("contactstart", new ContactStartEvent(colliderB, colliderA, opposite, c));
      }
    }
    for (const [id, c] of this._lastFrameContacts) {
      if (!this._currentFrameContacts.has(id)) {
        const colliderA = c.colliderA;
        const colliderB = c.colliderB;
        const side = Side.fromDirection(c.mtv);
        const opposite = Side.getOpposite(side);
        colliderA.events.emit("collisionend", new CollisionEndEvent(colliderA, colliderB, side, c));
        colliderA.events.emit("contactend", new ContactEndEvent(colliderA, colliderB, side, c));
        colliderB.events.emit("collisionend", new CollisionEndEvent(colliderB, colliderA, opposite, c));
        colliderB.events.emit("contactend", new ContactEndEvent(colliderB, colliderA, opposite, c));
      }
    }
  }
}
CollisionSystem.priority = SystemPriority.Higher;
class PhysicsWorld {
  constructor(config) {
    this.$configUpdate = new Observable();
    this._configDirty = false;
    this.config = config;
    this.$configUpdate.subscribe((config2) => {
      this._configDirty = true;
      BodyComponent.updateDefaultPhysicsConfig(config2.bodies);
    });
    if (this._config.spatialPartition === SpatialPartitionStrategy.SparseHashGrid) {
      this._collisionProcessor = new SparseHashGridCollisionProcessor(this._config.sparseHashGrid);
    } else {
      this._collisionProcessor = new DynamicTreeCollisionProcessor(this._config);
    }
  }
  get config() {
    return watchDeep(this._config, (change) => {
      this.$configUpdate.notifyAll(change);
    });
  }
  set config(newConfig) {
    this._config = newConfig;
    this.$configUpdate.notifyAll(newConfig);
  }
  /**
   * Spatial data structure for locating potential collision pairs and ray casts
   */
  get collisionProcessor() {
    if (this._configDirty) {
      this._configDirty = false;
      const colliders = this._collisionProcessor.getColliders();
      if (this._config.spatialPartition === SpatialPartitionStrategy.SparseHashGrid) {
        this._collisionProcessor = new SparseHashGridCollisionProcessor(this._config.sparseHashGrid);
      } else {
        this._collisionProcessor = new DynamicTreeCollisionProcessor(this._config);
      }
      for (const collider of colliders) {
        this._collisionProcessor.track(collider);
      }
    }
    return this._collisionProcessor;
  }
  /**
   * Raycast into the scene's physics world
   * @param ray
   * @param options
   */
  rayCast(ray, options) {
    return this.collisionProcessor.rayCast(ray, options);
  }
  query(pointOrBounds) {
    return this._collisionProcessor.query(pointOrBounds);
  }
}
var DisplayMode = /* @__PURE__ */ ((DisplayMode2) => {
  DisplayMode2["Fixed"] = "Fixed";
  DisplayMode2["FitContainerAndFill"] = "FitContainerAndFill";
  DisplayMode2["FitScreenAndFill"] = "FitScreenAndFill";
  DisplayMode2["FitContainerAndZoom"] = "FitContainerAndZoom";
  DisplayMode2["FitScreenAndZoom"] = "FitScreenAndZoom";
  DisplayMode2["FitScreen"] = "FitScreen";
  DisplayMode2["FillScreen"] = "FillScreen";
  DisplayMode2["FitContainer"] = "FitContainer";
  DisplayMode2["FillContainer"] = "FillContainer";
  return DisplayMode2;
})(DisplayMode || {});
class Resolution {
  /* istanbul ignore next */
  static get SVGA() {
    return { width: 800, height: 600 };
  }
  /* istanbul ignore next */
  static get Standard() {
    return { width: 1920, height: 1080 };
  }
  /* istanbul ignore next */
  static get Atari2600() {
    return { width: 160, height: 192 };
  }
  /* istanbul ignore next */
  static get GameBoy() {
    return { width: 160, height: 144 };
  }
  /* istanbul ignore next */
  static get GameBoyAdvance() {
    return { width: 240, height: 160 };
  }
  /* istanbul ignore next */
  static get NintendoDS() {
    return { width: 256, height: 192 };
  }
  /* istanbul ignore next */
  static get NES() {
    return { width: 256, height: 224 };
  }
  /* istanbul ignore next */
  static get SNES() {
    return { width: 256, height: 244 };
  }
}
const ScreenEvents = {
  ScreenResize: "resize",
  PixelRatioChange: "pixelratio",
  FullScreenChange: "fullscreen"
};
class Screen {
  constructor(options) {
    this.events = new EventEmitter();
    this._antialiasing = true;
    this._canvasImageRendering = "auto";
    this._resolutionStack = [];
    this._viewportStack = [];
    this._pixelRatioOverride = null;
    this._isFullscreen = false;
    this._isDisposed = false;
    this._logger = Logger.getInstance();
    this._fullscreenChangeHandler = () => {
      if (this._isDisposed) {
        return;
      }
      this._isFullscreen = !this._isFullscreen;
      this._logger.debug("Fullscreen Change", this._isFullscreen);
      this.events.emit("fullscreen", {
        fullscreen: this.isFullscreen
      });
    };
    this._pixelRatioChangeHandler = () => {
      if (this._isDisposed) {
        return;
      }
      this._logger.debug("Pixel Ratio Change", window.devicePixelRatio);
      this._listenForPixelRatio();
      this._devicePixelRatio = this._calculateDevicePixelRatio();
      this.applyResolutionAndViewport();
      this.events.emit("pixelratio", {
        pixelRatio: this.pixelRatio
      });
    };
    this._resizeHandler = () => {
      if (this._isDisposed) {
        return;
      }
      const parent = this.parent;
      this._logger.debug("View port resized");
      this._setResolutionAndViewportByDisplayMode(parent);
      this.applyResolutionAndViewport();
      this.events.emit("resize", {
        resolution: this.resolution,
        viewport: this.viewport
      });
    };
    this._devicePixelRatio = this._calculateDevicePixelRatio();
    this._contentArea = new BoundingBox();
    this._unsafeArea = new BoundingBox();
    var _a, _b, _c, _d;
    this.viewport = options.viewport;
    this.resolution = (_a = options.resolution) != null ? _a : { ...this.viewport };
    this._contentResolution = this.resolution;
    this._displayMode = (_b = options.displayMode) != null ? _b : "Fixed";
    this._canvas = options.canvas;
    this.graphicsContext = options.context;
    this._antialiasing = (_c = options.antialiasing) != null ? _c : this._antialiasing;
    this._canvasImageRendering = (_d = options.canvasImageRendering) != null ? _d : this._canvasImageRendering;
    this._browser = options.browser;
    this._pixelRatioOverride = options.pixelRatio;
    this._applyDisplayMode();
    this._listenForPixelRatio();
    this._canvas.addEventListener("fullscreenchange", this._fullscreenChangeHandler);
    this.applyResolutionAndViewport();
  }
  _listenForPixelRatio() {
    if (this._mediaQueryList && !this._mediaQueryList.addEventListener) {
      this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);
    }
    this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
    if (this._mediaQueryList.addEventListener) {
      this._mediaQueryList.addEventListener("change", this._pixelRatioChangeHandler, { once: true });
    } else {
      this._mediaQueryList.addListener(this._pixelRatioChangeHandler);
    }
  }
  dispose() {
    if (!this._isDisposed) {
      this._isDisposed = true;
      this.events.clear();
      this._browser.window.off("resize", this._resizeHandler);
      this._browser.window.clear();
      if (this._resizeObserver) {
        this._resizeObserver.disconnect();
      }
      this.parent.removeEventListener("resize", this._resizeHandler);
      if (this._mediaQueryList.removeEventListener) {
        this._mediaQueryList.removeEventListener("change", this._pixelRatioChangeHandler);
      } else {
        this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);
      }
      this._canvas.removeEventListener("fullscreenchange", this._fullscreenChangeHandler);
      this._canvas = null;
    }
  }
  _calculateDevicePixelRatio() {
    if (window.devicePixelRatio < 1) {
      return 1;
    }
    const devicePixelRatio = window.devicePixelRatio || 1;
    return devicePixelRatio;
  }
  /**
   * Returns the computed pixel ratio, first using any override, then the device pixel ratio
   */
  get pixelRatio() {
    if (this._pixelRatioOverride) {
      return this._pixelRatioOverride;
    }
    return this._devicePixelRatio;
  }
  /**
   * This calculates the ratio between excalibur pixels and the HTML pixels.
   *
   * This is useful for scaling HTML UI so that it matches your game.
   */
  get worldToPagePixelRatio() {
    if (this._canvas) {
      const pageOrigin = this.worldToPageCoordinates(Vector.Zero);
      const pageDistance = this.worldToPageCoordinates(vec(1, 0)).sub(pageOrigin);
      const pixelConversion = pageDistance.x;
      return pixelConversion;
    } else {
      return 1;
    }
  }
  /**
   * Get or set the pixel ratio override
   *
   * You will need to call applyResolutionAndViewport() affect change on the screen
   */
  get pixelRatioOverride() {
    return this._pixelRatioOverride;
  }
  set pixelRatioOverride(value) {
    this._pixelRatioOverride = value;
  }
  get isHiDpi() {
    return this.pixelRatio !== 1;
  }
  get displayMode() {
    return this._displayMode;
  }
  get canvas() {
    return this._canvas;
  }
  get parent() {
    switch (this.displayMode) {
      case "FillContainer":
      case "FitContainer":
      case "FitContainerAndFill":
      case "FitContainerAndZoom":
        return this.canvas.parentElement || document.body;
      default:
        return window;
    }
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(resolution) {
    this._resolution = resolution;
  }
  /**
   * Returns screen dimensions in pixels or percentage
   */
  get viewport() {
    if (this._viewport) {
      return this._viewport;
    }
    return this._resolution;
  }
  set viewport(viewport) {
    this._viewport = viewport;
  }
  get aspectRatio() {
    return this._resolution.width / this._resolution.height;
  }
  get scaledWidth() {
    return this._resolution.width * this.pixelRatio;
  }
  get scaledHeight() {
    return this._resolution.height * this.pixelRatio;
  }
  setCurrentCamera(camera) {
    this._camera = camera;
  }
  pushResolutionAndViewport() {
    this._resolutionStack.push(this.resolution);
    this._viewportStack.push(this.viewport);
    this.resolution = { ...this.resolution };
    this.viewport = { ...this.viewport };
  }
  peekViewport() {
    return this._viewportStack[this._viewportStack.length - 1];
  }
  peekResolution() {
    return this._resolutionStack[this._resolutionStack.length - 1];
  }
  popResolutionAndViewport() {
    if (this._resolutionStack.length && this._viewportStack.length) {
      this.resolution = this._resolutionStack.pop();
      this.viewport = this._viewportStack.pop();
    }
  }
  applyResolutionAndViewport() {
    if (this.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {
      const scaledResolutionSupported = this.graphicsContext.checkIfResolutionSupported({
        width: this.scaledWidth,
        height: this.scaledHeight
      });
      if (!scaledResolutionSupported) {
        this._logger.warnOnce(
          `The currently configured resolution (${this.resolution.width}x${this.resolution.height}) and pixel ratio (${this.pixelRatio}) are too large for the platform WebGL implementation, this may work but cause WebGL rendering to behave oddly. Try reducing the resolution or disabling Hi DPI scaling to avoid this (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).`
        );
        if (!this.pixelRatioOverride) {
          let currentPixelRatio = Math.max(1, this.pixelRatio - 0.5);
          let newResolutionSupported = false;
          while (currentPixelRatio > 1 && !newResolutionSupported) {
            currentPixelRatio = Math.max(1, currentPixelRatio - 0.5);
            const width = this._resolution.width * currentPixelRatio;
            const height = this._resolution.height * currentPixelRatio;
            newResolutionSupported = this.graphicsContext.checkIfResolutionSupported({ width, height });
          }
          this.pixelRatioOverride = currentPixelRatio;
          this._logger.warnOnce(
            `Scaled resolution too big attempted recovery! Pixel ratio was automatically reduced to (${this.pixelRatio}) to avoid 4k texture limit. Setting \`ex.Engine({pixelRatio: ...}) will override any automatic recalculation, do so at your own risk.\`  (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).`
          );
        }
      }
    }
    this._canvas.width = this.scaledWidth;
    this._canvas.height = this.scaledHeight;
    if (this._canvasImageRendering === "auto") {
      this._canvas.style.imageRendering = "auto";
    } else {
      this._canvas.style.imageRendering = "pixelated";
      if (this._canvas.style.imageRendering === "") {
        this._canvas.style.imageRendering = "crisp-edges";
      }
    }
    const widthUnit = this.viewport.widthUnit === "percent" ? "%" : "px";
    const heightUnit = this.viewport.heightUnit === "percent" ? "%" : "px";
    this._canvas.style.width = this.viewport.width + widthUnit;
    this._canvas.style.height = this.viewport.height + heightUnit;
    this.graphicsContext.updateViewport(this.resolution);
    this.graphicsContext.resetTransform();
    this.graphicsContext.smoothing = this._antialiasing;
    if (this.graphicsContext instanceof ExcaliburGraphicsContext2DCanvas) {
      this.graphicsContext.scale(this.pixelRatio, this.pixelRatio);
    }
    document.documentElement.style.setProperty("--ex-pixel-ratio", this.worldToPagePixelRatio.toString());
  }
  /**
   * Get or set screen antialiasing,
   *
   * If true smoothing is applied
   */
  get antialiasing() {
    return this._antialiasing;
  }
  /**
   * Get or set screen antialiasing
   */
  set antialiasing(isSmooth) {
    this._antialiasing = isSmooth;
    this.graphicsContext.smoothing = this._antialiasing;
  }
  /**
   * Returns true if excalibur is fullscreen using the browser fullscreen api
   * @deprecated use isFullscreen()
   */
  get isFullScreen() {
    return this._isFullscreen;
  }
  /**
   * Returns true if excalibur is fullscreen using the browser fullscreen api
   */
  get isFullscreen() {
    return this._isFullscreen;
  }
  /**
   * Requests to go fullscreen using the browser fullscreen api, requires user interaction to be successful.
   * For example, wire this to a user click handler.
   *
   * Optionally specify a target element id to go fullscreen, by default the game canvas is used
   * @param elementId
   * @deprecated use enterFullscreen(...)
   */
  goFullScreen(elementId) {
    return this.enterFullscreen(elementId);
  }
  /**
   * Requests to enter fullscreen using the browser fullscreen api, requires user interaction to be successful.
   * For example, wire this to a user click handler.
   *
   * Optionally specify a target element id to go fullscreen, by default the game canvas is used
   * @param elementId
   */
  enterFullscreen(elementId) {
    var _a, _b, _c, _d, _e, _f;
    if (elementId) {
      const maybeElement = document.getElementById(elementId);
      if ((maybeElement == null ? void 0 : maybeElement.requestFullscreen) || (maybeElement == null ? void 0 : maybeElement.webkitRequestFullscreen)) {
        if (!maybeElement.getAttribute("ex-fullscreen-listener")) {
          maybeElement.setAttribute("ex-fullscreen-listener", "true");
          maybeElement.addEventListener("fullscreenchange", this._fullscreenChangeHandler);
        }
        if (maybeElement.requestFullscreen) {
          return (_a = maybeElement.requestFullscreen()) != null ? _a : Promise.resolve();
        } else if (maybeElement.webkitRequestFullscreen) {
          return (_b = maybeElement.webkitRequestFullscreen()) != null ? _b : Promise.resolve();
        }
      }
    }
    if ((_c = this._canvas) == null ? void 0 : _c.requestFullscreen) {
      return (_e = (_d = this._canvas) == null ? void 0 : _d.requestFullscreen()) != null ? _e : Promise.resolve();
    } else if (this._canvas.webkitRequestFullscreen) {
      return (_f = this._canvas.webkitRequestFullscreen()) != null ? _f : Promise.resolve();
    }
    this._logger.warnOnce("Could not go fullscreen, is this an iPhone? Currently Apple does not support fullscreen on iPhones");
    return Promise.resolve();
  }
  /**
   * Requests to exit fullscreen using the browser fullscreen api
   * @deprecated use exitFullscreen()
   */
  exitFullScreen() {
    return this.exitFullscreen();
  }
  exitFullscreen() {
    return document.exitFullscreen();
  }
  _viewportToPixels(viewport) {
    return {
      width: viewport.widthUnit === "percent" ? this.canvas.offsetWidth : viewport.width,
      height: viewport.heightUnit === "percent" ? this.canvas.offsetHeight : viewport.height
    };
  }
  /**
   * Takes a coordinate in normal html page space, for example from a pointer move event, and translates it to
   * Excalibur screen space.
   *
   * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
   * bottom right corner (resolutionX, resolutionY). When using *AndFill suffixed display modes screen space
   * (0, 0) is the top left of the safe content area bounding box not the viewport.
   * @param point
   */
  pageToScreenCoordinates(point2) {
    let newX = point2.x;
    let newY = point2.y;
    if (!this._isFullscreen) {
      newX -= getPosition(this._canvas).x;
      newY -= getPosition(this._canvas).y;
    }
    const viewport = this._viewportToPixels(this.viewport);
    if (this._isFullscreen) {
      if (window.innerWidth / this.aspectRatio < window.innerHeight) {
        const screenHeight = window.innerWidth / this.aspectRatio;
        const screenMarginY = (window.innerHeight - screenHeight) / 2;
        newY = (newY - screenMarginY) / screenHeight * viewport.height;
        newX = newX / window.innerWidth * viewport.width;
      } else {
        const screenWidth = window.innerHeight * this.aspectRatio;
        const screenMarginX = (window.innerWidth - screenWidth) / 2;
        newX = (newX - screenMarginX) / screenWidth * viewport.width;
        newY = newY / window.innerHeight * viewport.height;
      }
    }
    newX = newX / viewport.width * this.resolution.width;
    newY = newY / viewport.height * this.resolution.height;
    newX = newX - this.contentArea.left;
    newY = newY - this.contentArea.top;
    return new Vector(newX, newY);
  }
  /**
   * Takes a coordinate in Excalibur screen space, and translates it to normal html page space. For example,
   * this is where html elements might live if you want to position them relative to Excalibur.
   *
   * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
   * bottom right corner (resolutionX, resolutionY)
   * @param point
   */
  screenToPageCoordinates(point2) {
    let newX = point2.x;
    let newY = point2.y;
    const viewport = this._viewportToPixels(this.viewport);
    newX = newX / this.resolution.width * viewport.width;
    newY = newY / this.resolution.height * viewport.height;
    if (this._isFullscreen) {
      if (window.innerWidth / this.aspectRatio < window.innerHeight) {
        const screenHeight = window.innerWidth / this.aspectRatio;
        const screenMarginY = (window.innerHeight - screenHeight) / 2;
        newY = newY / viewport.height * screenHeight + screenMarginY;
        newX = newX / viewport.width * window.innerWidth;
      } else {
        const screenWidth = window.innerHeight * this.aspectRatio;
        const screenMarginX = (window.innerWidth - screenWidth) / 2;
        newX = newX / viewport.width * screenWidth + screenMarginX;
        newY = newY / viewport.height * window.innerHeight;
      }
    }
    if (!this._isFullscreen) {
      newX += getPosition(this._canvas).x;
      newY += getPosition(this._canvas).y;
    }
    return new Vector(newX, newY);
  }
  /**
   * Takes a coordinate in Excalibur screen space, and translates it to Excalibur world space.
   *
   * World space is where {@apilink Entity | `entities`} in Excalibur live by default {@apilink CoordPlane.World}
   * and extends infinitely out relative from the {@apilink Camera}.
   * @param point  Screen coordinate to convert
   */
  screenToWorldCoordinates(point2) {
    point2 = point2.add(vec(this.contentArea.left, this.contentArea.top));
    if (this._camera) {
      return this._camera.inverse.multiply(point2);
    }
    return point2.sub(vec(this.resolution.width / 2, this.resolution.height / 2));
  }
  /**
   * Takes a coordinate in Excalibur world space, and translates it to Excalibur screen space.
   *
   * Screen space is where {@apilink ScreenElement | `screen elements`} and {@apilink Entity | `entities`} with {@apilink CoordPlane.Screen} live.
   * @param point  World coordinate to convert
   */
  worldToScreenCoordinates(point2) {
    if (this._camera) {
      return this._camera.transform.multiply(point2);
    }
    return point2.add(vec(this.resolution.width / 2, this.resolution.height / 2));
  }
  pageToWorldCoordinates(point2) {
    const screen = this.pageToScreenCoordinates(point2);
    return this.screenToWorldCoordinates(screen);
  }
  worldToPageCoordinates(point2) {
    const screen = this.worldToScreenCoordinates(point2);
    return this.screenToPageCoordinates(screen);
  }
  /**
   * Returns a BoundingBox of the top left corner of the screen
   * and the bottom right corner of the screen.
   *
   * World bounds are in world coordinates, useful for culling objects offscreen that are in world space
   */
  getWorldBounds() {
    const bounds = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Half).scale(vec(1 / this._camera.zoom, 1 / this._camera.zoom)).rotate(this._camera.rotation).translate(this._camera.drawPos);
    return bounds;
  }
  /**
   * Returns a BoundingBox of the top left corner of the screen and the bottom right corner of the screen.
   *
   * Screen bounds are in screen coordinates, useful for culling objects offscreen that are in screen space
   */
  getScreenBounds() {
    const bounds = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero, Vector.Zero);
    return bounds;
  }
  /**
   * The width of the game canvas in pixels (physical width component of the
   * resolution of the canvas element)
   */
  get canvasWidth() {
    return this.canvas.width;
  }
  /**
   * Returns half width of the game canvas in pixels (half physical width component)
   */
  get halfCanvasWidth() {
    return this.canvas.width / 2;
  }
  /**
   * The height of the game canvas in pixels, (physical height component of
   * the resolution of the canvas element)
   */
  get canvasHeight() {
    return this.canvas.height;
  }
  /**
   * Returns half height of the game canvas in pixels (half physical height component)
   */
  get halfCanvasHeight() {
    return this.canvas.height / 2;
  }
  /**
   * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get drawWidth() {
    if (this._camera) {
      return this.resolution.width / this._camera.zoom;
    }
    return this.resolution.width;
  }
  /**
   * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get width() {
    if (this._camera) {
      return this.resolution.width / this._camera.zoom;
    }
    return this.resolution.width;
  }
  /**
   * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get halfDrawWidth() {
    return this.drawWidth / 2;
  }
  /**
   * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get drawHeight() {
    if (this._camera) {
      return this.resolution.height / this._camera.zoom;
    }
    return this.resolution.height;
  }
  get height() {
    if (this._camera) {
      return this.resolution.height / this._camera.zoom;
    }
    return this.resolution.height;
  }
  /**
   * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get halfDrawHeight() {
    return this.drawHeight / 2;
  }
  /**
   * Returns screen center coordinates including zoom and device pixel ratio.
   */
  get center() {
    return vec(this.halfDrawWidth, this.halfDrawHeight);
  }
  /**
   * Returns the content area in screen space where it is safe to place content
   */
  get contentArea() {
    return this._contentArea;
  }
  /**
   * Returns the unsafe area in screen space, this is the full screen and some space may not be onscreen.
   */
  get unsafeArea() {
    return this._unsafeArea;
  }
  _computeFit() {
    document.body.style.margin = "0px";
    document.body.style.overflow = "hidden";
    const aspect = this.aspectRatio;
    let adjustedWidth = 0;
    let adjustedHeight = 0;
    if (window.innerWidth / aspect < window.innerHeight) {
      adjustedWidth = window.innerWidth;
      adjustedHeight = window.innerWidth / aspect;
    } else {
      adjustedWidth = window.innerHeight * aspect;
      adjustedHeight = window.innerHeight;
    }
    this.viewport = {
      width: adjustedWidth,
      height: adjustedHeight
    };
    this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);
    this._unsafeArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);
    this.events.emit("resize", {
      resolution: this.resolution,
      viewport: this.viewport
    });
  }
  _computeFitScreenAndFill() {
    document.body.style.margin = "0px";
    document.body.style.overflow = "hidden";
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    this._computeFitAndFill(vw, vh);
    this.events.emit("resize", {
      resolution: this.resolution,
      viewport: this.viewport
    });
  }
  _computeFitContainerAndFill() {
    this.canvas.style.width = "100%";
    this.canvas.style.height = "100%";
    this._computeFitAndFill(this.canvas.offsetWidth, this.canvas.offsetHeight, {
      width: 100,
      widthUnit: "percent",
      height: 100,
      heightUnit: "percent"
    });
    this.events.emit("resize", {
      resolution: this.resolution,
      viewport: this.viewport
    });
  }
  _computeFitAndFill(vw, vh, viewport) {
    this.viewport = viewport != null ? viewport : {
      width: vw,
      height: vh
    };
    if (vw / vh <= this._contentResolution.width / this._contentResolution.height) {
      this.resolution = {
        width: vw * this._contentResolution.width / vw,
        height: vw * this._contentResolution.width / vw * vh / vw
      };
      const clip = (this.resolution.height - this._contentResolution.height) / 2;
      this._contentArea = new BoundingBox({
        top: clip,
        left: 0,
        right: this._contentResolution.width,
        bottom: this.resolution.height - clip
      });
      this._unsafeArea = new BoundingBox({
        top: -clip,
        left: 0,
        right: this._contentResolution.width,
        bottom: this.resolution.height + clip
      });
    } else {
      this.resolution = {
        width: vh * this._contentResolution.height / vh * vw / vh,
        height: vh * this._contentResolution.height / vh
      };
      const clip = (this.resolution.width - this._contentResolution.width) / 2;
      this._contentArea = new BoundingBox({
        top: 0,
        left: clip,
        right: this.resolution.width - clip,
        bottom: this._contentResolution.height
      });
      this._unsafeArea = new BoundingBox({
        top: 0,
        left: -clip,
        right: this.resolution.width + clip,
        bottom: this._contentResolution.height
      });
    }
  }
  _computeFitScreenAndZoom() {
    document.body.style.margin = "0px";
    document.body.style.overflow = "hidden";
    this.canvas.style.position = "absolute";
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    this._computeFitAndZoom(vw, vh);
    this.events.emit("resize", {
      resolution: this.resolution,
      viewport: this.viewport
    });
  }
  _computeFitContainerAndZoom() {
    this.canvas.style.width = "100%";
    this.canvas.style.height = "100%";
    this.canvas.style.position = "relative";
    const parent = this.canvas.parentElement;
    parent.style.overflow = "hidden";
    const { offsetWidth: vw, offsetHeight: vh } = this.canvas;
    this._computeFitAndZoom(vw, vh);
    this.events.emit("resize", {
      resolution: this.resolution,
      viewport: this.viewport
    });
  }
  _computeFitAndZoom(vw, vh) {
    const aspect = this.aspectRatio;
    let adjustedWidth = 0;
    let adjustedHeight = 0;
    if (vw / aspect < vh) {
      adjustedWidth = vw;
      adjustedHeight = vw / aspect;
    } else {
      adjustedWidth = vh * aspect;
      adjustedHeight = vh;
    }
    const scaleX = vw / adjustedWidth;
    const scaleY = vh / adjustedHeight;
    const maxScaleFactor = Math.max(scaleX, scaleY);
    const zoomedWidth = adjustedWidth * maxScaleFactor;
    const zoomedHeight = adjustedHeight * maxScaleFactor;
    if (zoomedWidth > vw) {
      this.canvas.style.left = -(zoomedWidth - vw) / 2 + "px";
    } else {
      this.canvas.style.left = "";
    }
    if (zoomedHeight > vh) {
      this.canvas.style.top = -(zoomedHeight - vh) / 2 + "px";
    } else {
      this.canvas.style.top = "";
    }
    this.viewport = {
      width: zoomedWidth,
      height: zoomedHeight
    };
    const bounds = BoundingBox.fromDimension(this.viewport.width, this.viewport.height, Vector.Zero);
    if (this.viewport.width > vw) {
      const clip = (this.viewport.width - vw) / this.viewport.width * this.resolution.width;
      bounds.top = 0;
      bounds.left = clip / 2;
      bounds.right = this.resolution.width - clip / 2;
      bounds.bottom = this.resolution.height;
    }
    if (this.viewport.height > vh) {
      const clip = (this.viewport.height - vh) / this.viewport.height * this.resolution.height;
      bounds.top = clip / 2;
      bounds.left = 0;
      bounds.bottom = this.resolution.height - clip / 2;
      bounds.right = this.resolution.width;
    }
    this._contentArea = bounds;
  }
  _computeFitContainer() {
    const aspect = this.aspectRatio;
    let adjustedWidth = 0;
    let adjustedHeight = 0;
    let widthUnit = "pixel";
    let heightUnit = "pixel";
    const parent = this.canvas.parentElement;
    if (parent.clientWidth / aspect < parent.clientHeight) {
      this.canvas.style.width = "100%";
      adjustedWidth = 100;
      widthUnit = "percent";
      adjustedHeight = this.canvas.offsetWidth / aspect;
    } else {
      this.canvas.style.height = "100%";
      adjustedHeight = 100;
      heightUnit = "percent";
      adjustedWidth = this.canvas.offsetHeight * aspect;
    }
    this.viewport = {
      width: adjustedWidth,
      widthUnit,
      height: adjustedHeight,
      heightUnit
    };
    this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);
    this.events.emit("resize", {
      resolution: this.resolution,
      viewport: this.viewport
    });
  }
  _applyDisplayMode() {
    this._setResolutionAndViewportByDisplayMode(this.parent);
    if (this.parent instanceof Window) {
      this._browser.window.on("resize", this._resizeHandler);
    } else {
      this._resizeObserver = new ResizeObserver(() => {
        this._resizeHandler();
      });
      this._resizeObserver.observe(this.parent);
    }
    this.parent.addEventListener("resize", this._resizeHandler);
  }
  /**
   * Sets the resolution and viewport based on the selected display mode.
   */
  _setResolutionAndViewportByDisplayMode(parent) {
    if (this.displayMode === "FillContainer") {
      this.canvas.style.width = "100%";
      this.canvas.style.height = "100%";
      this.viewport = {
        width: 100,
        widthUnit: "percent",
        height: 100,
        heightUnit: "percent"
      };
      this.resolution = {
        width: this.canvas.offsetWidth,
        height: this.canvas.offsetHeight
      };
    }
    if (this.displayMode === "FillScreen") {
      document.body.style.margin = "0px";
      document.body.style.overflow = "hidden";
      this.resolution = {
        width: parent.innerWidth,
        height: parent.innerHeight
      };
      this.viewport = this.resolution;
    }
    this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);
    if (this.displayMode === "FitScreen") {
      this._computeFit();
    }
    if (this.displayMode === "FitContainer") {
      this._computeFitContainer();
    }
    if (this.displayMode === "FitScreenAndFill") {
      this._computeFitScreenAndFill();
    }
    if (this.displayMode === "FitContainerAndFill") {
      this._computeFitContainerAndFill();
    }
    if (this.displayMode === "FitScreenAndZoom") {
      this._computeFitScreenAndZoom();
    }
    if (this.displayMode === "FitContainerAndZoom") {
      this._computeFitContainerAndZoom();
    }
  }
}
class AudioContextFactory {
  static create() {
    if (!this._INSTANCE) {
      if (window.AudioContext || window.webkitAudioContext) {
        this._INSTANCE = new AudioContext();
      }
    }
    return this._INSTANCE;
  }
}
function isLegacyWebAudioSource(source) {
  return !!source.playbackState;
}
const _WebAudio = class _WebAudio2 {
  /**
   * Play an empty sound to unlock Safari WebAudio context. Call this function
   * right after a user interaction event.
   * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/
   */
  static unlock() {
    const promise = new Promise((resolve, reject) => {
      if (_WebAudio2._UNLOCKED || !AudioContextFactory.create()) {
        return resolve(true);
      }
      const unlockTimeoutTimer = setTimeout(() => {
        Logger.getInstance().warn("Excalibur was unable to unlock the audio context, audio probably will not play in this browser.");
        resolve(false);
      }, 200);
      const audioContext = AudioContextFactory.create();
      audioContext.resume().then(
        () => {
          const buffer = audioContext.createBuffer(1, 1, 22050);
          const source = audioContext.createBufferSource();
          let ended = false;
          source.buffer = buffer;
          source.connect(audioContext.destination);
          source.onended = () => ended = true;
          source.start(0);
          setTimeout(() => {
            if (isLegacyWebAudioSource(source)) {
              if (source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE) {
                _WebAudio2._UNLOCKED = true;
              }
            } else {
              if (audioContext.currentTime > 0 || ended) {
                _WebAudio2._UNLOCKED = true;
              }
            }
          }, 0);
          clearTimeout(unlockTimeoutTimer);
          resolve(true);
        },
        () => {
          reject();
        }
      );
    });
    return promise;
  }
  static isUnlocked() {
    return this._UNLOCKED;
  }
};
_WebAudio._UNLOCKED = false;
let WebAudio = _WebAudio;
class ExResponse {
}
ExResponse.type = {
  any: "",
  blob: "blob",
  json: "json",
  text: "text",
  document: "document",
  arraybuffer: "arraybuffer"
};
class StateMachine {
  constructor() {
    this.states = /* @__PURE__ */ new Map();
  }
  get currentState() {
    return this._currentState;
  }
  set currentState(state) {
    this._currentState = state;
  }
  static create(machineDescription, data) {
    const machine = new StateMachine();
    machine.data = data;
    for (const stateName in machineDescription.states) {
      machine.states.set(stateName, {
        name: stateName,
        ...machineDescription.states[stateName]
      });
    }
    for (const state of machine.states.values()) {
      for (const transitionState of state.transitions) {
        if (transitionState === "*") {
          continue;
        }
        if (!machine.states.has(transitionState)) {
          throw Error(
            `Invalid state machine, state [${state.name}] has a transition to another state that doesn't exist [${transitionState}]`
          );
        }
      }
    }
    machine.currentState = machine.startState = machine.states.get(machineDescription.start);
    return machine;
  }
  in(state) {
    return this.currentState.name === state;
  }
  go(stateName, eventData) {
    var _a, _b;
    if (this.currentState.transitions.includes(stateName) || this.currentState.transitions.includes("*")) {
      const potentialNewState = this.states.get(stateName);
      if (this.currentState.onExit) {
        const canExit = (_a = this.currentState) == null ? void 0 : _a.onExit({ to: potentialNewState.name, data: this.data });
        if (canExit === false) {
          return false;
        }
      }
      if (potentialNewState == null ? void 0 : potentialNewState.onEnter) {
        const canEnter = potentialNewState == null ? void 0 : potentialNewState.onEnter({ from: this.currentState.name, eventData, data: this.data });
        if (canEnter === false) {
          return false;
        }
      }
      this.currentState = potentialNewState;
      if ((_b = this.currentState) == null ? void 0 : _b.onState) {
        this.currentState.onState();
      }
      return true;
    }
    return false;
  }
  update(elapsed) {
    if (this.currentState.onUpdate) {
      this.currentState.onUpdate(this.data, elapsed);
    }
  }
  save(saveKey) {
    localStorage.setItem(
      saveKey,
      JSON.stringify({
        currentState: this.currentState.name,
        data: this.data
      })
    );
  }
  restore(saveKey) {
    const state = JSON.parse(localStorage.getItem(saveKey));
    this.currentState = this.states.get(state.currentState);
    this.data = state.data;
  }
}
class WebAudioInstance {
  constructor(_src) {
    this._src = _src;
    this._audioContext = AudioContextFactory.create();
    this._volumeNode = this._audioContext.createGain();
    this._playingFuture = new Future();
    this._stateMachine = StateMachine.create(
      {
        start: "STOPPED",
        states: {
          PLAYING: {
            onEnter: ({ data }) => {
              this._createNewBufferSource();
              this._handleEnd();
              if (this.loop) {
                this._instance.start(0, data.pausedAt * this._playbackRate);
              } else {
                this._instance.start(0, data.pausedAt * this._playbackRate, this.duration);
              }
              data.startedAt = this._audioContext.currentTime - data.pausedAt;
              data.pausedAt = 0;
            },
            onState: () => this._playStarted(),
            onExit: ({ to }) => {
              if (to === "STOPPED") {
                this._playingFuture.resolve(true);
              }
              this._instance.onended = null;
              this._instance.disconnect();
              this._instance.stop(0);
              this._instance = null;
            },
            transitions: ["STOPPED", "PAUSED", "SEEK"]
          },
          SEEK: {
            onEnter: ({ eventData: position, data }) => {
              data.pausedAt = (position != null ? position : 0) / this._playbackRate;
              data.startedAt = 0;
            },
            transitions: ["*"]
          },
          STOPPED: {
            onEnter: ({ data }) => {
              data.pausedAt = 0;
              data.startedAt = 0;
              this._playingFuture.resolve(true);
            },
            transitions: ["PLAYING", "PAUSED", "SEEK"]
          },
          PAUSED: {
            onEnter: ({ data }) => {
              data.pausedAt = this._audioContext.currentTime - data.startedAt;
            },
            transitions: ["PLAYING", "STOPPED", "SEEK"]
          }
        }
      },
      {
        startedAt: 0,
        pausedAt: 0
      }
    );
    this._volume = 1;
    this._loop = false;
    this._playStarted = () => {
    };
    this._playbackRate = 1;
    this._createNewBufferSource();
  }
  _createNewBufferSource() {
    this._instance = this._audioContext.createBufferSource();
    this._instance.buffer = this._src;
    this._instance.loop = this.loop;
    this._instance.playbackRate.value = this._playbackRate;
    this._instance.connect(this._volumeNode);
    this._volumeNode.connect(this._audioContext.destination);
  }
  _handleEnd() {
    if (!this.loop) {
      this._instance.onended = () => {
        this._playingFuture.resolve(true);
      };
    }
  }
  set loop(value) {
    this._loop = value;
    if (this._instance) {
      this._instance.loop = value;
      if (!this.loop) {
        this._instance.onended = () => {
          this._playingFuture.resolve(true);
        };
      }
    }
  }
  get loop() {
    return this._loop;
  }
  set volume(value) {
    value = clamp(value, 0, 1);
    this._volume = value;
    if (this._stateMachine.in("PLAYING") && this._volumeNode.gain.setTargetAtTime) {
      this._volumeNode.gain.setTargetAtTime(value, this._audioContext.currentTime, 0.1);
    } else {
      this._volumeNode.gain.value = value;
    }
  }
  get volume() {
    return this._volume;
  }
  /**
   * Returns the set duration to play, otherwise returns the total duration if unset
   */
  get duration() {
    var _a;
    return (_a = this._duration) != null ? _a : this.getTotalPlaybackDuration();
  }
  /**
   * Set the duration that this audio should play.
   *
   * Note: if you seek to a specific point the duration will start from that point, for example
   *
   * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.
   */
  set duration(duration) {
    this._duration = duration;
  }
  isPlaying() {
    return this._stateMachine.in("PLAYING");
  }
  isPaused() {
    return this._stateMachine.in("PAUSED") || this._stateMachine.in("SEEK");
  }
  isStopped() {
    return this._stateMachine.in("STOPPED");
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  play(playStarted = () => {
  }) {
    this._playStarted = playStarted;
    this._stateMachine.go("PLAYING");
    return this._playingFuture.promise;
  }
  pause() {
    this._stateMachine.go("PAUSED");
  }
  stop() {
    this._stateMachine.go("STOPPED");
  }
  seek(position) {
    this._stateMachine.go("PAUSED");
    this._stateMachine.go("SEEK", position);
  }
  getTotalPlaybackDuration() {
    return this._src.duration;
  }
  getPlaybackPosition() {
    const { pausedAt, startedAt } = this._stateMachine.data;
    if (pausedAt) {
      return pausedAt * this._playbackRate;
    }
    if (startedAt) {
      return (this._audioContext.currentTime - startedAt) * this._playbackRate;
    }
    return 0;
  }
  set playbackRate(playbackRate) {
    this._instance.playbackRate.value = this._playbackRate = playbackRate;
  }
  get playbackRate() {
    return this._instance.playbackRate.value;
  }
}
class MediaEvent extends GameEvent {
  constructor(target, _name = "MediaEvent") {
    super();
    this.target = target;
    this._name = _name;
  }
  /**
   * Media event cannot bubble
   */
  set bubbles(_value) {
  }
  /**
   * Media event cannot bubble
   */
  get bubbles() {
    return false;
  }
  /**
   * Media event cannot bubble, so they have no path
   */
  get _path() {
    return null;
  }
  /**
   * Media event cannot bubble, so they have no path
   */
  set _path(_val) {
  }
  /**
   * Prevents event from bubbling
   */
  stopPropagation() {
  }
  /**
   * Action, that calls when event happens
   */
  action() {
  }
  /**
   * Propagate event further through event path
   */
  propagate() {
  }
  layPath(_actor) {
  }
}
class NativeSoundEvent extends MediaEvent {
  constructor(target, track) {
    super(target, "NativeSoundEvent");
    this.track = track;
  }
}
class NativeSoundProcessedEvent extends MediaEvent {
  constructor(target, _processedData) {
    super(target, "NativeSoundProcessedEvent");
    this._processedData = _processedData;
    this.data = this._processedData;
  }
}
function canPlayFile(file) {
  try {
    const a = new Audio();
    const filetype = /.*\.([A-Za-z0-9]+)(?:(?:\?|\#).*)*$/;
    const type = file.match(filetype)[1];
    if (a.canPlayType("audio/" + type)) {
      return true;
    } else {
      return false;
    }
  } catch (e) {
    Logger.getInstance().warn("Cannot determine audio support, assuming no support for the Audio Tag", e);
    return false;
  }
}
const SoundEvents = {
  VolumeChange: "volumechange",
  Processed: "processed",
  Pause: "pause",
  Stop: "stop",
  PlaybackEnd: "playbackend",
  Resume: "resume",
  PlaybackStart: "playbackstart"
};
function isSoundOptions(x) {
  var _a;
  return !!((_a = x[0]) == null ? void 0 : _a.paths);
}
class Sound {
  constructor(...pathsOrSoundOption) {
    this.events = new EventEmitter();
    this.logger = Logger.getInstance();
    this._loop = false;
    this._volume = 1;
    this._isStopped = false;
    this._tracks = [];
    this._wasPlayingOnHidden = false;
    this._playbackRate = 1;
    this._audioContext = AudioContextFactory.create();
    let options;
    if (isSoundOptions(pathsOrSoundOption)) {
      options = pathsOrSoundOption[0];
    } else {
      options = {
        paths: pathsOrSoundOption
      };
    }
    this._resource = new Resource("", ExResponse.type.arraybuffer);
    const { volume, position, playbackRate, loop, bustCache, duration } = options;
    this.volume = volume != null ? volume : this.volume;
    this.playbackRate = playbackRate != null ? playbackRate : this.playbackRate;
    this.loop = loop != null ? loop : this.loop;
    this.duration = duration != null ? duration : this.duration;
    this.bustCache = bustCache != null ? bustCache : this.bustCache;
    this.position = position != null ? position : this.position;
    for (const path of options.paths) {
      if (canPlayFile(path)) {
        this.path = path;
        break;
      }
    }
    if (!this.path) {
      this.logger.warn("This browser does not support any of the audio files specified:", options.paths.join(", "));
      this.logger.warn("Attempting to use", options.paths[0]);
      this.path = options.paths[0];
    }
  }
  /**
   * Indicates whether the clip should loop when complete
   * @param value  Set the looping flag
   */
  set loop(value) {
    this._loop = value;
    for (const track of this._tracks) {
      track.loop = this._loop;
    }
    this.logger.debug("Set loop for all instances of sound", this.path, "to", this._loop);
  }
  get loop() {
    return this._loop;
  }
  set volume(value) {
    this._volume = value;
    for (const track of this._tracks) {
      track.volume = this._volume;
    }
    this.events.emit("volumechange", new NativeSoundEvent(this));
    this.logger.debug("Set loop for all instances of sound", this.path, "to", this._volume);
  }
  get volume() {
    return this._volume;
  }
  /**
   * Get the duration that this audio should play. If unset the total natural playback duration will be used.
   */
  get duration() {
    return this._duration;
  }
  /**
   * Set the duration that this audio should play. If unset the total natural playback duration will be used.
   *
   * Note: if you seek to a specific point the duration will start from that point, for example
   *
   * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.
   */
  set duration(duration) {
    this._duration = duration;
  }
  /**
   * Return array of Current AudioInstances playing or being paused
   */
  get instances() {
    return this._tracks;
  }
  get path() {
    return this._resource.path;
  }
  set path(val) {
    this._resource.path = val;
  }
  /**
   * Should excalibur add a cache busting querystring? By default false.
   * Must be set before loading
   */
  get bustCache() {
    return this._resource.bustCache;
  }
  set bustCache(val) {
    this._resource.bustCache = val;
  }
  isLoaded() {
    return !!this.data;
  }
  async load() {
    var _a, _b;
    if (this.data) {
      return this.data;
    }
    const arraybuffer = await this._resource.load();
    const audiobuffer = await this.decodeAudio(arraybuffer.slice(0));
    this._duration = (_b = (_a = this._duration) != null ? _a : audiobuffer == null ? void 0 : audiobuffer.duration) != null ? _b : void 0;
    this.events.emit("processed", new NativeSoundProcessedEvent(this, audiobuffer));
    return this.data = audiobuffer;
  }
  async decodeAudio(data) {
    try {
      return await this._audioContext.decodeAudioData(data.slice(0));
    } catch (e) {
      this.logger.error(
        "Unable to decode  this browser may not fully support this format, or the file may be corrupt, if this is an mp3 try removing id3 tags and album art from the file."
      );
      return await Promise.reject();
    }
  }
  wireEngine(engine) {
    if (engine) {
      this._engine = engine;
      this._engine.on("hidden", () => {
        if (engine.pauseAudioWhenHidden && this.isPlaying()) {
          this._wasPlayingOnHidden = true;
          this.pause();
        }
      });
      this._engine.on("visible", () => {
        if (engine.pauseAudioWhenHidden && this._wasPlayingOnHidden) {
          this.play();
          this._wasPlayingOnHidden = false;
        }
      });
      this._engine.on("start", () => {
        this._isStopped = false;
      });
      this._engine.on("stop", () => {
        this.stop();
        this._isStopped = true;
      });
    }
  }
  /**
   * Returns how many instances of the sound are currently playing
   */
  instanceCount() {
    return this._tracks.length;
  }
  /**
   * Whether or not the sound is playing right now
   */
  isPlaying() {
    return this._tracks.some((t) => t.isPlaying());
  }
  isPaused() {
    return this._tracks.some((t) => t.isPaused());
  }
  isStopped() {
    return this._tracks.some((t) => t.isStopped());
  }
  /**
   * Play the sound, returns a promise that resolves when the sound is done playing
   * An optional volume argument can be passed in to play the sound. Max volume is 1.0
   */
  play(volume) {
    if (!this.isLoaded()) {
      this.logger.warn("Cannot start playing. Resource", this.path, "is not loaded yet");
      return Promise.resolve(true);
    }
    if (this._isStopped) {
      this.logger.warn("Cannot start playing. Engine is in a stopped state.");
      return Promise.resolve(false);
    }
    this.volume = volume != null ? volume : this.volume;
    if (this.isPaused()) {
      return this._resumePlayback();
    } else {
      if (this.position) {
        this.seek(this.position);
      }
      return this._startPlayback();
    }
  }
  /**
   * Stop the sound, and do not rewind
   */
  pause() {
    if (!this.isPlaying()) {
      return;
    }
    for (const track of this._tracks) {
      track.pause();
    }
    this.events.emit("pause", new NativeSoundEvent(this));
    this.logger.debug("Paused all instances of sound", this.path);
  }
  /**
   * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.
   */
  stop() {
    for (const track of this._tracks) {
      track.stop();
    }
    this.events.emit("stop", new NativeSoundEvent(this));
    this._tracks.length = 0;
    this.logger.debug("Stopped all instances of sound", this.path);
  }
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(playbackRate) {
    this._playbackRate = playbackRate;
    this._tracks.forEach((t) => {
      t.playbackRate = this._playbackRate;
    });
  }
  seek(position, trackId = 0) {
    if (this._tracks.length === 0) {
      this._getTrackInstance(this.data);
    }
    this._tracks[trackId].seek(position);
  }
  getTotalPlaybackDuration() {
    if (!this.isLoaded()) {
      this.logger.warnOnce(
        `Sound from ${this.path} is not loaded, cannot return total playback duration.Did you forget to add Sound to a loader? https://excaliburjs.com/docs/loaders/`
      );
      return 0;
    }
    return this.data.duration;
  }
  /**
   * Return the current playback time of the playing track in seconds from the start.
   *
   * Optionally specify the track to query if multiple are playing at once.
   * @param trackId
   */
  getPlaybackPosition(trackId = 0) {
    if (this._tracks.length) {
      return this._tracks[trackId].getPlaybackPosition();
    }
    return 0;
  }
  /**
   * Get Id of provided AudioInstance in current trackList
   * @param track {@apilink Audio} which Id is to be given
   */
  getTrackId(track) {
    return this._tracks.indexOf(track);
  }
  async _resumePlayback() {
    if (this.isPaused()) {
      const resumed = [];
      for (const track of this._tracks) {
        resumed.push(
          track.play().then(() => {
            this._tracks.splice(this.getTrackId(track), 1);
            return true;
          })
        );
      }
      this.events.emit("resume", new NativeSoundEvent(this));
      this.logger.debug("Resuming paused instances for sound", this.path, this._tracks);
      await Promise.all(resumed);
    }
    return true;
  }
  /**
   * Starts playback, returns a promise that resolves when playback is complete
   */
  async _startPlayback() {
    const track = this._getTrackInstance(this.data);
    const complete = await track.play(() => {
      this.events.emit("playbackstart", new NativeSoundEvent(this, track));
      this.logger.debug("Playing new instance for sound", this.path);
    });
    this.events.emit("playbackend", new NativeSoundEvent(this, track));
    const trackId = this.getTrackId(track);
    if (trackId !== -1) {
      this._tracks.splice(trackId, 1);
    }
    return complete;
  }
  _getTrackInstance(data) {
    var _a;
    const newTrack = new WebAudioInstance(data);
    newTrack.loop = this.loop;
    newTrack.volume = this.volume;
    newTrack.duration = (_a = this.duration) != null ? _a : 0;
    newTrack.playbackRate = this._playbackRate;
    this._tracks.push(newTrack);
    return newTrack;
  }
  emit(eventName, event) {
    this.events.emit(eventName, event);
  }
  on(eventName, handler) {
    return this.events.on(eventName, handler);
  }
  once(eventName, handler) {
    return this.events.once(eventName, handler);
  }
  off(eventName, handler) {
    this.events.off(eventName, handler);
  }
}
const LoaderEvents = {
  // Add event types here
  BeforeLoad: "beforeload",
  AfterLoad: "afterload",
  UserAction: "useraction",
  LoadResourceStart: "loadresourcestart",
  LoadResourceEnd: "loadresourceend"
};
function isLoaderConstructor(x) {
  var _a, _b;
  return !!(x == null ? void 0 : x.prototype) && !!((_b = (_a = x == null ? void 0 : x.prototype) == null ? void 0 : _a.constructor) == null ? void 0 : _b.name);
}
class DefaultLoader {
  /**
   * @param options Optionally provide the list of resources you want to load at constructor time
   */
  constructor(options) {
    this.events = new EventEmitter();
    this.canvas = new Canvas({
      filtering: ImageFiltering.Blended,
      smoothing: true,
      cache: false,
      draw: this.onDraw.bind(this)
    });
    this._resources = [];
    this._numLoaded = 0;
    this._totalTimeMs = 0;
    this._loadingFuture = new Future();
    var _a;
    if (options && ((_a = options.loadables) == null ? void 0 : _a.length)) {
      this.addResources(options.loadables);
    }
  }
  get resources() {
    return this._resources;
  }
  /**
   * Called by the engine before loading
   * @param engine
   */
  onInitialize(engine) {
    this.engine = engine;
    this.canvas.width = this.engine.screen.resolution.width;
    this.canvas.height = this.engine.screen.resolution.height;
  }
  /**
   * Return a promise that resolves when the user interacts with the loading screen in some way, usually a click.
   *
   * It's important to implement this in order to unlock the audio context in the browser. Browsers automatically prevent
   * audio from playing until the user performs an action.
   *
   */
  async onUserAction() {
    return await Promise.resolve();
  }
  /**
   * Overridable lifecycle method, called directly before loading starts
   */
  async onBeforeLoad() {
  }
  /**
   * Overridable lifecycle method, called after loading has completed
   */
  async onAfterLoad() {
    await delay(500, this.engine.clock);
  }
  /**
   * Add a resource to the loader to load
   * @param loadable  Resource to add
   */
  addResource(loadable) {
    this._resources.push(loadable);
  }
  /**
   * Add a list of resources to the loader to load
   * @param loadables  The list of resources to load
   */
  addResources(loadables) {
    let i = 0;
    const len = loadables.length;
    for (i; i < len; i++) {
      this.addResource(loadables[i]);
    }
  }
  markResourceComplete() {
    this._numLoaded++;
  }
  /**
   * Returns the progress of the loader as a number between [0, 1] inclusive.
   */
  get progress() {
    const total = this._resources.length;
    return total > 0 ? clamp(this._numLoaded, 0, total) / total : 1;
  }
  /**
   * Returns true if the loader has completely loaded all resources
   */
  isLoaded() {
    return this._numLoaded === this._resources.length;
  }
  /**
   * Optionally override the onUpdate
   * @param engine
   * @param elapsed
   */
  onUpdate(engine, elapsed) {
    this._totalTimeMs += elapsed;
  }
  /**
   * Optionally override the onDraw
   */
  onDraw(ctx) {
    const seconds = this._totalTimeMs / 1e3;
    ctx.fillStyle = Color.Black.toRGBA();
    ctx.fillRect(0, 0, this.engine.screen.resolution.width, this.engine.screen.resolution.height);
    ctx.save();
    ctx.translate(this.engine.screen.resolution.width / 2, this.engine.screen.resolution.height / 2);
    const speed = seconds * 10;
    ctx.strokeStyle = "white";
    ctx.lineWidth = 10;
    ctx.lineCap = "round";
    ctx.arc(0, 0, 40, speed, speed + Math.PI * 3 / 2);
    ctx.stroke();
    ctx.fillStyle = "white";
    ctx.font = "16px sans-serif";
    const text = (this.progress * 100).toFixed(0) + "%";
    const textbox = ctx.measureText(text);
    const width = Math.abs(textbox.actualBoundingBoxLeft) + Math.abs(textbox.actualBoundingBoxRight);
    const height = Math.abs(textbox.actualBoundingBoxAscent) + Math.abs(textbox.actualBoundingBoxDescent);
    ctx.fillText(text, -width / 2, height / 2);
    ctx.restore();
  }
  areResourcesLoaded() {
    if (this._resources.length === 0) {
      return Promise.resolve();
    }
    return this._loadingFuture.promise;
  }
  /**
   * Not meant to be overridden
   *
   * Begin loading all of the supplied resources, returning a promise
   * that resolves when loading of all is complete AND the user has interacted with the loading screen
   */
  async load() {
    await this.onBeforeLoad();
    this.events.emit("beforeload");
    this.canvas.flagDirty();
    await Promise.all(
      this._resources.map(async (r) => {
        this.events.emit("loadresourcestart", r);
        await r.load().finally(() => {
          this._numLoaded++;
          this.canvas.flagDirty();
          this.events.emit("loadresourceend", r);
        });
      })
    );
    for (const resource of this._resources) {
      if (resource instanceof Sound) {
        resource.wireEngine(this.engine);
      }
    }
    this._loadingFuture.resolve();
    this.canvas.flagDirty();
    await this.onUserAction();
    this.events.emit("useraction");
    await WebAudio.unlock();
    await this.onAfterLoad();
    this.events.emit("afterload");
    return this.data = this._resources;
  }
  emit(eventName, event) {
    this.events.emit(eventName, event);
  }
  on(eventName, handler) {
    return this.events.on(eventName, handler);
  }
  once(eventName, handler) {
    return this.events.once(eventName, handler);
  }
  off(eventName, handler) {
    this.events.off(eventName, handler);
  }
}
const logoImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAB2CAYAAABxhGI9AAAACXBIWXMAAAsSAAALEgHS3X78AAAKnUlEQVR42u3dP2wjSx0H8N8hJIonIRmJjsq0SBR+BQ1dcqKhe0lD77SvSwpKkJKGPulpktfRIMUdEqKIqV57rpAokM4dbSiyq7ONPTP7x39ifz7SFbnEnp3xer47O7uzH15fXwMA6OYHmgAABCoACFQAEKgAgEAFAIEKAAIVAAQqACBQAUCgAoBABQCBCgAIVAAQqAAgUAFAoAIAAhUABCoACFQAEKgAgECFLbmOiNeFf2PbAyz68Pr6qhUgbRwR92v+/zwiJrYHMEKFMmcN///UtgcQqFBk1PD/97U9Qx8VCFSgu4EmAIEKAAIVAAQqACBQ4Z25jojP8eX+0WtNAgIVaOY+Im5j+eKh24h41jQgUIEyZ7F5NaPU7wCBCiwYd/w9cOB+qAlgJ3KLLow0EV198803RWvJfvfddx+0lhEqHKu5JgAjVCBvlhmFzjQRXUekHz9+TP79y8uLRjNChXfvoePvAYEKxNtj1e42/O5JoIJABcrdRMRVLM+X3kTEpaaB988cKuzWg9EobTWdMx0Oly8uN4dqhAoARqgnaN3arHfqu7OyH8ItKLVB/P+CEfMTHyGPY3npx1m8zWGDEeoBfUk/xdti57dr/r1Wv2+6EPow3tZ5rRdS72s1neuF97xvWd+XTH0/V+UMttDWqbI/r2nrxfp+jv2uSjSO7S+OXy/A/3lN+9xX5T5HxEUPZZ0tfB71+w57eJ/HFu+z+jkv1u92YX9fbI/HhX3JA9rp5MPr66tWaG9UfUGbrHIzi7cLUyYFf/tpTady03EEeL8mUJ6i7MKYNvWNqr4Pe2jradXO60LrvPAz2PQ5RPX684ah8dxD+2zantnCgVipSVV+m/tgB9W2DDq2Sx/vM95wcHhZhWVJm8yrv58cSgfTdc70+++/X/r522+/tUKSEepBqo+om4ZLPerMjUwuNnQCtx1GWJtee1FwdD5uWd86xLs8UaVt2aNEO1/saZ/Z5rYMW4zq6v34rGV9Bg3q2eZ9SkeNm9qwyUh30OPIHYFKx5FG03C7znSOqYBq+qW/zpQ3anH037TNHluG6f0WPsPhHvab4QFty7ogOeuxDYcNy2/zu2214WNYWxmBurNO8bGn97pNBOO8xy/9uCorZZ4I2r4C7aJgO7ZV9iE49Dm6NvOWx+pWE9CUq3zbdTp9doz38TbXtzqH9RT5CyWe422OaZoZGeZCabrhPQY9HjwsjpTvCg4YtlE2+Ta/j2bzn8fqrDqgm+6yUHOmAvWUjAtGhbNYvsBknDnqH1Qhc7VmxHgeb/NbudA5j/UXlYwif2p6luhAc9teu1npiHKnDs8if6tCm7JLX3NKpgttXe9ruc9mHMd7a83iwdxF5vt8tutARaCeklRnNK9C8WnNF7geJQ4T4XG3JhSnVdilQrG+yOnrlVHfsEGYzhNBn7Lu6tS7+HJafJQ4EMiNlNqWXZ9WPvVgnVYHG5M1ByDXkT6leX2EgTqJtyt45yv7S2qO3sEZjZhDLXeR+YKdJ0Zdk8QocvH9N732KrNtq+FZ/zzIHABcJrYpd+Xv14lOd5ap76SgrduW/VTQ1qcQpqnbgu4ifZvUMNpd9XuoZmvCtPaQ2Y/BCHVLgbrJTeRPDdVf6pfMKDU2fOkHmVFFfXr3MsouLsnNvV5kRoe5+s431PeuoKPqWnaurY/ZPBEeqwceN4l96iwO6H7Mjq4y7VGPVNe10VaZMzVCPVWpI/Z6FZbcv5fMqGCU+dLfFGzj58jP8+bCdJCo7yzKTwdOF0bu9Ug7V4c+yz7FJfYeGoysUss0HssIdVZwYLDujMqlESoCdTtGsZtbHnJBeNdDSJSs0jTKdMJN1HNX54Wv7bvsU9NkVJVa13dX+/wuArV0X/l5RHyo/lnfF4G6p6DrS0kHdtXhy35TGErDPYZUn2WfWqDOo/lVqdMD2O/hKJhD7S/odukymq9s02QN4EEPR/zbaOumZc+r15zK1Zqznl9jsfiemTM1QmV3HUuTkedlg9HIQzRbUD93dfC+2tpj2fIHEH2+RqCCQH13gZq7hWXTNpVu19OB1fc9nQ0AKOKUb5lU0P1kDyOneoWk0lOZ9cIP0x7qu8+2BhCoR2wYu1+e7DmaXzBSsu5vaX1ne2zrpmUPTmxf7PM1Dm4y/vC7ny7Nif7+z/9ZmtM0Z3panPLtPmra9f16bcK0Dpbnwk43Vd/RHtu6zfNQTy1QBy3aqG2g9nVmxml+BOoJyT3NpWmn9xhfFnu4bvDa+44BXhqqfdf3uUF9+yz77AT31Yue2mjecYQ62NLfgkA9ghHqLNEhNem4H1c6vdyDxhf/bpz5m4coW/c39wi6VH2bPtHlcaV9cvXts+zxCe6rTeqc2ndL7uGd93QwM9bFcAzMoZZ7SgTBbWx+asui61h/iq1+RmjqdbnQXQ3T1DNQ63V/U9ucqm/pMzPb1rePsk/1iTOjgvatR4W3Lc8ULB78pELyrnAfeTcj1NU509/86mfJ33/8+Mf00a05UyPUEw7UVCeWG/WNEiExyHRMt5ltW30izUPk18ytt7lNfc8i//DvtvXto+ySA5BjljsLUF8lPkqMPEtW1JomDsiGBZ9Byb4NAvUITSN9GuwsIj6t6UTOqk7jJREkmzqli8xIs96udSO20sX0H1vW92IL9e1a9rgqVyf91gbPsTy9UD9n9lOkT8k+RfkFR5PMNqxOcdSf32PBvg3vilO+zdxE+okx9Wm0ph36XYsRZCpMF993GOk5qvqB3Dct6jvssb67KvuUNJ3frw92bhr8/STSF0JdRPMLpUCgnsgo9S76PZ246ZFk1wWvK5m3vVoYvW1Sz7nN91jfXbQ1ZQc7TW6HeaoOalypG/8/p/rP1aNAc6ZHzSnfdqPUPhdy2PQw6Nz9gSVhuhiqueUHR3uu7y7K3rdDX4u46ZrPbUa0IFBZ0seKQ3XQTRt2vm3W/a2DbNKys++rvm3ep6+y1x2UdP3bWU9lzra47U1GmlctX/sQ23t+aOlByLTh/4NAPaCRxtcdO5HLSJ/6vNtCwGx67VPmPbvWd1q9frKHtp4kAqRJ2HR9j762JfX3bZ//elPtj13PPDx1+D5tqk/Xi6NO8SHz7MmH19dXrdBNfVFP6T2PT1UHNit87/t4m5+aRH+nQBdvqyhZDKJLfZs8h7XPsqdV2ZOV+tanKB8aln0dyxdAXbV4j4gvt4oMOrbP6vbU73NW7TMlbdTnPrWpfqXfh9HKZ9vke7KuTeZRNtXRSe6+1FV//ce/ln5eXfsXgcqXzr6+9261M3moOoa7E6nvTZTfy7iNsmfb7kjfgXGsvxe0vihsEts9HTquPpt1q1vtahu2TqAiUAEEKj0zhwoARqgAu/OnX/442WH+9xc/Wvr58re/Tr7f41/+ZsRqhAoACFQAEKgAcHjMoQJskJsz/eqrr5Z+vvr7v5fmQFevAl5lztQIFQAQqAAgUAHgIJlDBdhgdQ41N2eKESoAIFABQKACwFEwhwoARqgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAEKgAgUAFAoAKAQAUAgQoACFQAEKgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAQqAAgUAFAoAKAQAUAlvwPcFDns1DsH4sAAAAASUVORK5CYII=";
const loaderCss = "/* Buttons styles start */\n\nbutton#excalibur-play {\n  display: inline-block;\n  position: relative;\n  z-index: 999;\n  border-radius: 6px;\n  border: none;\n  /*border: 3px solid;\n    border-color: white;\n    box-shadow: 0 0 10px #ccc;*/\n  padding: 1rem 1.5rem 1rem 4rem;\n  margin: 0;\n  text-decoration: none;\n  background: #00b233;\n  color: #ffffff;\n  font-family: sans-serif;\n  font-size: 2rem;\n  white-space: nowrap;\n  line-height: 1;\n  cursor: pointer;\n  text-align: center;\n  transition:\n    background 250ms ease-in-out,\n    transform 150ms ease;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\n  animation: excalibur-button-fadein 200ms;\n}\n\n/*\nbutton#excalibur-play {\n  display: none;\n}*/\n\nbutton#excalibur-play:after {\n  position: absolute;\n  content: '';\n  border: 8px solid;\n  border-color: transparent transparent transparent white;\n  left: 35px;\n  top: 24px;\n  width: 0;\n  height: 0;\n}\n\nbutton#excalibur-play:before {\n  position: absolute;\n  content: '';\n  border: 3px solid;\n  left: 19px;\n  top: 14px;\n  border-radius: 20px;\n  width: 30px;\n  height: 30px;\n}\n\nbutton#excalibur-play:hover,\nbutton#excalibur-play:focus {\n  background: #00982c;\n}\n\nbutton#excalibur-play:focus {\n  outline: 1px solid #fff;\n  outline-offset: -4px;\n}\n\nbutton#excalibur-play:active {\n  transform: scale(0.99);\n}\n\n@keyframes excalibur-button-fadein {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n/* Firefox < 16 */\n@-moz-keyframes excalibur-button-fadein {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n/* Safari, Chrome and Opera > 12.1 */\n@-webkit-keyframes excalibur-button-fadein {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n/* Internet Explorer */\n@-ms-keyframes excalibur-button-fadein {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n/* Opera < 12.1 */\n@-o-keyframes excalibur-button-fadein {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n";
const _Loader = class _Loader2 extends DefaultLoader {
  constructor(loadablesOrOptions) {
    const options = Array.isArray(loadablesOrOptions) ? {
      loadables: loadablesOrOptions
    } : loadablesOrOptions;
    super(options);
    this._logger = Logger.getInstance();
    this._originalOptions = { loadables: [] };
    this.events = new EventEmitter();
    this._playButtonShown = false;
    this.logo = logoImg;
    this.logoWidth = 468;
    this.logoHeight = 118;
    this.loadingBarColor = Color.White;
    this.backgroundColor = "#176BAA";
    this._imageLoaded = new Future();
    this.suppressPlayButton = false;
    this._playButtonStyles = loaderCss;
    this.playButtonText = "Play game";
    this.startButtonFactory = () => {
      let buttonElement = document.getElementById("excalibur-play");
      if (!buttonElement) {
        buttonElement = document.createElement("button");
      }
      buttonElement.id = "excalibur-play";
      buttonElement.textContent = this.playButtonText;
      buttonElement.style.display = "none";
      return buttonElement;
    };
    this._originalOptions = { ..._Loader2._DEFAULT_LOADER_OPTIONS, ...options };
  }
  get _image() {
    if (!this._imageElement) {
      this._imageElement = new Image();
      this._imageElement.onload = () => this._imageLoaded.resolve();
      this._imageElement.src = this.logo;
    }
    return this._imageElement;
  }
  get playButtonRootElement() {
    return this._playButtonRootElement;
  }
  get playButtonElement() {
    return this._playButtonElement;
  }
  get _playButton() {
    const existingRoot = document.getElementById("excalibur-play-root");
    if (existingRoot) {
      this._playButtonRootElement = existingRoot;
    }
    if (!this._playButtonRootElement) {
      this._playButtonRootElement = document.createElement("div");
      this._playButtonRootElement.id = "excalibur-play-root";
      this._playButtonRootElement.style.position = "absolute";
      document.body.appendChild(this._playButtonRootElement);
    }
    if (!this._styleBlock) {
      this._styleBlock = document.createElement("style");
      this._styleBlock.textContent = this._playButtonStyles;
      document.head.appendChild(this._styleBlock);
    }
    if (!this._playButtonElement) {
      this._playButtonElement = this.startButtonFactory();
      this._playButtonRootElement.appendChild(this._playButtonElement);
    }
    return this._playButtonElement;
  }
  onInitialize(engine) {
    this.engine = engine;
    this.screen = engine.screen;
    this.canvas.width = this.engine.canvas.width;
    this.canvas.height = this.engine.canvas.height;
    this.screen.events.on("resize", () => {
      this.canvas.width = this.engine.canvas.width;
      this.canvas.height = this.engine.canvas.height;
    });
  }
  /**
   * Shows the play button and returns a promise that resolves when clicked
   */
  async showPlayButton() {
    var _a, _b;
    if (this.suppressPlayButton) {
      this.hidePlayButton();
      await delay(500, (_a = this.engine) == null ? void 0 : _a.clock);
    } else {
      const resizeHandler = () => {
        try {
          this._positionPlayButton();
        } catch (e) {
        }
      };
      if ((_b = this.engine) == null ? void 0 : _b.browser) {
        this.engine.browser.window.on("resize", resizeHandler);
      }
      this._playButtonShown = true;
      this._playButton.style.display = "block";
      document.body.addEventListener("keyup", (evt) => {
        if (evt.key === "Enter") {
          this._playButton.click();
        }
      });
      this._positionPlayButton();
      const playButtonClicked = new Promise((resolve) => {
        const startButtonHandler = (e) => {
          var _a2;
          e.stopPropagation();
          this.hidePlayButton();
          if ((_a2 = this.engine) == null ? void 0 : _a2.browser) {
            this.engine.browser.window.off("resize", resizeHandler);
          }
          if (this._originalOptions.fullscreenAfterLoad) {
            try {
              this._logger.info("requesting fullscreen");
              if (this._originalOptions.fullscreenContainer instanceof HTMLElement) {
                this._originalOptions.fullscreenContainer.requestFullscreen();
              } else {
                this.engine.screen.enterFullscreen(this._originalOptions.fullscreenContainer);
              }
            } catch (error) {
              this._logger.error("could not go fullscreen", error);
            }
          }
          resolve();
        };
        this._playButton.addEventListener("click", startButtonHandler);
        this._playButton.addEventListener("touchend", startButtonHandler);
        this._playButton.addEventListener("pointerup", startButtonHandler);
        if (this.engine) {
          this.engine.input.gamepads.once("button", () => startButtonHandler(new Event("button")));
        }
      });
      return await playButtonClicked;
    }
  }
  hidePlayButton() {
    this._playButtonShown = false;
    this._playButton.style.display = "none";
  }
  /**
   * Clean up generated elements for the loader
   */
  dispose() {
    if (this._playButtonRootElement.parentElement) {
      this._playButtonRootElement.removeChild(this._playButtonElement);
      document.body.removeChild(this._playButtonRootElement);
      document.head.removeChild(this._styleBlock);
      this._playButtonRootElement = null;
      this._playButtonElement = null;
      this._styleBlock = null;
    }
  }
  async onUserAction() {
    var _a;
    await delay(200, (_a = this.engine) == null ? void 0 : _a.clock);
    this.canvas.flagDirty();
    await this.showPlayButton();
  }
  async onBeforeLoad() {
    this.screen.pushResolutionAndViewport();
    this.screen.resolution = { width: this.canvas.width, height: this.canvas.height };
    this.screen.applyResolutionAndViewport();
    const image = this._image;
    await this._imageLoaded.promise;
    await (image == null ? void 0 : image.decode());
  }
  // eslint-disable-next-line require-await
  async onAfterLoad() {
    this.screen.popResolutionAndViewport();
    this.screen.applyResolutionAndViewport();
    this.dispose();
  }
  _positionPlayButton() {
    if (this.engine) {
      const { x: left, y: top, width: screenWidth, height: screenHeight } = this.engine.canvas.getBoundingClientRect();
      if (this._playButtonRootElement) {
        const buttonWidth = this._playButton.clientWidth;
        const buttonHeight = this._playButton.clientHeight;
        if (this.playButtonPosition) {
          this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`;
          this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`;
        } else {
          this._playButtonRootElement.style.left = `${left + screenWidth / 2 - buttonWidth / 2}px`;
          this._playButtonRootElement.style.top = `${top + screenHeight / 2 - buttonHeight / 2 + 100}px`;
        }
      }
    }
  }
  /**
   * Loader draw function. Draws the default Excalibur loading screen.
   * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties
   * to customize the drawing, or just override entire method.
   */
  onDraw(ctx) {
    const canvasHeight = this.engine.canvasHeight / this.engine.pixelRatio;
    const canvasWidth = this.engine.canvasWidth / this.engine.pixelRatio;
    this._positionPlayButton();
    ctx.fillStyle = this.backgroundColor;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    let logoY = canvasHeight / 2;
    const width = Math.min(this.logoWidth, canvasWidth * 0.75);
    let logoX = canvasWidth / 2 - width / 2;
    if (this.logoPosition) {
      logoX = this.logoPosition.x;
      logoY = this.logoPosition.y;
    }
    const imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth));
    const oldAntialias = this.engine.screen.antialiasing;
    this.engine.screen.antialiasing = true;
    if (!this.logoPosition) {
      ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY - imageHeight - 20, width, imageHeight);
    } else {
      ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY, width, imageHeight);
    }
    if (!this.suppressPlayButton && this._playButtonShown) {
      this.engine.screen.antialiasing = oldAntialias;
      return;
    }
    let loadingX = logoX;
    let loadingY = logoY;
    if (this.loadingBarPosition) {
      loadingX = this.loadingBarPosition.x;
      loadingY = this.loadingBarPosition.y;
    }
    ctx.lineWidth = 2;
    roundRect(ctx, loadingX, loadingY, width, 20, 10, this.loadingBarColor);
    const progress = width * this.progress;
    const margin = 5;
    const progressWidth = progress - margin * 2;
    const height = 20 - margin * 2;
    roundRect(
      ctx,
      loadingX + margin,
      loadingY + margin,
      progressWidth > 10 ? progressWidth : 10,
      height,
      5,
      null,
      this.loadingBarColor
    );
    this.engine.screen.antialiasing = oldAntialias;
  }
};
_Loader._DEFAULT_LOADER_OPTIONS = {
  loadables: [],
  fullscreenAfterLoad: false,
  fullscreenContainer: void 0
};
let Loader = _Loader;
const REPORTED_FEATURES = {
  webgl: "WebGL",
  webaudio: "WebAudio",
  gamepadapi: "Gamepad API"
};
class Detector {
  constructor() {
    this._features = null;
    this.failedTests = [];
    this._criticalTests = {
      // Test canvas/2d context support
      canvasSupport: function() {
        const elem = document.createElement("canvas");
        return !!(elem.getContext && elem.getContext("2d"));
      },
      // Test array buffer support ex uses for downloading binary data
      arrayBufferSupport: function() {
        const xhr = new XMLHttpRequest();
        xhr.open("GET", "/");
        try {
          xhr.responseType = "arraybuffer";
        } catch (e) {
          return false;
        }
        return xhr.responseType === "arraybuffer";
      },
      // Test data urls ex uses for sprites
      dataUrlSupport: function() {
        const canvas = document.createElement("canvas");
        return canvas.toDataURL("image/png").indexOf("data:image/png") === 0;
      },
      // Test object url support for loading
      objectUrlSupport: function() {
        return "URL" in window && "revokeObjectURL" in URL && "createObjectURL" in URL;
      },
      // RGBA support for colors
      rgbaSupport: function() {
        const style = document.createElement("a").style;
        style.cssText = "background-color:rgba(150,255,150,.5)";
        return ("" + style.backgroundColor).indexOf("rgba") > -1;
      }
    };
    this._warningTest = {
      webAudioSupport: function() {
        return !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext || window.oAudioContext);
      },
      webglSupport: function() {
        const elem = document.createElement("canvas");
        return !!(elem.getContext && elem.getContext("webgl"));
      }
    };
    this._features = this._loadBrowserFeatures();
  }
  /**
   * Returns a map of currently supported browser features. This method
   * treats the features as a singleton and will only calculate feature
   * support if it has not previously been done.
   */
  getBrowserFeatures() {
    if (this._features === null) {
      this._features = this._loadBrowserFeatures();
    }
    return this._features;
  }
  /**
   * Report on non-critical browser support for debugging purposes.
   * Use native browser console colors for visibility.
   */
  logBrowserFeatures() {
    let msg = "%cSUPPORTED BROWSER FEATURES\n==========================%c\n";
    const args = ["font-weight: bold; color: navy", "font-weight: normal; color: inherit"];
    const supported = this.getBrowserFeatures();
    for (const feature of Object.keys(REPORTED_FEATURES)) {
      if (supported[feature]) {
        msg += "(%c%c)";
        args.push("font-weight: bold; color: green");
        args.push("font-weight: normal; color: inherit");
      } else {
        msg += "(%c%c)";
        args.push("font-weight: bold; color: red");
        args.push("font-weight: normal; color: inherit");
      }
      msg += " " + REPORTED_FEATURES[feature] + "\n";
    }
    args.unshift(msg);
    console.log.apply(console, args);
  }
  /**
   * Executes several IIFE's to get a constant reference to supported
   * features within the current execution context.
   */
  _loadBrowserFeatures() {
    return {
      // IIFE to check canvas support
      canvas: (() => {
        return this._criticalTests.canvasSupport();
      })(),
      // IIFE to check arraybuffer support
      arraybuffer: (() => {
        return this._criticalTests.arrayBufferSupport();
      })(),
      // IIFE to check dataurl support
      dataurl: (() => {
        return this._criticalTests.dataUrlSupport();
      })(),
      // IIFE to check objecturl support
      objecturl: (() => {
        return this._criticalTests.objectUrlSupport();
      })(),
      // IIFE to check rgba support
      rgba: (() => {
        return this._criticalTests.rgbaSupport();
      })(),
      // IIFE to check webaudio support
      webaudio: (() => {
        return this._warningTest.webAudioSupport();
      })(),
      // IIFE to check webgl support
      webgl: (() => {
        return this._warningTest.webglSupport();
      })(),
      // IIFE to check gamepadapi support
      gamepadapi: (() => {
        return !!navigator.getGamepads;
      })()
    };
  }
  test() {
    let failedCritical = false;
    for (const test in this._criticalTests) {
      if (!this._criticalTests[test].call(this)) {
        this.failedTests.push(test);
        Logger.getInstance().error("Critical browser feature missing, Excalibur requires:", test);
        failedCritical = true;
      }
    }
    if (failedCritical) {
      return false;
    }
    for (const warning in this._warningTest) {
      if (!this._warningTest[warning]()) {
        Logger.getInstance().warn("Warning browser feature missing, Excalibur will have reduced performance:", warning);
      }
    }
    return true;
  }
}
function isScreenElement(actor) {
  return actor instanceof ScreenElement;
}
class ScreenElement extends Actor {
  constructor(config) {
    var _a, _b;
    super({ ...config });
    this.get(TransformComponent).coordPlane = CoordPlane.Screen;
    this.anchor = (_a = config == null ? void 0 : config.anchor) != null ? _a : vec(0, 0);
    this.body.collisionType = (_b = config == null ? void 0 : config.collisionType) != null ? _b : CollisionType.PreventCollision;
    this.pointer.useGraphicsBounds = true;
    this.pointer.useColliderShape = false;
    if (!(config == null ? void 0 : config.collider) && (config == null ? void 0 : config.width) > 0 && (config == null ? void 0 : config.height) > 0) {
      this.collider.useBoxCollider(this.width, this.height, this.anchor);
    }
  }
  _initialize(engine) {
    this._engine = engine;
    super._initialize(engine);
  }
  contains(x, y, useWorld = true) {
    if (useWorld) {
      return super.contains(x, y);
    }
    const coords = this._engine.worldToScreenCoordinates(new Vector(x, y));
    return super.contains(coords.x, coords.y);
  }
}
const _Timer = class _Timer2 {
  constructor(options) {
    this._logger = Logger.getInstance();
    this.id = 0;
    this._elapsedTime = 0;
    this._totalTimeAlive = 0;
    this._running = false;
    this._numberOfTicks = 0;
    this.interval = 10;
    this.repeats = false;
    this.maxNumberOfRepeats = -1;
    this.randomRange = [0, 0];
    this._baseInterval = 10;
    this._generateRandomInterval = () => {
      return this._baseInterval + this.random.integer(this.randomRange[0], this.randomRange[1]);
    };
    this._complete = false;
    this.scene = null;
    var _a;
    const fcn = (_a = options.action) != null ? _a : options.fcn;
    const interval = options.interval;
    const repeats = options.repeats;
    const numberOfRepeats = options.numberOfRepeats;
    const randomRange = options.randomRange;
    const random = options.random;
    if (!!numberOfRepeats && numberOfRepeats >= 0) {
      this.maxNumberOfRepeats = numberOfRepeats;
      if (!repeats) {
        throw new Error("repeats must be set to true if numberOfRepeats is set");
      }
    }
    this.id = _Timer2._MAX_ID++;
    this._callbacks = [];
    this._baseInterval = this.interval = interval;
    if (!!randomRange) {
      if (randomRange[0] > randomRange[1]) {
        throw new Error("min value must be lower than max value for range");
      }
      this.random = random != null ? random : new Random();
      this.randomRange = randomRange;
      this.interval = this._generateRandomInterval();
      this.on(() => {
        this.interval = this._generateRandomInterval();
      });
    }
    this.repeats = repeats || this.repeats;
    if (fcn) {
      this.on(fcn);
    }
  }
  get complete() {
    return this._complete;
  }
  /**
   * Adds a new callback to be fired after the interval is complete
   * @param action The callback to be added to the callback list, to be fired after the interval is complete.
   */
  on(action) {
    this._callbacks.push(action);
  }
  /**
   * Removes a callback from the callback list to be fired after the interval is complete.
   * @param action The callback to be removed from the callback list, to be fired after the interval is complete.
   */
  off(action) {
    const index = this._callbacks.indexOf(action);
    this._callbacks.splice(index, 1);
  }
  /**
   * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
   * @param elapsed  Number of elapsed milliseconds since the last update.
   */
  update(elapsed) {
    if (this._running) {
      this._totalTimeAlive += elapsed;
      this._elapsedTime += elapsed;
      if (this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats) {
        this._complete = true;
        this._running = false;
        this._elapsedTime = 0;
      }
      if (!this.complete && this._elapsedTime >= this.interval) {
        this._callbacks.forEach((c) => {
          c.call(this);
        });
        this._numberOfTicks++;
        if (this.repeats) {
          this._elapsedTime = 0;
        } else {
          this._complete = true;
          this._running = false;
          this._elapsedTime = 0;
        }
      }
    }
  }
  /**
   * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.
   *
   * Warning** you may need to call `timer.start()` again if the timer had completed
   * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback
   * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes
   */
  reset(newInterval, newNumberOfRepeats) {
    if (!!newInterval && newInterval >= 0) {
      this._baseInterval = this.interval = newInterval;
    }
    if (!!this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0) {
      this.maxNumberOfRepeats = newNumberOfRepeats;
      if (!this.repeats) {
        throw new Error("repeats must be set to true if numberOfRepeats is set");
      }
    }
    this._complete = false;
    this._elapsedTime = 0;
    this._numberOfTicks = 0;
  }
  get timesRepeated() {
    return this._numberOfTicks;
  }
  getTimeRunning() {
    return this._totalTimeAlive;
  }
  /**
   * @returns milliseconds until the next action callback, if complete will return 0
   */
  get timeToNextAction() {
    if (this.complete) {
      return 0;
    }
    return this.interval - this._elapsedTime;
  }
  /**
   * @returns milliseconds elapsed toward the next action
   */
  get timeElapsedTowardNextAction() {
    return this._elapsedTime;
  }
  get isRunning() {
    return this._running;
  }
  /**
   * Pauses the timer, time will no longer increment towards the next call
   */
  pause() {
    this._running = false;
    return this;
  }
  /**
   * Resumes the timer, time will now increment towards the next call.
   */
  resume() {
    this._running = true;
    return this;
  }
  /**
   * Starts the timer, if the timer was complete it will restart the timer and reset the elapsed time counter
   */
  start() {
    if (!this.scene) {
      this._logger.warn("Cannot start a timer not part of a scene, timer wont start until added");
    }
    this._running = true;
    if (this.complete) {
      this._complete = false;
      this._elapsedTime = 0;
      this._numberOfTicks = 0;
    }
    return this;
  }
  /**
   * Stops the timer and resets the elapsed time counter towards the next action invocation
   */
  stop() {
    this._running = false;
    this._elapsedTime = 0;
    this._numberOfTicks = 0;
    return this;
  }
  /**
   * Cancels the timer, preventing any further executions.
   */
  cancel() {
    this.pause();
    if (this.scene) {
      this.scene.cancelTimer(this);
    }
  }
};
_Timer._MAX_ID = 0;
let Timer = _Timer;
function hasNestedEvents(object) {
  return object && object._dispatchPointerEvents && object._processPointerToObject;
}
class PointerTargetObjectProxy {
  get events() {
    return this.object.events;
  }
  init(object, contains2, active) {
    this.object = object;
    this.contains = contains2;
    this.active = active;
  }
}
class PointerEventsToObjectDispatcher {
  constructor() {
    this._proxyPool = new RentalPool(
      () => new PointerTargetObjectProxy(),
      (p) => p,
      100
    );
    this._objectToProxy = /* @__PURE__ */ new Map();
    this._proxies = [];
    this._lastFrameObjectToPointers = /* @__PURE__ */ new Map();
    this._currentFrameObjectToPointers = /* @__PURE__ */ new Map();
  }
  /**
   * Tracks an object to associate with pointers and their events
   * @param object
   * @param contains
   * @param active
   */
  addObject(object, contains2, active) {
    const proxy = this._proxyPool.rent(false);
    proxy.init(object, contains2, active);
    this._proxies.push(proxy);
    this._objectToProxy.set(object, proxy);
  }
  _getProxy(object) {
    const proxy = this._objectToProxy.get(object);
    if (proxy) {
      return proxy;
    }
    throw new Error("No PointerTargetProxy for object");
  }
  /**
   * Untracks an object associated with pointers and their events
   * @param object
   */
  removeObject(object) {
    const proxy = this._objectToProxy.get(object);
    if (proxy) {
      const index = this._proxies.indexOf(proxy);
      this._objectToProxy.delete(object);
      if (index > -1) {
        this._proxies.splice(index, 1);
      }
      this._proxyPool.return(proxy);
    }
  }
  _objectCurrentlyUnderPointer(object, pointerId) {
    return !!(this._currentFrameObjectToPointers.has(object) && this._currentFrameObjectToPointers.get(object).includes(pointerId));
  }
  _objectWasUnderPointer(object, pointerId) {
    return !!(this._lastFrameObjectToPointers.has(object) && this._lastFrameObjectToPointers.get(object).includes(pointerId));
  }
  _entered(object, pointerId) {
    return this._objectCurrentlyUnderPointer(object, pointerId) && !this._lastFrameObjectToPointers.has(object);
  }
  _left(object, pointerId) {
    return !this._currentFrameObjectToPointers.has(object) && this._objectWasUnderPointer(object, pointerId);
  }
  /**
   * Manually associate a pointer id with an object.
   *
   * This assumes you've checked that the pointer is indeed over the object.
   */
  addPointerToObject(object, pointerId) {
    const maybeProxy = this._objectToProxy.get(object);
    if (maybeProxy) {
      this._addPointerToProxy(maybeProxy, pointerId);
    }
  }
  _addPointerToProxy(object, pointerId) {
    if (!this._currentFrameObjectToPointers.has(object)) {
      this._currentFrameObjectToPointers.set(object, [pointerId]);
      return;
    }
    const pointers = this._currentFrameObjectToPointers.get(object);
    this._currentFrameObjectToPointers.set(object, pointers.concat(pointerId));
  }
  /**
   * Dispatches the appropriate pointer events in sortedObject order on tracked objects
   * @param receiver
   * @param sortedObjects
   */
  dispatchEvents(receiver, sortedObjects) {
    const lastFrameEntities = new Set(this._lastFrameObjectToPointers.keys());
    const currentFrameEntities = new Set(this._currentFrameObjectToPointers.keys());
    let lastMovePerPointer;
    let lastUpPerPointer;
    let lastDownPerPointer;
    for (let i = 0; i < sortedObjects.length; i++) {
      const object = sortedObjects[i];
      const proxy = this._getProxy(object);
      if (hasNestedEvents(object)) {
        object._dispatchPointerEvents(receiver);
      }
      if (lastFrameEntities.has(proxy) || currentFrameEntities.has(proxy)) {
        lastDownPerPointer = this._processDownAndEmit(receiver, proxy);
        lastUpPerPointer = this._processUpAndEmit(receiver, proxy);
        lastMovePerPointer = this._processMoveAndEmit(receiver, proxy);
        const lastUpDownMoveEvents = [...lastMovePerPointer.values(), ...lastDownPerPointer.values(), ...lastUpPerPointer.values()];
        this._processEnterLeaveAndEmit(receiver, proxy, lastUpDownMoveEvents);
        this._processCancelAndEmit(receiver, proxy);
        this._processWheelAndEmit(receiver, proxy);
      }
    }
  }
  /**
   * Given the tracked objects, update pointer containment given the provided contains()
   * @param receiver
   * @param objects
   */
  processPointerToObject(receiver, objects) {
    for (let objectIndex = 0; objectIndex < objects.length; objectIndex++) {
      const object = objects[objectIndex];
      const proxy = this._getProxy(object);
      if (hasNestedEvents(object)) {
        object._processPointerToObject(receiver);
      }
      for (const [pointerId, pos] of receiver.currentFramePointerCoords.entries()) {
        if (proxy.contains(pos)) {
          this._addPointerToProxy(proxy, pointerId);
        }
      }
    }
  }
  /**
   * Clear current frames pointer-object associations and track last frame pointer-object associations
   */
  clear() {
    this._lastFrameObjectToPointers.clear();
    this._lastFrameObjectToPointers = new Map(this._currentFrameObjectToPointers);
    this._currentFrameObjectToPointers.clear();
  }
  _processDownAndEmit(receiver, object) {
    const lastDownPerPointer = /* @__PURE__ */ new Map();
    for (const event of receiver.currentFrameDown) {
      if (event.active && this._objectCurrentlyUnderPointer(object, event.pointerId)) {
        object.events.emit("pointerdown", event);
        if (receiver.isDragStart(event.pointerId)) {
          object.events.emit("pointerdragstart", event);
        }
      }
      lastDownPerPointer.set(event.pointerId, event);
    }
    return lastDownPerPointer;
  }
  _processUpAndEmit(receiver, object) {
    const lastUpPerPointer = /* @__PURE__ */ new Map();
    for (const event of receiver.currentFrameUp) {
      if (event.active && this._objectCurrentlyUnderPointer(object, event.pointerId)) {
        object.events.emit("pointerup", event);
        if (receiver.isDragEnd(event.pointerId)) {
          object.events.emit("pointerdragend", event);
        }
      }
      lastUpPerPointer.set(event.pointerId, event);
    }
    return lastUpPerPointer;
  }
  _processMoveAndEmit(receiver, object) {
    const lastMovePerPointer = /* @__PURE__ */ new Map();
    for (const event of receiver.currentFrameMove) {
      if (event.active && object.active() && this._objectCurrentlyUnderPointer(object, event.pointerId)) {
        object.events.emit("pointermove", event);
        if (receiver.isDragging(event.pointerId)) {
          object.events.emit("pointerdragmove", event);
        }
      }
      lastMovePerPointer.set(event.pointerId, event);
    }
    return lastMovePerPointer;
  }
  _processEnterLeaveAndEmit(receiver, object, lastUpDownMoveEvents) {
    for (const event of lastUpDownMoveEvents) {
      if (event.active && object.active() && this._entered(object, event.pointerId)) {
        object.events.emit("pointerenter", event);
        if (receiver.isDragging(event.pointerId)) {
          object.events.emit("pointerdragenter", event);
        }
        break;
      }
      if (event.active && object.active() && // leave can happen on move
      (this._left(object, event.pointerId) || // or leave can happen on pointer up
      this._objectCurrentlyUnderPointer(object, event.pointerId) && event.type === "up")) {
        object.events.emit("pointerleave", event);
        if (receiver.isDragging(event.pointerId)) {
          object.events.emit("pointerdragleave", event);
        }
        break;
      }
    }
  }
  _processCancelAndEmit(receiver, object) {
    for (const event of receiver.currentFrameCancel) {
      if (event.active && object.active() && this._objectCurrentlyUnderPointer(object, event.pointerId)) {
        object.events.emit("pointercancel", event);
      }
    }
  }
  _processWheelAndEmit(receiver, object) {
    for (const event of receiver.currentFrameWheel) {
      if (event.active && object.active() && this._objectCurrentlyUnderPointer(object, 0)) {
        object.events.emit("pointerwheel", event);
      }
    }
  }
}
const TileMapEvents = {
  PreUpdate: "preupdate",
  PostUpdate: "postupdate",
  PreDraw: "predraw",
  PostDraw: "postdraw",
  PointerUp: "pointerup",
  PointerDown: "pointerdown",
  PointerMove: "pointermove",
  PointerCancel: "pointercancel"
};
class TileMap extends Entity {
  /**
   * @param options
   */
  constructor(options) {
    var _a, _b, _c;
    super([], options.name);
    this.events = new EventEmitter();
    this._token = 0;
    this.logger = Logger.getInstance();
    this.tiles = [];
    this._rows = [];
    this._cols = [];
    this.renderFromTopOfGraphic = false;
    this.meshingLookBehind = 10;
    this._collidersDirty = true;
    this._oldRotation = 0;
    this._originalOffsets = /* @__PURE__ */ new WeakMap();
    this.meshingLookBehind = (_a = options.meshingLookBehind) != null ? _a : this.meshingLookBehind;
    this.addComponent(new TransformComponent());
    this.addComponent(new MotionComponent());
    this.addComponent(
      new BodyComponent({
        type: CollisionType.Fixed
      })
    );
    this.addComponent(
      new GraphicsComponent({
        onPostDraw: (ctx, elapsed) => this.draw(ctx, elapsed)
      })
    );
    this.addComponent(new DebugGraphicsComponent((ctx, debugFlags) => this.debug(ctx, debugFlags), false));
    this.addComponent(new ColliderComponent());
    this.addComponent(new PointerComponent());
    this.pointer = this.get(PointerComponent);
    this._graphics = this.get(GraphicsComponent);
    this.transform = this.get(TransformComponent);
    this._motion = this.get(MotionComponent);
    this.collider = this.get(ColliderComponent);
    this._composite = this.collider.useCompositeCollider([]);
    this.transform.pos = (_b = options.pos) != null ? _b : Vector.Zero;
    this._oldPos = this.transform.pos.clone();
    this._oldScale = this.transform.scale.clone();
    this.renderFromTopOfGraphic = (_c = options.renderFromTopOfGraphic) != null ? _c : this.renderFromTopOfGraphic;
    this.tileWidth = options.tileWidth;
    this.tileHeight = options.tileHeight;
    this.rows = options.rows;
    this.columns = options.columns;
    this._pointerEventDispatcher = new PointerEventsToObjectDispatcher();
    this.tiles = new Array(this.rows * this.columns);
    this._rows = new Array(this.rows);
    this._cols = new Array(this.columns);
    let currentCol = [];
    for (let i = 0; i < this.columns; i++) {
      for (let j = 0; j < this.rows; j++) {
        const tile = new Tile({
          x: i,
          y: j,
          map: this
        });
        tile.map = this;
        this.tiles[i + j * this.columns] = tile;
        this._pointerEventDispatcher.addObject(
          tile,
          (vec2) => {
            return tile.bounds.contains(vec2.worldPos);
          },
          () => true
        );
        currentCol.push(tile);
        if (!this._rows[j]) {
          this._rows[j] = [];
        }
        this._rows[j].push(tile);
      }
      this._cols[i] = currentCol;
      currentCol = [];
    }
    this._graphics.localBounds = new BoundingBox({
      left: 0,
      top: 0,
      right: this.columns * this.tileWidth * this.scale.x,
      bottom: this.rows * this.tileHeight * this.scale.y
    });
  }
  flagCollidersDirty() {
    this._collidersDirty = true;
  }
  flagTilesDirty() {
    for (let i = 0; i < this.tiles.length; i++) {
      if (this.tiles[i]) {
        this.tiles[i].flagDirty();
      }
    }
  }
  get x() {
    var _a;
    return (_a = this.transform.pos.x) != null ? _a : 0;
  }
  set x(val) {
    var _a;
    if ((_a = this.transform) == null ? void 0 : _a.pos) {
      this.get(TransformComponent).pos = vec(val, this.y);
    }
  }
  get y() {
    var _a, _b;
    return (_b = (_a = this.transform) == null ? void 0 : _a.pos.y) != null ? _b : 0;
  }
  set y(val) {
    var _a;
    if ((_a = this.transform) == null ? void 0 : _a.pos) {
      this.transform.pos = vec(this.x, val);
    }
  }
  get z() {
    var _a;
    return (_a = this.transform.z) != null ? _a : 0;
  }
  set z(val) {
    if (this.transform) {
      this.transform.z = val;
    }
  }
  get rotation() {
    var _a, _b;
    return (_b = (_a = this.transform) == null ? void 0 : _a.rotation) != null ? _b : 0;
  }
  set rotation(val) {
    if (this.transform) {
      if (val !== this.transform.rotation) {
        this.flagCollidersDirty();
        this.flagTilesDirty();
      }
      this.transform.rotation = val;
    }
  }
  get scale() {
    var _a, _b;
    return (_b = (_a = this.transform) == null ? void 0 : _a.scale) != null ? _b : Vector.One;
  }
  set scale(val) {
    if (this.transform) {
      if (!(val == null ? void 0 : val.equals(this.transform.scale))) {
        this.flagCollidersDirty();
        this.flagTilesDirty();
      }
      this.transform.scale = val;
    }
  }
  get pos() {
    return this.transform.pos;
  }
  set pos(val) {
    if (this.transform) {
      if (!(val == null ? void 0 : val.equals(this.transform.pos))) {
        this.flagCollidersDirty();
        this.flagTilesDirty();
      }
      this.transform.pos = val;
    }
  }
  get vel() {
    return this._motion.vel;
  }
  set vel(val) {
    this._motion.vel = val;
  }
  /**
   * Width of the whole tile map in pixels
   */
  get width() {
    return this.tileWidth * this.columns * this.scale.x;
  }
  /**
   * Height of the whole tilemap in pixels
   */
  get height() {
    return this.tileHeight * this.rows * this.scale.y;
  }
  emit(eventName, event) {
    this.events.emit(eventName, event);
  }
  on(eventName, handler) {
    return this.events.on(eventName, handler);
  }
  once(eventName, handler) {
    return this.events.once(eventName, handler);
  }
  off(eventName, handler) {
    this.events.off(eventName, handler);
  }
  _initialize(engine) {
    super._initialize(engine);
    this._engine = engine;
  }
  _getOrSetColliderOriginalOffset(collider) {
    var _a;
    if (!this._originalOffsets.has(collider)) {
      const originalOffset = collider.offset;
      this._originalOffsets.set(collider, originalOffset);
      return originalOffset;
    } else {
      return (_a = this._originalOffsets.get(collider)) != null ? _a : Vector.Zero;
    }
  }
  /**
   * Tiles colliders based on the solid tiles in the tilemap.
   */
  _updateColliders() {
    this.collider.$colliderRemoved.notifyAll(this._composite);
    this._composite.clearColliders();
    const colliders = [];
    this._composite = this.collider.useCompositeCollider([]);
    let current = null;
    const shareEdges = (prev, next) => {
      if (prev && next) {
        return prev.top === next.top && prev.bottom === next.bottom && // Shared right/left edge
        prev.right === next.left;
      }
      return false;
    };
    const checkAndCombine = (current2, colliders2, maxLookBack = this.meshingLookBehind) => {
      if (!current2) {
        return false;
      }
      for (let i = colliders2.length - 1; i >= 0; i--) {
        if (maxLookBack-- < 0) {
          return false;
        }
        const prev = colliders2[i];
        if (shareEdges(prev, current2)) {
          colliders2[i] = prev.combine(current2);
          return true;
        }
      }
      return false;
    };
    for (let i = 0; i < this.columns; i++) {
      for (let j = 0; j < this.rows; j++) {
        const tile = this.tiles[i + j * this.columns];
        if (tile.solid) {
          if (tile.getColliders().length > 0) {
            for (const collider of tile.getColliders()) {
              const originalOffset = this._getOrSetColliderOriginalOffset(collider);
              collider.offset = vec(tile.x * this.tileWidth * this.scale.x, tile.y * this.tileHeight * this.scale.y).add(originalOffset);
              collider.owner = this;
              this._composite.addCollider(collider);
            }
            if (current && !checkAndCombine(current, colliders)) {
              colliders.push(current);
            }
            current = null;
          } else {
            if (!current) {
              current = tile.defaultGeometry;
            } else {
              current = current.combine(tile.defaultGeometry);
            }
          }
        } else {
          if (current && !checkAndCombine(current, colliders)) {
            colliders.push(current);
          }
          current = null;
        }
      }
      if (current && !checkAndCombine(current, colliders)) {
        colliders.push(current);
      }
      current = null;
    }
    for (const c of colliders) {
      const collider = Shape.Box(c.width, c.height, Vector.Zero, vec(c.left - this.pos.x, c.top - this.pos.y));
      collider.owner = this;
      this._composite.addCollider(collider);
    }
    this.collider.update();
    this.collider.$colliderAdded.notifyAll(this._composite);
  }
  /**
   * Returns the {@apilink Tile} by index (row major order)
   *
   * Returns null if out of bounds
   */
  getTileByIndex(index) {
    var _a;
    return (_a = this.tiles[index]) != null ? _a : null;
  }
  /**
   * Returns the {@apilink Tile} by its x and y integer coordinates
   *
   * Returns null if out of bounds
   *
   * For example, if I want the tile in fifth column (x), and second row (y):
   * `getTile(4, 1)` 0 based, so 0 is the first in row/column
   */
  getTile(x, y) {
    if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {
      return null;
    }
    return this.tiles[x + y * this.columns];
  }
  /**
   * Returns the {@apilink Tile} by testing a point in world coordinates,
   * returns `null` if no Tile was found.
   */
  getTileByPoint(point2) {
    const { x, y } = this._getTileCoordinates(point2);
    const tile = this.getTile(x, y);
    if (x >= 0 && y >= 0 && x < this.columns && y < this.rows && tile) {
      return tile;
    }
    return null;
  }
  _getTileCoordinates(point2) {
    point2 = this.transform.applyInverse(point2);
    const x = Math.floor(point2.x / this.tileWidth);
    const y = Math.floor(point2.y / this.tileHeight);
    return { x, y };
  }
  getRows() {
    return this._rows;
  }
  getColumns() {
    return this._cols;
  }
  /**
   * Returns the on screen tiles for a tilemap, this will overshoot by a small amount because of the internal quad tree data structure.
   *
   * Useful if you need to perform specific logic on onscreen tiles
   */
  getOnScreenTiles() {
    const worldBounds = this._engine.screen.getWorldBounds();
    let parallaxOffset = vec(0, 0);
    let bounds = this.transform.coordPlane === CoordPlane.Screen ? this._engine.screen.getScreenBounds() : worldBounds;
    const maybeParallax = this.get(ParallaxComponent);
    if (maybeParallax && this.isInitialized) {
      const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);
      parallaxOffset = this._engine.currentScene.camera.pos.scale(oneMinusFactor);
      bounds = bounds.translate(parallaxOffset.negate());
    }
    const topLeft = this._getTileCoordinates(bounds.topLeft);
    const topRight = this._getTileCoordinates(bounds.topRight);
    const bottomRight = this._getTileCoordinates(bounds.bottomRight);
    const bottomLeft = this._getTileCoordinates(bounds.bottomLeft);
    const tileStartX = Math.min(clamp(topLeft.x, 0, this.columns - 1), clamp(topRight.x, 0, this.columns - 1));
    const tileStartY = Math.min(clamp(topLeft.y, 0, this.rows - 1), clamp(topRight.y, 0, this.rows - 1));
    const tileEndX = Math.max(clamp(bottomRight.x, 0, this.columns - 1), clamp(bottomLeft.x, 0, this.columns - 1));
    const tileEndY = Math.max(clamp(bottomRight.y, 0, this.rows - 1), clamp(bottomLeft.y, 0, this.rows - 1));
    const tiles = [];
    for (let x = tileStartX; x <= tileEndX; x++) {
      for (let y = tileStartY; y <= tileEndY; y++) {
        tiles.push(this.getTile(x, y));
      }
    }
    return tiles;
  }
  /**
   * @internal
   */
  _processPointerToObject(receiver) {
    this._pointerEventDispatcher.processPointerToObject(receiver, this.tiles);
  }
  /**
   * @internal
   */
  _dispatchPointerEvents(receiver) {
    this._pointerEventDispatcher.dispatchEvents(receiver, this.tiles);
  }
  update(engine, elapsed) {
    this._initialize(engine);
    this.onPreUpdate(engine, elapsed);
    this.emit("preupdate", new PreUpdateEvent(engine, elapsed, this));
    if (!this._oldPos.equals(this.pos) || this._oldRotation !== this.rotation || !this._oldScale.equals(this.scale)) {
      this.flagCollidersDirty();
      this.flagTilesDirty();
    }
    if (this._collidersDirty) {
      this._collidersDirty = false;
      this._updateColliders();
    }
    this._pointerEventDispatcher.clear();
    this._token++;
    this.pos.clone(this._oldPos);
    this._oldRotation = this.rotation;
    this.scale.clone(this._oldScale);
    this.transform.pos = this.pos;
    this.onPostUpdate(engine, elapsed);
    this.emit("postupdate", new PostUpdateEvent(engine, elapsed, this));
  }
  /**
   * Draws the tile map to the screen. Called by the {@apilink Scene}.
   * @param ctx ExcaliburGraphicsContext
   * @param elapsed  The number of milliseconds since the last draw
   */
  draw(ctx, elapsed) {
    if (!this.isInitialized) {
      return;
    }
    this.emit("predraw", new PreDrawEvent(ctx, elapsed, this));
    let graphics, graphicsIndex, graphicsLen;
    const tiles = this.getOnScreenTiles();
    for (let i = 0; i < tiles.length; i++) {
      const tile = tiles[i];
      const offsets = tile.getGraphicsOffsets();
      graphics = tile.getGraphics();
      for (graphicsIndex = 0, graphicsLen = graphics.length; graphicsIndex < graphicsLen; graphicsIndex++) {
        const graphic = graphics[graphicsIndex];
        const offset = offsets[graphicsIndex];
        if (graphic) {
          if (hasGraphicsTick(graphic)) {
            graphic == null ? void 0 : graphic.tick(elapsed, this._token);
          }
          const offsetY = this.renderFromTopOfGraphic ? 0 : graphic.height - this.tileHeight;
          graphic.draw(ctx, tile.x * this.tileWidth + offset.x, tile.y * this.tileHeight - offsetY + offset.y);
        }
      }
    }
    this.emit("postdraw", new PostDrawEvent(ctx, elapsed, this));
  }
  debug(gfx, debugFlags) {
    const {
      showAll,
      showGrid,
      gridColor,
      gridWidth,
      showSolidBounds: showColliderBounds,
      solidBoundsColor: colliderBoundsColor,
      showColliderGeometry
    } = debugFlags.tilemap;
    const { geometryColor, geometryLineWidth, geometryPointSize } = debugFlags.collider;
    const width = this.tileWidth * this.columns * this.scale.x;
    const height = this.tileHeight * this.rows * this.scale.y;
    const pos = this.pos;
    if (showGrid || showAll) {
      for (let r = 0; r < this.rows + 1; r++) {
        const yOffset = vec(0, r * this.tileHeight * this.scale.y);
        gfx.drawLine(pos.add(yOffset), pos.add(vec(width, yOffset.y)), gridColor, gridWidth);
      }
      for (let c = 0; c < this.columns + 1; c++) {
        const xOffset = vec(c * this.tileWidth * this.scale.x, 0);
        gfx.drawLine(pos.add(xOffset), pos.add(vec(xOffset.x, height)), gridColor, gridWidth);
      }
    }
    if (showAll || showColliderBounds || showColliderGeometry) {
      const colliders = this._composite.getColliders();
      gfx.save();
      gfx.translate(this.pos.x, this.pos.y);
      gfx.scale(this.scale.x, this.scale.y);
      for (const collider of colliders) {
        const bounds = collider.localBounds;
        const pos2 = collider.worldPos.sub(this.pos);
        if (showColliderBounds) {
          gfx.drawRectangle(pos2, bounds.width, bounds.height, colliderBoundsColor);
        }
      }
      gfx.restore();
      if (showColliderGeometry) {
        for (const collider of colliders) {
          collider.debug(gfx, geometryColor, { lineWidth: geometryLineWidth, pointSize: geometryPointSize });
        }
      }
    }
    if (showAll || showColliderBounds) {
      gfx.save();
      gfx.z = 999;
      if (showColliderBounds) {
        for (let i = 0; i < this.tiles.length; i++) {
          this.tiles[i].bounds.draw(gfx);
        }
      }
      gfx.restore();
    }
  }
}
class Tile {
  constructor(options) {
    this._posDirty = false;
    this.events = new EventEmitter();
    this._solid = false;
    this._graphics = [];
    this._offsets = [];
    this._colliders = [];
    this.data = /* @__PURE__ */ new Map();
    var _a, _b;
    this.x = options.x;
    this.y = options.y;
    this.map = options.map;
    this._width = options.map.tileWidth * this.map.scale.x;
    this._height = options.map.tileHeight * this.map.scale.y;
    this.solid = (_a = options.solid) != null ? _a : this.solid;
    this._graphics = (_b = options.graphics) != null ? _b : [];
    this._recalculate();
  }
  /**
   * Return the world position of the top left corner of the tile
   */
  get pos() {
    if (this._posDirty) {
      this._recalculate();
      this._posDirty = false;
    }
    return this._pos;
  }
  /**
   * Width of the tile in pixels
   */
  get width() {
    return this._width;
  }
  /**
   * Height of the tile in pixels
   */
  get height() {
    return this._height;
  }
  /**
   * Wether this tile should be treated as solid by the tilemap
   */
  get solid() {
    return this._solid;
  }
  /**
   * Wether this tile should be treated as solid by the tilemap
   */
  set solid(val) {
    var _a;
    (_a = this.map) == null ? void 0 : _a.flagCollidersDirty();
    this._solid = val;
  }
  /**
   * Current list of graphics for this tile
   */
  getGraphics() {
    return this._graphics;
  }
  /**
   * Current list of offsets for this tile's graphics
   */
  getGraphicsOffsets() {
    return this._offsets;
  }
  /**
   * Add another {@apilink Graphic} to this TileMap tile
   * @param graphic
   */
  addGraphic(graphic, options) {
    this._graphics.push(graphic);
    if (options == null ? void 0 : options.offset) {
      this._offsets.push(options.offset);
    } else {
      this._offsets.push(Vector.Zero);
    }
  }
  /**
   * Remove an instance of a {@apilink Graphic} from this tile
   */
  removeGraphic(graphic) {
    const index = this._graphics.indexOf(graphic);
    if (index > -1) {
      this._graphics.splice(index, 1);
      this._offsets.splice(index, 1);
    }
  }
  /**
   * Clear all graphics from this tile
   */
  clearGraphics() {
    this._graphics.length = 0;
    this._offsets.length = 0;
  }
  /**
   * Returns the list of colliders
   */
  getColliders() {
    return this._colliders;
  }
  /**
   * Adds a custom collider to the {@apilink Tile} to use instead of it's bounds
   *
   * If no collider is set but {@apilink Tile.solid} is set, the tile bounds are used as a collider.
   *
   * **Note!** the {@apilink Tile.solid} must be set to true for it to act as a "fixed" collider
   * @param collider
   */
  addCollider(collider) {
    this._colliders.push(collider);
    this.map.flagCollidersDirty();
  }
  /**
   * Removes a collider from the {@apilink Tile}
   * @param collider
   */
  removeCollider(collider) {
    const index = this._colliders.indexOf(collider);
    if (index > -1) {
      this._colliders.splice(index, 1);
    }
    this.map.flagCollidersDirty();
  }
  /**
   * Clears all colliders from the {@apilink Tile}
   */
  clearColliders() {
    this._colliders.length = 0;
    this.map.flagCollidersDirty();
  }
  flagDirty() {
    this._posDirty = true;
  }
  _recalculate() {
    const geometryPos = this.map.pos.add(vec(this.x * this.map.tileWidth, this.y * this.map.tileHeight));
    this._geometry = new BoundingBox(geometryPos.x, geometryPos.y, geometryPos.x + this.map.tileWidth, geometryPos.y + this.map.tileHeight);
    this._width = this.map.tileWidth * this.map.scale.x;
    this._height = this.map.tileHeight * this.map.scale.y;
    this._pos = this.map.pos.add(vec(this.x * this._width, this.y * this._height));
    this._bounds = new BoundingBox(this._pos.x, this._pos.y, this._pos.x + this._width, this._pos.y + this._height);
    if (this.map.rotation) {
      this._bounds = this._bounds.rotate(this.map.rotation, this.map.pos);
    }
    this._posDirty = false;
  }
  /**
   * Tile bounds in world space
   */
  get bounds() {
    if (this._posDirty) {
      this._recalculate();
    }
    return this._bounds;
  }
  get defaultGeometry() {
    return this._geometry;
  }
  /**
   * Tile position in world space
   */
  get center() {
    if (this._posDirty) {
      this._recalculate();
    }
    return new Vector(this._pos.x + this._width / 2, this._pos.y + this._height / 2);
  }
  emit(eventName, event) {
    this.events.emit(eventName, event);
  }
  on(eventName, handler) {
    return this.events.on(eventName, handler);
  }
  once(eventName, handler) {
    return this.events.once(eventName, handler);
  }
  off(eventName, handler) {
    if (handler) {
      this.events.off(eventName, handler);
    } else {
      this.events.off(eventName);
    }
  }
}
class IsometricEntityComponent extends Component {
  /**
   * Specify the isometric map to use to position this entity's z-index
   * @param mapOrOptions
   */
  constructor(mapOrOptions) {
    super();
    this.elevation = 0;
    this.columns = mapOrOptions.columns;
    this.rows = mapOrOptions.rows;
    this.tileWidth = mapOrOptions.tileWidth;
    this.tileHeight = mapOrOptions.tileHeight;
  }
}
class IsometricTile extends Entity {
  /**
   * Construct a new IsometricTile
   * @param x tile coordinate in x (not world position)
   * @param y tile coordinate in y (not world position)
   * @param graphicsOffset offset that tile should be shifted by (default (0, 0))
   * @param map reference to owning IsometricMap
   */
  constructor(x, y, graphicsOffset, map) {
    super([
      new TransformComponent(),
      new GraphicsComponent({
        offset: graphicsOffset != null ? graphicsOffset : Vector.Zero,
        onPostDraw: (gfx, elapsed) => this.draw(gfx, elapsed)
      }),
      new IsometricEntityComponent(map)
    ]);
    this.solid = false;
    this.events = new EventEmitter();
    this._tileBounds = new BoundingBox();
    this._graphics = [];
    this._colliders = [];
    this.data = /* @__PURE__ */ new Map();
    this.x = x;
    this.y = y;
    this.map = map;
    this._transform = this.get(TransformComponent);
    this._isometricEntityComponent = this.get(IsometricEntityComponent);
    const halfTileWidth = this.map.tileWidth / 2;
    const halfTileHeight = this.map.tileHeight / 2;
    const xPos = (this.x - this.y) * halfTileWidth;
    const yPos = (this.x + this.y) * halfTileHeight;
    this._transform.pos = vec(xPos, yPos);
    this._isometricEntityComponent.elevation = map.elevation;
    this._gfx = this.get(GraphicsComponent);
    this._gfx.isVisible = false;
    const totalWidth = this.map.tileWidth;
    const totalHeight = this.map.tileHeight;
    const offset = vec(0, this.map.renderFromTopOfGraphic ? totalHeight : 0);
    this._gfx.localBounds = this._tileBounds = new BoundingBox({
      left: -totalWidth / 2,
      top: -totalHeight,
      right: totalWidth / 2,
      bottom: totalHeight
    }).translate(offset);
  }
  getGraphics() {
    return this._graphics;
  }
  /**
   * Tile graphics
   */
  addGraphic(graphic, options) {
    this._graphics.push(graphic);
    this._gfx.isVisible = this.map.isVisible;
    this._gfx.opacity = this.map.opacity;
    if (options == null ? void 0 : options.offset) {
      this._gfx.offset = options.offset;
    }
    this._gfx.localBounds = this._recalculateBounds();
  }
  _recalculateBounds() {
    let bounds = this._tileBounds.clone();
    for (const graphic of this._graphics) {
      const offset = vec(
        this.map.graphicsOffset.x - this.map.tileWidth / 2,
        this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : graphic.height - this.map.tileHeight)
      );
      bounds = bounds.combine(graphic.localBounds.translate(offset));
    }
    return bounds;
  }
  removeGraphic(graphic) {
    const index = this._graphics.indexOf(graphic);
    if (index > -1) {
      this._graphics.splice(index, 1);
    }
    this._gfx.localBounds = this._recalculateBounds();
  }
  clearGraphics() {
    this._graphics.length = 0;
    this._gfx.isVisible = false;
    this._gfx.localBounds = this._recalculateBounds();
  }
  getColliders() {
    return this._colliders;
  }
  /**
   * Adds a collider to the IsometricTile
   *
   * **Note!** the {@apilink Tile.solid} must be set to true for it to act as a "fixed" collider
   * @param collider
   */
  addCollider(collider) {
    this._colliders.push(collider);
    this.map.flagCollidersDirty();
  }
  /**
   * Removes a collider from the IsometricTile
   * @param collider
   */
  removeCollider(collider) {
    const index = this._colliders.indexOf(collider);
    if (index > -1) {
      this._colliders.splice(index, 1);
    }
    this.map.flagCollidersDirty();
  }
  /**
   * Clears all colliders from the IsometricTile
   */
  clearColliders() {
    this._colliders.length = 0;
    this.map.flagCollidersDirty();
  }
  /**
   * Returns the top left corner of the {@apilink IsometricTile} in world space
   */
  get pos() {
    return this.map.tileToWorld(vec(this.x, this.y));
  }
  /**
   * Returns the center of the {@apilink IsometricTile}
   */
  get center() {
    return this.pos.add(vec(0, this.map.tileHeight / 2));
  }
  draw(gfx, _elapsed) {
    const halfTileWidth = this.map.tileWidth / 2;
    gfx.save();
    gfx.translate(-halfTileWidth, 0);
    for (const graphic of this._graphics) {
      graphic.draw(
        gfx,
        this.map.graphicsOffset.x,
        this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : graphic.height - this.map.tileHeight)
      );
    }
    gfx.restore();
  }
}
class IsometricMap extends Entity {
  constructor(options) {
    super(
      [
        new TransformComponent(),
        new BodyComponent({
          type: CollisionType.Fixed
        }),
        new ColliderComponent(),
        new PointerComponent(),
        new DebugGraphicsComponent((ctx, debugFlags) => this.debug(ctx, debugFlags), false)
      ],
      options.name
    );
    this.elevation = 0;
    this.isVisible = true;
    this.opacity = 1;
    this.renderFromTopOfGraphic = false;
    this.graphicsOffset = vec(0, 0);
    this._collidersDirty = false;
    this._originalOffsets = /* @__PURE__ */ new WeakMap();
    const { pos, tileWidth, tileHeight, columns: width, rows: height, renderFromTopOfGraphic, graphicsOffset, elevation } = options;
    this.transform = this.get(TransformComponent);
    if (pos) {
      this.transform.pos = pos;
    }
    this.collider = this.get(ColliderComponent);
    if (this.collider) {
      this.collider.set(this._composite = new CompositeCollider([]));
    }
    this.pointer = this.get(PointerComponent);
    this.renderFromTopOfGraphic = renderFromTopOfGraphic != null ? renderFromTopOfGraphic : this.renderFromTopOfGraphic;
    this.graphicsOffset = graphicsOffset != null ? graphicsOffset : this.graphicsOffset;
    this.elevation = elevation != null ? elevation : this.elevation;
    this.tileWidth = tileWidth;
    this.tileHeight = tileHeight;
    this.columns = width;
    this.rows = height;
    this._pointerEventDispatcher = new PointerEventsToObjectDispatcher();
    this.tiles = new Array(width * height);
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const tile = new IsometricTile(x, y, this.graphicsOffset, this);
        this.tiles[x + y * width] = tile;
        this.addChild(tile);
        this._pointerEventDispatcher.addObject(
          tile,
          (p) => this.getTileByPoint(p.worldPos) === tile,
          () => true
        );
      }
    }
    this.pointer.localBounds = BoundingBox.fromDimension(
      tileWidth * width * this.transform.scale.x,
      tileHeight * height * this.transform.scale.y,
      vec(0.5, 0)
    );
  }
  /**
   * Whether tiles should be visible
   * @deprecated use isVisible
   */
  get visible() {
    return this.isVisible;
  }
  /**
   * Whether tiles should be visible
   * @deprecated use isVisible
   */
  set visible(val) {
    this.isVisible = val;
  }
  /**
   * @internal
   */
  _processPointerToObject(receiver) {
    this._pointerEventDispatcher.processPointerToObject(receiver, this.tiles);
  }
  /**
   * @internal
   */
  _dispatchPointerEvents(receiver) {
    this._pointerEventDispatcher.dispatchEvents(receiver, this.tiles);
  }
  update() {
    if (this._collidersDirty) {
      this.updateColliders();
      this._collidersDirty = false;
    }
    this._pointerEventDispatcher.clear();
  }
  flagCollidersDirty() {
    this._collidersDirty = true;
  }
  _getOrSetColliderOriginalOffset(collider) {
    var _a;
    if (!this._originalOffsets.has(collider)) {
      const originalOffset = collider.offset;
      this._originalOffsets.set(collider, originalOffset);
      return originalOffset;
    } else {
      return (_a = this._originalOffsets.get(collider)) != null ? _a : Vector.Zero;
    }
  }
  updateColliders() {
    this._composite.clearColliders();
    const pos = this.get(TransformComponent).pos;
    for (const tile of this.tiles) {
      if (tile.solid) {
        for (const collider of tile.getColliders()) {
          const originalOffset = this._getOrSetColliderOriginalOffset(collider);
          collider.offset = this.tileToWorld(vec(tile.x, tile.y)).sub(pos).add(originalOffset).sub(vec(this.tileWidth / 2, this.tileHeight));
          collider.owner = this;
          this._composite.addCollider(collider);
        }
      }
    }
    this.collider.update();
  }
  /**
   * Convert world space coordinates to the tile x, y coordinate
   * @param worldCoordinate
   */
  worldToTile(worldCoordinate) {
    worldCoordinate = worldCoordinate.sub(this.transform.globalPos);
    const halfTileWidth = this.tileWidth / 2;
    const halfTileHeight = this.tileHeight / 2;
    return vec(
      ~~((worldCoordinate.x / halfTileWidth + worldCoordinate.y / halfTileHeight) / 2),
      ~~((worldCoordinate.y / halfTileHeight - worldCoordinate.x / halfTileWidth) / 2)
    );
  }
  /**
   * Given a tile coordinate, return the top left corner in world space
   * @param tileCoordinate
   */
  tileToWorld(tileCoordinate) {
    const halfTileWidth = this.tileWidth / 2;
    const halfTileHeight = this.tileHeight / 2;
    const xPos = (tileCoordinate.x - tileCoordinate.y) * halfTileWidth;
    const yPos = (tileCoordinate.x + tileCoordinate.y) * halfTileHeight;
    return vec(xPos, yPos).add(this.transform.pos);
  }
  /**
   * Returns the {@apilink IsometricTile} by its x and y coordinates
   */
  getTile(x, y) {
    if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {
      return null;
    }
    return this.tiles[x + y * this.columns];
  }
  /**
   * Returns the {@apilink IsometricTile} by testing a point in world coordinates,
   * returns `null` if no Tile was found.
   */
  getTileByPoint(point2) {
    const tileCoord = this.worldToTile(point2);
    const tile = this.getTile(tileCoord.x, tileCoord.y);
    return tile;
  }
  _getMaxZIndex() {
    let maxZ = Number.NEGATIVE_INFINITY;
    for (const tile of this.tiles) {
      const currentZ = tile.get(TransformComponent).z;
      if (currentZ > maxZ) {
        maxZ = currentZ;
      }
    }
    return maxZ;
  }
  /**
   * Debug draw for IsometricMap, called internally by excalibur when debug mode is toggled on
   * @param gfx
   */
  debug(gfx, debugFlags) {
    const { showAll, showPosition, positionColor, positionSize, showGrid, gridColor, gridWidth, showColliderGeometry } = debugFlags.isometric;
    const { geometryColor, geometryLineWidth, geometryPointSize } = debugFlags.collider;
    gfx.save();
    gfx.z = this._getMaxZIndex() + 0.5;
    if (showAll || showGrid) {
      for (let y = 0; y < this.rows + 1; y++) {
        const left = this.tileToWorld(vec(0, y));
        const right = this.tileToWorld(vec(this.columns, y));
        gfx.drawLine(left, right, gridColor, gridWidth);
      }
      for (let x = 0; x < this.columns + 1; x++) {
        const top = this.tileToWorld(vec(x, 0));
        const bottom = this.tileToWorld(vec(x, this.rows));
        gfx.drawLine(top, bottom, gridColor, gridWidth);
      }
    }
    if (showAll || showPosition) {
      for (const tile of this.tiles) {
        gfx.drawCircle(this.tileToWorld(vec(tile.x, tile.y)), positionSize, positionColor);
      }
    }
    if (showAll || showColliderGeometry) {
      for (const tile of this.tiles) {
        if (tile.solid) {
          for (const collider of tile.getColliders()) {
            collider.debug(gfx, geometryColor, { lineWidth: geometryLineWidth, pointSize: geometryPointSize });
          }
        }
      }
    }
    gfx.restore();
  }
}
class IsometricEntitySystem extends System {
  constructor(world) {
    super();
    this.world = world;
    this.systemType = SystemType.Update;
    this.query = this.world.query([TransformComponent, IsometricEntityComponent]);
  }
  update() {
    let transform;
    let iso;
    for (let i = 0; i < this.query.entities.length; i++) {
      const entity = this.query.entities[i];
      transform = entity.get(TransformComponent);
      iso = entity.get(IsometricEntityComponent);
      const maxZindexPerElevation = Math.max(iso.columns * iso.tileWidth, iso.rows * iso.tileHeight);
      const newZ = maxZindexPerElevation * iso.elevation + transform.pos.y;
      transform.z = newZ;
    }
  }
}
IsometricEntitySystem.priority = SystemPriority.Lower;
class StrategyContainer {
  constructor(camera) {
    this.camera = camera;
  }
  /**
   * Creates and adds the {@apilink LockCameraToActorStrategy} on the current camera.
   * @param actor The actor to lock the camera to
   */
  lockToActor(actor) {
    this.camera.addStrategy(new LockCameraToActorStrategy(actor));
  }
  /**
   * Creates and adds the {@apilink LockCameraToActorAxisStrategy} on the current camera
   * @param actor The actor to lock the camera to
   * @param axis The axis to follow the actor on
   */
  lockToActorAxis(actor, axis) {
    this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));
  }
  /**
   * Creates and adds the {@apilink ElasticToActorStrategy} on the current camera
   * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
   * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
   * correct and bounce around the target
   * @param actor Target actor to elastically follow
   * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
   * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
   */
  elasticToActor(actor, cameraElasticity, cameraFriction) {
    this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));
  }
  /**
   * Creates and adds the {@apilink RadiusAroundActorStrategy} on the current camera
   * @param actor Target actor to follow when it is "radius" pixels away
   * @param radius Number of pixels away before the camera will follow
   */
  radiusAroundActor(actor, radius) {
    this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));
  }
  /**
   * Creates and adds the {@apilink LimitCameraBoundsStrategy} on the current camera
   * @param box The bounding box to limit the camera to.
   */
  limitCameraBounds(box) {
    this.camera.addStrategy(new LimitCameraBoundsStrategy(box));
  }
}
var Axis = /* @__PURE__ */ ((Axis2) => {
  Axis2[Axis2["X"] = 0] = "X";
  Axis2[Axis2["Y"] = 1] = "Y";
  return Axis2;
})(Axis || {});
class LockCameraToActorStrategy {
  constructor(target) {
    this.target = target;
    this.action = (target2, camera, engine, elapsed) => {
      const center = target2.center;
      return center;
    };
  }
}
class LockCameraToActorAxisStrategy {
  constructor(target, axis) {
    this.target = target;
    this.axis = axis;
    this.action = (target2, cam, _eng, elapsed) => {
      const center = target2.center;
      const currentFocus = cam.getFocus();
      if (this.axis === 0) {
        return new Vector(center.x, currentFocus.y);
      } else {
        return new Vector(currentFocus.x, center.y);
      }
    };
  }
}
class ElasticToActorStrategy {
  /**
   * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
   * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
   * correct and bounce around the target
   * @param target Target actor to elastically follow
   * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
   * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
   */
  constructor(target, cameraElasticity, cameraFriction) {
    this.target = target;
    this.cameraElasticity = cameraElasticity;
    this.cameraFriction = cameraFriction;
    this.action = (target2, cam, _eng, elapsed) => {
      const position = target2.center;
      let focus = cam.getFocus();
      let cameraVel = cam.vel.clone();
      const stretch = position.sub(focus).scale(this.cameraElasticity);
      cameraVel = cameraVel.add(stretch);
      const friction = cameraVel.scale(-1).scale(this.cameraFriction);
      cameraVel = cameraVel.add(friction);
      focus = focus.add(cameraVel);
      return focus;
    };
  }
}
class RadiusAroundActorStrategy {
  /**
   *
   * @param target Target actor to follow when it is "radius" pixels away
   * @param radius Number of pixels away before the camera will follow
   */
  constructor(target, radius) {
    this.target = target;
    this.radius = radius;
    this.action = (target2, cam, _eng, elapsed) => {
      const position = target2.center;
      const focus = cam.getFocus();
      const direction = position.sub(focus);
      const distance = direction.magnitude;
      if (distance >= this.radius) {
        const offset = distance - this.radius;
        return focus.add(direction.normalize().scale(offset));
      }
      return focus;
    };
  }
}
class LimitCameraBoundsStrategy {
  // Check and warn only once
  constructor(target) {
    this.target = target;
    this.boundSizeChecked = false;
    this.action = (target2, cam, _eng, elapsed) => {
      const focus = cam.getFocus();
      if (!this.boundSizeChecked) {
        if (target2.bottom - target2.top < _eng.drawHeight || target2.right - target2.left < _eng.drawWidth) {
          Logger.getInstance().warn("Camera bounds should not be smaller than the engine viewport");
        }
        this.boundSizeChecked = true;
      }
      let focusX = focus.x;
      let focusY = focus.y;
      if (focus.x < target2.left + _eng.halfDrawWidth) {
        focusX = target2.left + _eng.halfDrawWidth;
      } else if (focus.x > target2.right - _eng.halfDrawWidth) {
        focusX = target2.right - _eng.halfDrawWidth;
      }
      if (focus.y < target2.top + _eng.halfDrawHeight) {
        focusY = target2.top + _eng.halfDrawHeight;
      } else if (focus.y > target2.bottom - _eng.halfDrawHeight) {
        focusY = target2.bottom - _eng.halfDrawHeight;
      }
      return vec(focusX, focusY);
    };
  }
}
const CameraEvents = {
  Initialize: "initialize",
  PreUpdate: "preupdate",
  PostUpdate: "postupdate"
};
class Camera {
  constructor() {
    this.events = new EventEmitter();
    this.transform = AffineMatrix.identity();
    this.inverse = AffineMatrix.identity();
    this._cameraStrategies = [];
    this.strategy = new StrategyContainer(this);
    this._z = 1;
    this.dz = 0;
    this.az = 0;
    this.rotation = 0;
    this._angularVelocity = 0;
    this._posChanged = false;
    this._pos = new WatchVector(Vector.Zero, () => {
      this._posChanged = true;
    });
    this.drawPos = this.pos.clone();
    this._oldPos = this.pos.clone();
    this.vel = Vector.Zero;
    this.acc = Vector.Zero;
    this._cameraMoving = false;
    this._currentLerpTime = 0;
    this._lerpDuration = 1e3;
    this._lerpStart = null;
    this._lerpEnd = null;
    this._isShaking = false;
    this._shakeMagnitudeX = 0;
    this._shakeMagnitudeY = 0;
    this._shakeDuration = 0;
    this._elapsedShakeTime = 0;
    this._xShake = 0;
    this._yShake = 0;
    this._isZooming = false;
    this._zoomStart = 1;
    this._zoomEnd = 1;
    this._currentZoomTime = 0;
    this._zoomDuration = 0;
    this._zoomEasing = EasingFunctions.EaseInOutCubic;
    this._easing = EasingFunctions.EaseInOutCubic;
    this._halfWidth = 0;
    this._halfHeight = 0;
    this._viewport = null;
    this._isInitialized = false;
    this._snapPos = vec(0, 0);
  }
  get strategies() {
    return this._cameraStrategies;
  }
  get zoom() {
    return this._z;
  }
  set zoom(val) {
    this._z = val;
    if (this._engine) {
      this._halfWidth = this._engine.halfDrawWidth;
      this._halfHeight = this._engine.halfDrawHeight;
    }
  }
  /**
   * Get or set the camera's angular velocity
   */
  get angularVelocity() {
    return this._angularVelocity;
  }
  set angularVelocity(value) {
    this._angularVelocity = value;
  }
  /**
   * Get or set the camera's position
   */
  get pos() {
    return this._pos;
  }
  set pos(vec2) {
    this._posChanged = true;
    this._pos = new WatchVector(vec2, () => {
      this._posChanged = true;
    });
  }
  /**
   * Has the position changed since the last update
   */
  hasChanged() {
    return this._posChanged;
  }
  /**
   * Get the camera's x position
   */
  get x() {
    return this.pos.x;
  }
  /**
   * Set the camera's x position (cannot be set when following an {@apilink Actor} or when moving)
   */
  set x(value) {
    if (!this._follow && !this._cameraMoving) {
      this.pos = vec(value, this.pos.y);
    }
  }
  /**
   * Get the camera's y position
   */
  get y() {
    return this.pos.y;
  }
  /**
   * Set the camera's y position (cannot be set when following an {@apilink Actor} or when moving)
   */
  set y(value) {
    if (!this._follow && !this._cameraMoving) {
      this.pos = vec(this.pos.x, value);
    }
  }
  /**
   * Get or set the camera's x velocity
   */
  get dx() {
    return this.vel.x;
  }
  set dx(value) {
    this.vel = vec(value, this.vel.y);
  }
  /**
   * Get or set the camera's y velocity
   */
  get dy() {
    return this.vel.y;
  }
  set dy(value) {
    this.vel = vec(this.vel.x, value);
  }
  /**
   * Get or set the camera's x acceleration
   */
  get ax() {
    return this.acc.x;
  }
  set ax(value) {
    this.acc = vec(value, this.acc.y);
  }
  /**
   * Get or set the camera's y acceleration
   */
  get ay() {
    return this.acc.y;
  }
  set ay(value) {
    this.acc = vec(this.acc.x, value);
  }
  /**
   * Returns the focal point of the camera, a new point giving the x and y position of the camera
   */
  getFocus() {
    return this.pos;
  }
  /**
   * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.
   * @param pos The target position to move to
   * @param duration The duration in milliseconds the move should last
   * @param [easingFn] An optional easing function ({@apilink EasingFunctions.EaseInOutCubic} by default)
   * @returns A {@apilink Promise} that resolves when movement is finished, including if it's interrupted.
   *          The {@apilink Promise} value is the {@apilink Vector} of the target position. It will be rejected if a move cannot be made.
   */
  move(pos, duration, easingFn = EasingFunctions.EaseInOutCubic) {
    if (typeof easingFn !== "function") {
      throw "Please specify an EasingFunction";
    }
    if (this._follow) {
      return Promise.reject(pos);
    }
    if (this._lerpPromise && this._lerpResolve) {
      this._lerpResolve(pos);
    }
    this._lerpPromise = new Promise((resolve) => {
      this._lerpResolve = resolve;
    });
    this._lerpStart = this.getFocus().clone();
    this._lerpDuration = duration;
    this._lerpEnd = pos;
    this._currentLerpTime = 0;
    this._cameraMoving = true;
    this._easing = easingFn;
    return this._lerpPromise;
  }
  /**
   * Sets the camera to shake at the specified magnitudes for the specified duration
   * @param magnitudeX  The x magnitude of the shake
   * @param magnitudeY  The y magnitude of the shake
   * @param duration    The duration of the shake in milliseconds
   */
  shake(magnitudeX, magnitudeY, duration) {
    this._isShaking = true;
    this._shakeMagnitudeX = magnitudeX;
    this._shakeMagnitudeY = magnitudeY;
    this._shakeDuration = duration;
  }
  /**
   * Zooms the camera in or out by the specified scale over the specified duration.
   * If no duration is specified, it take effect immediately.
   * @param scale    The scale of the zoom
   * @param duration The duration of the zoom in milliseconds
   */
  zoomOverTime(scale, duration = 0, easingFn = EasingFunctions.EaseInOutCubic) {
    this._zoomPromise = new Promise((resolve) => {
      this._zoomResolve = resolve;
    });
    if (duration) {
      this._isZooming = true;
      this._zoomEasing = easingFn;
      this._currentZoomTime = 0;
      this._zoomDuration = duration;
      this._zoomStart = this.zoom;
      this._zoomEnd = scale;
    } else {
      this._isZooming = false;
      this.zoom = scale;
      return Promise.resolve(true);
    }
    return this._zoomPromise;
  }
  /**
   * Gets the bounding box of the viewport of this camera in world coordinates
   */
  get viewport() {
    if (this._viewport) {
      return this._viewport;
    }
    return new BoundingBox(0, 0, 0, 0);
  }
  /**
   * Adds one or more new camera strategies to this camera
   * @param cameraStrategy Instance of an {@apilink CameraStrategy}
   */
  addStrategy(...cameraStrategies) {
    this._cameraStrategies.push(...cameraStrategies);
  }
  /**
   * Sets the strategies of this camera, replacing all existing strategies
   * @param cameraStrategies Array of {@apilink CameraStrategy}
   */
  setStrategies(cameraStrategies) {
    this._cameraStrategies = [...cameraStrategies];
  }
  /**
   * Removes a camera strategy by reference
   * @param cameraStrategy Instance of an {@apilink CameraStrategy}
   */
  removeStrategy(cameraStrategy) {
    removeItemFromArray(cameraStrategy, this._cameraStrategies);
  }
  /**
   * Clears all camera strategies from the camera
   */
  clearAllStrategies() {
    this._cameraStrategies.length = 0;
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPreUpdate} lifecycle event
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   * @internal
   */
  _preupdate(engine, elapsed) {
    this.events.emit("preupdate", new PreUpdateEvent(engine, elapsed, this));
    this.onPreUpdate(engine, elapsed);
  }
  /**
   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPreUpdate` is called directly before a scene is updated.
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   */
  onPreUpdate(engine, elapsed) {
  }
  /**
   *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPostUpdate} lifecycle event
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   * @internal
   */
  _postupdate(engine, elapsed) {
    this.events.emit("postupdate", new PostUpdateEvent(engine, elapsed, this));
    this.onPostUpdate(engine, elapsed);
  }
  /**
   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPostUpdate` is called directly after a scene is updated.
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   */
  onPostUpdate(engine, elapsed) {
  }
  get isInitialized() {
    return this._isInitialized;
  }
  _initialize(engine) {
    if (!this.isInitialized) {
      this._engine = engine;
      this._screen = engine.screen;
      const currentRes = this._screen.contentArea;
      let center = vec(currentRes.width / 2, currentRes.height / 2);
      if (!this._engine.loadingComplete) {
        const res = this._screen.peekResolution();
        if (res) {
          center = vec(res.width / 2, res.height / 2);
        }
      }
      this._halfWidth = center.x;
      this._halfHeight = center.y;
      if (!this._posChanged) {
        this.pos = center;
      }
      this.pos.clone(this.drawPos);
      this.updateTransform(this.pos);
      this.runStrategies(engine, engine.clock.elapsed());
      this.updateViewport();
      this.updateTransform(this.pos);
      this.pos.clone(this._oldPos);
      this.onInitialize(engine);
      this.events.emit("initialize", new InitializeEvent(engine, this));
      this._isInitialized = true;
    }
  }
  /**
   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPostUpdate` is called directly after a scene is updated.
   */
  onInitialize(engine) {
  }
  emit(eventName, event) {
    this.events.emit(eventName, event);
  }
  on(eventName, handler) {
    return this.events.on(eventName, handler);
  }
  once(eventName, handler) {
    return this.events.once(eventName, handler);
  }
  off(eventName, handler) {
    this.events.off(eventName, handler);
  }
  runStrategies(engine, elapsed) {
    for (const s of this._cameraStrategies) {
      this.pos = s.action.call(s, s.target, this, engine, elapsed);
    }
  }
  updateViewport() {
    this._viewport = new BoundingBox(
      this.x - this._halfWidth,
      this.y - this._halfHeight,
      this.x + this._halfWidth,
      this.y + this._halfHeight
    );
  }
  update(engine, elapsed) {
    this._initialize(engine);
    this._preupdate(engine, elapsed);
    this.pos.clone(this._oldPos);
    this.pos = this.pos.add(this.vel.scale(elapsed / 1e3));
    this.zoom += this.dz * elapsed / 1e3;
    this.vel = this.vel.add(this.acc.scale(elapsed / 1e3));
    this.dz += this.az * elapsed / 1e3;
    this.rotation += this.angularVelocity * elapsed / 1e3;
    if (this._isZooming) {
      if (this._currentZoomTime < this._zoomDuration) {
        const zoomEasing = this._zoomEasing;
        const newZoom = zoomEasing(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);
        this.zoom = newZoom;
        this._currentZoomTime += elapsed;
      } else {
        this._isZooming = false;
        this.zoom = this._zoomEnd;
        this._currentZoomTime = 0;
        this._zoomResolve(true);
      }
    }
    if (this._cameraMoving) {
      if (this._currentLerpTime < this._lerpDuration) {
        const moveEasing = EasingFunctions.CreateVectorEasingFunction(this._easing);
        const lerpPoint = moveEasing(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration);
        this.pos = lerpPoint;
        this._currentLerpTime += elapsed;
      } else {
        this.pos = this._lerpEnd;
        const end = this._lerpEnd.clone();
        this._lerpStart = null;
        this._lerpEnd = null;
        this._currentLerpTime = 0;
        this._cameraMoving = false;
        this._lerpResolve(end);
      }
    }
    if (this._isDoneShaking()) {
      this._isShaking = false;
      this._elapsedShakeTime = 0;
      this._shakeMagnitudeX = 0;
      this._shakeMagnitudeY = 0;
      this._shakeDuration = 0;
      this._xShake = 0;
      this._yShake = 0;
    } else {
      this._elapsedShakeTime += elapsed;
      this._xShake = (Math.random() * this._shakeMagnitudeX | 0) + 1;
      this._yShake = (Math.random() * this._shakeMagnitudeY | 0) + 1;
    }
    this.runStrategies(engine, elapsed);
    this.updateViewport();
    this.updateTransform(this.pos);
    this._postupdate(engine, elapsed);
    this._posChanged = false;
  }
  /**
   * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera
   * @param ctx Canvas context to apply transformations
   */
  draw(ctx) {
    this.pos.clone(this.drawPos);
    if (this._engine.fixedUpdateTimestep) {
      const blend = this._engine.currentFrameLagMs / this._engine.fixedUpdateTimestep;
      const interpolatedPos = this.pos.scale(blend).add(this._oldPos.scale(1 - blend));
      interpolatedPos.clone(this.drawPos);
      this.updateTransform(interpolatedPos);
    }
    if (ctx.snapToPixel) {
      const snapPos = this.drawPos.clone(this._snapPos);
      snapPos.x = ~~(snapPos.x + pixelSnapEpsilon * sign(snapPos.x));
      snapPos.y = ~~(snapPos.y + pixelSnapEpsilon * sign(snapPos.y));
      snapPos.clone(this.drawPos);
      this.updateTransform(snapPos);
    }
    ctx.multiply(this.transform);
  }
  updateTransform(pos) {
    const newCanvasWidth = this._screen.resolution.width / this.zoom;
    const newCanvasHeight = this._screen.resolution.height / this.zoom;
    const cameraPos = vec(-pos.x + newCanvasWidth / 2 + this._xShake, -pos.y + newCanvasHeight / 2 + this._yShake);
    this.transform.reset();
    this.transform.scale(this.zoom, this.zoom);
    this.transform.translate(newCanvasWidth / 2, newCanvasHeight / 2);
    this.transform.rotate(this.rotation);
    this.transform.translate(-newCanvasWidth / 2, -newCanvasHeight / 2);
    this.transform.translate(cameraPos.x, cameraPos.y);
    this.transform.inverse(this.inverse);
  }
  _isDoneShaking() {
    return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;
  }
}
const TriggerEvents = {
  ExitTrigger: "exit",
  EnterTrigger: "enter"
};
class Trigger extends Actor {
  /**
   * @param options Trigger options
   */
  constructor(options) {
    var _a, _b, _c, _d;
    super({ ...options });
    this.events = new EventEmitter();
    this.filter = (_a = options.filter) != null ? _a : () => true;
    this.repeat = (_b = options.repeat) != null ? _b : -1;
    this.action = (_c = options.action) != null ? _c : () => void 0;
    this.target = options.target;
    this.graphics.isVisible = (_d = options.visible) != null ? _d : false;
    this.body.collisionType = CollisionType.Passive;
    this.events.on("collisionstart", ({ other: collider }) => {
      if (!this._matchesTarget(collider.owner)) {
        return;
      }
      this.events.emit("enter", new EnterTriggerEvent(this, collider.owner));
      this._dispatchAction(collider.owner);
      if (this.repeat === 0) {
        this.kill();
      }
    });
    this.events.on("collisionend", ({ other: collider }) => {
      if (this._matchesTarget(collider.owner)) {
        this.events.emit("exit", new ExitTriggerEvent(this, collider.owner));
      }
    });
  }
  _matchesTarget(entity) {
    return this.filter(entity) && (this.target === void 0 || this.target === entity);
  }
  _dispatchAction(target) {
    if (this.repeat !== 0) {
      this.action.call(this, target);
      this.repeat--;
    }
  }
}
class DebugSystem extends System {
  constructor(world) {
    super();
    this.world = world;
    this.systemType = SystemType.Draw;
    this.query = this.world.query([TransformComponent]);
  }
  initialize(world, scene) {
    this._graphicsContext = scene.engine.graphicsContext;
    this._camera = scene.camera;
    this._engine = scene.engine;
    this._collisionSystem = world.systemManager.get(CollisionSystem);
  }
  update() {
    var _a;
    if (!this._engine.isDebug) {
      return;
    }
    const filterSettings = this._engine.debug.filter;
    let id;
    let name;
    const entitySettings = this._engine.debug.entity;
    let tx;
    const txSettings = this._engine.debug.transform;
    let motion;
    const motionSettings = this._engine.debug.motion;
    let colliderComp;
    const colliderSettings = this._engine.debug.collider;
    const physicsSettings = this._engine.debug.physics;
    let graphics;
    const graphicsSettings = this._engine.debug.graphics;
    let debugDraw;
    let body;
    const bodySettings = this._engine.debug.body;
    const cameraSettings = this._engine.debug.camera;
    for (let i = 0; i < this.query.entities.length; i++) {
      const entity = this.query.entities[i];
      if (entity.hasTag("offscreen")) {
        continue;
      }
      if (entity instanceof Particle) {
        continue;
      }
      if (filterSettings.useFilter) {
        const allIds = filterSettings.ids.length === 0;
        const idMatch = allIds || filterSettings.ids.includes(entity.id);
        if (!idMatch) {
          continue;
        }
        const allNames = filterSettings.nameQuery === "";
        const nameMatch = allNames || entity.name.includes(filterSettings.nameQuery);
        if (!nameMatch) {
          continue;
        }
      }
      let cursor = Vector.Zero;
      const lineHeight = vec(0, 16);
      id = entity.id;
      name = entity.name;
      tx = entity.get(TransformComponent);
      this._pushCameraTransform(tx);
      this._graphicsContext.save();
      if (tx.coordPlane === CoordPlane.Screen) {
        this._graphicsContext.translate(this._engine.screen.contentArea.left, this._engine.screen.contentArea.top);
      }
      this._graphicsContext.z = txSettings.debugZIndex;
      this._applyTransform(entity);
      if (tx) {
        if (txSettings.showAll || txSettings.showPosition) {
          this._graphicsContext.debug.drawPoint(Vector.Zero, { size: 4, color: txSettings.positionColor });
        }
        if (txSettings.showAll || txSettings.showPositionLabel) {
          this._graphicsContext.debug.drawText(`pos${tx.pos.toString(2)}`, cursor);
          cursor = cursor.add(lineHeight);
        }
        if (txSettings.showAll || txSettings.showZIndex) {
          this._graphicsContext.debug.drawText(`z(${tx.z.toFixed(1)})`, cursor);
          cursor = cursor.add(lineHeight);
        }
        if (entitySettings.showAll || entitySettings.showId) {
          this._graphicsContext.debug.drawText(`id(${id}) ${entity.parent ? "child of id(" + ((_a = entity.parent) == null ? void 0 : _a.id) + ")" : ""}`, cursor);
          cursor = cursor.add(lineHeight);
        }
        if (entitySettings.showAll || entitySettings.showName) {
          this._graphicsContext.debug.drawText(`name(${name})`, cursor);
          cursor = cursor.add(lineHeight);
        }
        if (txSettings.showAll || txSettings.showRotation) {
          this._graphicsContext.drawLine(
            Vector.Zero,
            Vector.fromAngle(tx.rotation).scale(50).add(Vector.Zero),
            txSettings.rotationColor,
            2
          );
          this._graphicsContext.debug.drawText(`rot deg(${toDegrees(tx.rotation).toFixed(2)})`, cursor);
          cursor = cursor.add(lineHeight);
        }
        if (txSettings.showAll || txSettings.showScale) {
          this._graphicsContext.drawLine(Vector.Zero, tx.scale.add(Vector.Zero), txSettings.scaleColor, 2);
        }
      }
      graphics = entity.get(GraphicsComponent);
      if (graphics) {
        if (graphicsSettings.showAll || graphicsSettings.showBounds) {
          const bounds = graphics.localBounds;
          bounds.draw(this._graphicsContext, graphicsSettings.boundsColor);
        }
      }
      debugDraw = entity.get(DebugGraphicsComponent);
      if (debugDraw) {
        if (!debugDraw.useTransform) {
          this._graphicsContext.restore();
        }
        debugDraw.draw(this._graphicsContext, this._engine.debug);
        if (!debugDraw.useTransform) {
          this._graphicsContext.save();
          this._applyTransform(entity);
        }
      }
      body = entity.get(BodyComponent);
      if (body) {
        if (bodySettings.showAll || bodySettings.showCollisionGroup) {
          this._graphicsContext.debug.drawText(`collision group(${body.group.name})`, cursor);
          cursor = cursor.add(lineHeight);
        }
        if (bodySettings.showAll || bodySettings.showCollisionType) {
          this._graphicsContext.debug.drawText(`collision type(${body.collisionType})`, cursor);
          cursor = cursor.add(lineHeight);
        }
        if (bodySettings.showAll || bodySettings.showMass) {
          this._graphicsContext.debug.drawText(`mass(${body.mass})`, cursor);
          cursor = cursor.add(lineHeight);
        }
        if (bodySettings.showAll || bodySettings.showMotion) {
          this._graphicsContext.debug.drawText(`motion(${body.sleepMotion})`, cursor);
          cursor = cursor.add(lineHeight);
        }
        if (bodySettings.showAll || bodySettings.showSleeping) {
          this._graphicsContext.debug.drawText(`sleeping(${body.canSleep ? body.isSleeping : "cant sleep"})`, cursor);
          cursor = cursor.add(lineHeight);
        }
      }
      this._graphicsContext.restore();
      this._graphicsContext.save();
      if (tx.coordPlane === CoordPlane.Screen) {
        this._graphicsContext.translate(this._engine.screen.contentArea.left, this._engine.screen.contentArea.top);
      }
      this._graphicsContext.z = txSettings.debugZIndex;
      motion = entity.get(MotionComponent);
      if (motion) {
        if (motionSettings.showAll || motionSettings.showVelocity) {
          this._graphicsContext.debug.drawText(`vel${motion.vel.toString(2)}`, cursor.add(tx.globalPos));
          this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.vel), motionSettings.velocityColor, 2);
          cursor = cursor.add(lineHeight);
        }
        if (motionSettings.showAll || motionSettings.showAcceleration) {
          this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.acc), motionSettings.accelerationColor, 2);
        }
      }
      colliderComp = entity.get(ColliderComponent);
      if (colliderComp) {
        const collider = colliderComp.get();
        if ((colliderSettings.showAll || colliderSettings.showGeometry) && collider) {
          collider.debug(this._graphicsContext, colliderSettings.geometryColor, {
            lineWidth: colliderSettings.geometryLineWidth,
            pointSize: colliderSettings.geometryPointSize
          });
        }
        if (colliderSettings.showAll || colliderSettings.showBounds) {
          if (collider instanceof CompositeCollider) {
            const colliders = collider.getColliders();
            for (const collider2 of colliders) {
              const bounds = collider2.bounds;
              const pos = vec(bounds.left, bounds.top);
              this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
              if (colliderSettings.showAll || colliderSettings.showOwner) {
                this._graphicsContext.debug.drawText(`owner id(${collider2.owner.id})`, pos);
              }
            }
            colliderComp.bounds.draw(this._graphicsContext, colliderSettings.boundsColor);
          } else if (collider) {
            const bounds = colliderComp.bounds;
            const pos = vec(bounds.left, bounds.top);
            this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
            if (colliderSettings.showAll || colliderSettings.showOwner) {
              this._graphicsContext.debug.drawText(`owner id(${colliderComp.owner.id})`, pos);
            }
          }
        }
      }
      this._graphicsContext.restore();
      this._popCameraTransform(tx);
    }
    this._graphicsContext.save();
    this._camera.draw(this._graphicsContext);
    if (physicsSettings.showAll || physicsSettings.showBroadphaseSpacePartitionDebug) {
      this._collisionSystem.debug(this._graphicsContext);
    }
    if (physicsSettings.showAll || physicsSettings.showCollisionContacts || physicsSettings.showCollisionNormals) {
      for (const [_, contact] of this._engine.debug.stats.currFrame.physics.contacts) {
        if (physicsSettings.showAll || physicsSettings.showCollisionContacts) {
          for (const point2 of contact.points) {
            this._graphicsContext.debug.drawPoint(point2, {
              size: physicsSettings.contactSize,
              color: physicsSettings.collisionContactColor
            });
          }
        }
        if (physicsSettings.showAll || physicsSettings.showCollisionNormals) {
          for (const point2 of contact.points) {
            this._graphicsContext.debug.drawLine(point2, contact.normal.scale(30).add(point2), {
              color: physicsSettings.collisionNormalColor
            });
          }
        }
      }
    }
    this._graphicsContext.restore();
    if (cameraSettings) {
      this._graphicsContext.save();
      this._camera.draw(this._graphicsContext);
      if (cameraSettings.showAll || cameraSettings.showFocus) {
        this._graphicsContext.drawCircle(this._camera.pos, 4, cameraSettings.focusColor);
      }
      if (cameraSettings.showAll || cameraSettings.showZoom) {
        this._graphicsContext.debug.drawText(`zoom(${this._camera.zoom})`, this._camera.pos);
      }
      this._graphicsContext.restore();
    }
    this._graphicsContext.flush();
  }
  postupdate(engine, elapsed) {
    if (this._engine.isDebug) {
      this._graphicsContext.save();
      if (this._camera) {
        this._camera.draw(this._graphicsContext);
      }
      Debug.flush(this._graphicsContext);
      this._graphicsContext.restore();
    }
  }
  /**
   * This applies the current entity transform to the graphics context
   * @param entity
   */
  _applyTransform(entity) {
    const ancestors = entity.getAncestors();
    for (const ancestor of ancestors) {
      const transform = ancestor == null ? void 0 : ancestor.get(TransformComponent);
      if (transform) {
        this._graphicsContext.translate(transform.pos.x, transform.pos.y);
        this._graphicsContext.scale(transform.scale.x, transform.scale.y);
        this._graphicsContext.rotate(transform.rotation);
      }
    }
  }
  /**
   * Applies the current camera transform if in world coordinates
   * @param transform
   */
  _pushCameraTransform(transform) {
    if (transform.coordPlane === CoordPlane.World) {
      this._graphicsContext.save();
      if (this._camera) {
        this._camera.draw(this._graphicsContext);
      }
    }
  }
  /**
   * Resets the current camera transform if in world coordinates
   * @param transform
   */
  _popCameraTransform(transform) {
    if (transform.coordPlane === CoordPlane.World) {
      this._graphicsContext.restore();
    }
  }
}
DebugSystem.priority = SystemPriority.Lowest;
class PointerSystem extends System {
  constructor(world) {
    super();
    this.world = world;
    this.systemType = SystemType.Update;
    this._graphicsHashGrid = new SparseHashGrid({ size: 100 });
    this._graphics = [];
    this._entityToPointer = /* @__PURE__ */ new Map();
    this._pointerEventDispatcher = new PointerEventsToObjectDispatcher();
    this.overrideUseColliderShape = false;
    this.overrideUseGraphicsBounds = false;
    this._sortedTransforms = [];
    this._sortedEntities = [];
    this._zHasChanged = false;
    this._zIndexUpdate = () => {
      this._zHasChanged = true;
    };
    this.query = this.world.query([TransformComponent, PointerComponent]);
    this.query.entityAdded$.subscribe((e) => {
      const tx = e.get(TransformComponent);
      const pointer = e.get(PointerComponent);
      this._pointerEventDispatcher.addObject(
        e,
        (pos) => {
          if (pointer && pointer.localBounds) {
            const pointerBounds = pointer.localBounds.transform(tx.get().matrix);
            return pointerBounds.contains(tx.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos);
          }
          return false;
        },
        () => e.isActive
      );
      this._entityToPointer.set(e, pointer);
      const maybeGfx = e.get(GraphicsComponent);
      if (maybeGfx) {
        this._graphics.push(maybeGfx);
        this._graphicsHashGrid.track(maybeGfx);
      }
      this._sortedTransforms.push(tx);
      this._sortedEntities.push(tx.owner);
      tx.zIndexChanged$.subscribe(this._zIndexUpdate);
      this._zHasChanged = true;
    });
    this.query.entityRemoved$.subscribe((e) => {
      this._pointerEventDispatcher.removeObject(e);
      const tx = e.get(TransformComponent);
      this._entityToPointer.delete(e);
      const maybeGfx = e.get(GraphicsComponent);
      if (maybeGfx) {
        const index2 = this._graphics.indexOf(maybeGfx);
        if (index2 > -1) {
          this._graphics.splice(index2, 1);
        }
        this._graphicsHashGrid.untrack(maybeGfx);
      }
      tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);
      const index = this._sortedTransforms.indexOf(tx);
      if (index > -1) {
        this._sortedTransforms.splice(index, 1);
        this._sortedEntities.splice(index, 1);
      }
    });
  }
  initialize(world, scene) {
    this._engine = scene.engine;
    this._scene = scene;
  }
  preupdate() {
    if (this._scene.camera.hasChanged()) {
      this._scene.camera.updateTransform(this._scene.camera.pos);
    }
    this._receivers = [this._engine.input.pointers, this._scene.input.pointers];
    this._engineReceiver = this._engine.input.pointers;
    if (this._zHasChanged) {
      this._sortedTransforms.sort((a, b) => {
        return b.z - a.z;
      });
      this._sortedEntities = this._sortedTransforms.map((t) => t.owner);
      this._zHasChanged = false;
    }
  }
  update() {
    this._graphicsHashGrid.update(this._graphics);
    for (const [pointerId, pos] of this._engineReceiver.currentFramePointerCoords.entries()) {
      const colliders = this._scene.physics.query(pos.worldPos);
      for (let i = 0; i < colliders.length; i++) {
        const collider = colliders[i];
        const maybePointer = this._entityToPointer.get(collider.owner);
        if (maybePointer && (maybePointer.useColliderShape || this.overrideUseColliderShape)) {
          this._pointerEventDispatcher.addPointerToObject(collider.owner, pointerId);
        }
      }
      const graphics = this._graphicsHashGrid.query(pos.worldPos);
      for (let i = 0; i < graphics.length; i++) {
        const graphic = graphics[i];
        const maybePointer = this._entityToPointer.get(graphic.owner);
        if (maybePointer && (maybePointer.useGraphicsBounds || this.overrideUseGraphicsBounds)) {
          this._pointerEventDispatcher.addPointerToObject(graphic.owner, pointerId);
        }
      }
    }
    this._pointerEventDispatcher.processPointerToObject(this._engineReceiver, this._sortedEntities);
    this._pointerEventDispatcher.dispatchEvents(this._engineReceiver, this._sortedEntities);
    this._receivers.forEach((r) => r.update());
    this._pointerEventDispatcher.clear();
    this._receivers.forEach((r) => r.clear());
  }
}
PointerSystem.priority = SystemPriority.Higher;
class ActionsSystem extends System {
  constructor(world) {
    super();
    this.world = world;
    this.systemType = SystemType.Update;
    this._actions = [];
    this.query = this.world.query([ActionsComponent]);
    this.query.entityAdded$.subscribe((e) => this._actions.push(e.get(ActionsComponent)));
    this.query.entityRemoved$.subscribe((e) => {
      const action = e.get(ActionsComponent);
      const index = this._actions.indexOf(action);
      if (index > -1) {
        this._actions.splice(index, 1);
      }
    });
  }
  update(elapsed) {
    for (let i = 0; i < this._actions.length; i++) {
      const action = this._actions[i];
      action.update(elapsed);
    }
  }
}
ActionsSystem.priority = SystemPriority.Higher;
class Gamepads {
  constructor() {
    this.events = new EventEmitter();
    this.enabled = false;
    this.supported = !!navigator.getGamepads;
    this._gamePadTimeStamps = [0, 0, 0, 0];
    this._oldPads = [];
    this._pads = [];
    this._initSuccess = false;
    this._navigator = navigator;
    this._minimumConfiguration = null;
    this._enabled = true;
  }
  init() {
    if (!this.supported) {
      return;
    }
    if (this._initSuccess) {
      return;
    }
    this._oldPads = this._clonePads(this._navigator.getGamepads());
    if (this._oldPads.length && this._oldPads[0]) {
      this._initSuccess = true;
    }
  }
  toggleEnabled(enabled) {
    this._enabled = enabled;
  }
  /**
   * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means
   * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive
   * all other controllers with more axis or buttons are valid as well. If no minimum
   * configuration is set all pads are valid.
   */
  setMinimumGamepadConfiguration(config) {
    this._enableAndUpdate();
    this._minimumConfiguration = config;
  }
  /**
   * When implicitly enabled, set the enabled flag and run an update so information is updated
   */
  _enableAndUpdate() {
    if (!this.enabled) {
      this.enabled = true;
      this.update();
    }
  }
  /**
   * Checks a navigator gamepad against the minimum configuration if present.
   */
  _isGamepadValid(pad) {
    if (!this._minimumConfiguration) {
      return true;
    }
    if (!pad) {
      return false;
    }
    const axesLength = pad.axes.filter((value) => {
      return typeof value !== void 0;
    }).length;
    const buttonLength = pad.buttons.filter((value) => {
      return typeof value !== void 0;
    }).length;
    return axesLength >= this._minimumConfiguration.axis && buttonLength >= this._minimumConfiguration.buttons && pad.connected;
  }
  emit(eventName, event) {
    this.events.emit(eventName, event);
  }
  on(eventName, handler) {
    this._enableAndUpdate();
    return this.events.on(eventName, handler);
  }
  once(eventName, handler) {
    this._enableAndUpdate();
    return this.events.once(eventName, handler);
  }
  off(eventName, handler) {
    this._enableAndUpdate();
    this.events.off(eventName, handler);
  }
  /**
   * Updates Gamepad state and publishes Gamepad events
   */
  update() {
    var _a, _b;
    if (!this.enabled || !this.supported) {
      return;
    }
    if (!this._enabled) {
      return;
    }
    this.init();
    const gamepads = this._navigator.getGamepads();
    for (let i = 0; i < gamepads.length; i++) {
      if (!gamepads[i]) {
        const gamepad2 = this.at(i);
        if (gamepad2.connected) {
          this.events.emit("disconnect", new GamepadDisconnectEvent(i, gamepad2));
          gamepad2.events.unpipe(this.events);
        }
        gamepad2.connected = false;
        continue;
      } else {
        const gamepad2 = this.at(i);
        if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {
          gamepad2.events.pipe(this.events);
          this.events.emit("connect", new GamepadConnectEvent(i, this.at(i)));
        }
        this.at(i).connected = true;
      }
      this.at(i).update();
      if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
        continue;
      }
      this._gamePadTimeStamps[i] = gamepads[i].timestamp;
      this.at(i).navigatorGamepad = gamepads[i];
      const gamepad = gamepads[i];
      if (gamepad) {
        for (let buttonIndex = 0; buttonIndex < gamepad.buttons.length; buttonIndex++) {
          const button = gamepad.buttons[buttonIndex];
          const value = button == null ? void 0 : button.value;
          if (value !== ((_a = this._oldPads[i]) == null ? void 0 : _a.getButton(buttonIndex))) {
            if (button == null ? void 0 : button.pressed) {
              this.at(i).updateButton(buttonIndex, value);
              this.at(i).events.emit(
                "button",
                new GamepadButtonEvent(
                  buttonIndex in Buttons ? buttonIndex : -1,
                  buttonIndex,
                  value,
                  this.at(i)
                )
              );
            } else {
              this.at(i).updateButton(buttonIndex, 0);
            }
          }
        }
        for (let axesIndex = 0; axesIndex < gamepad.axes.length; axesIndex++) {
          const axis = gamepad.axes[axesIndex];
          if (axis !== ((_b = this._oldPads[i]) == null ? void 0 : _b.getAxes(axesIndex))) {
            this.at(i).updateAxes(axesIndex, axis);
            this.at(i).events.emit("axis", new GamepadAxisEvent(axesIndex, axis, this.at(i)));
          }
        }
      }
      this._oldPads[i] = this._clonePad(gamepads[i]);
    }
  }
  /**
   * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
   */
  at(index) {
    this._enableAndUpdate();
    if (index >= this._pads.length) {
      for (let i = this._pads.length - 1, max = index; i < max; i++) {
        this._pads.push(new Gamepad());
        this._oldPads.push(new Gamepad());
      }
    }
    return this._pads[index];
  }
  /**
   * Returns a list of all valid gamepads that meet the minimum configuration requirement.
   */
  getValidGamepads() {
    this._enableAndUpdate();
    const result = [];
    for (let i = 0; i < this._pads.length; i++) {
      if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {
        result.push(this.at(i));
      }
    }
    return result;
  }
  /**
   * Gets the number of connected gamepads
   */
  count() {
    return this._pads.filter((p) => p.connected).length;
  }
  _clonePads(pads) {
    const arr = [];
    for (let i = 0, len = pads.length; i < len; i++) {
      arr.push(this._clonePad(pads[i]));
    }
    return arr;
  }
  /**
   * Fastest way to clone a known object is to do it yourself
   */
  _clonePad(pad) {
    let i, len;
    const clonedPad = new Gamepad();
    if (!pad) {
      return clonedPad;
    }
    for (i = 0, len = pad.buttons.length; i < len; i++) {
      if (pad.buttons[i]) {
        clonedPad.updateButton(i, pad.buttons[i].value);
      }
    }
    for (i = 0, len = pad.axes.length; i < len; i++) {
      clonedPad.updateAxes(i, pad.axes[i]);
    }
    return clonedPad;
  }
}
Gamepads.MinAxisMoveThreshold = 0.05;
class Gamepad {
  constructor() {
    this.events = new EventEmitter();
    this.connected = false;
    this._axes = new Array(4);
    this._buttons = new Array(16);
    this._buttonsUp = new Array(16);
    this._buttonsDown = new Array(16);
    for (let i = 0; i < this._buttons.length; i++) {
      this._buttons[i] = 0;
    }
    for (let i = 0; i < this._axes.length; i++) {
      this._axes[i] = 0;
    }
  }
  update() {
    this._buttonsDown = new Array(16);
    this._buttonsUp = new Array(16);
  }
  /**
   * Whether or not the given button is pressed
   * @deprecated will be removed in v0.28.0. Use isButtonHeld instead
   * @param button     The button to query
   * @param threshold  The threshold over which the button is considered to be pressed
   */
  isButtonPressed(button, threshold = 1) {
    return this._buttons[button] >= threshold;
  }
  /**
   * Tests if a certain button is held down. This is persisted between frames.
   * @param button     The button to query
   * @param threshold  The threshold over which the button is considered to be pressed
   */
  isButtonHeld(button, threshold = 1) {
    return this._buttons[button] >= threshold;
  }
  /**
   * Tests if a certain button was just pressed this frame. This is cleared at the end of the update frame.
   * @param button Test whether a button was just pressed
   * @param threshold  The threshold over which the button is considered to be pressed
   */
  wasButtonPressed(button, threshold = 1) {
    return this._buttonsDown[button] >= threshold;
  }
  /**
   * Tests if a certain button was just released this frame. This is cleared at the end of the update frame.
   * @param button  Test whether a button was just released
   */
  wasButtonReleased(button) {
    return Boolean(this._buttonsUp[button]);
  }
  /**
   * Gets the given button value between 0 and 1
   */
  getButton(button) {
    return this._buttons[button];
  }
  /**
   * Gets the given axis value between -1 and 1. Values below
   * {@apilink MinAxisMoveThreshold} are considered 0.
   */
  getAxes(axes) {
    const value = this._axes[axes];
    if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
      return 0;
    } else {
      return value;
    }
  }
  updateButton(buttonIndex, value) {
    if (value === 0 && this._buttons[buttonIndex]) {
      this._buttonsUp[buttonIndex] = 1;
    } else {
      this._buttonsDown[buttonIndex] = value;
    }
    this._buttons[buttonIndex] = value;
  }
  updateAxes(axesIndex, value) {
    this._axes[axesIndex] = value;
  }
  emit(eventName, event) {
    this.events.emit(eventName, event);
  }
  on(eventName, handler) {
    return this.events.on(eventName, handler);
  }
  once(eventName, handler) {
    return this.events.once(eventName, handler);
  }
  off(eventName, handler) {
    this.events.off(eventName, handler);
  }
}
var Buttons = /* @__PURE__ */ ((Buttons2) => {
  Buttons2[Buttons2["Unknown"] = -1] = "Unknown";
  Buttons2[Buttons2["Face1"] = 0] = "Face1";
  Buttons2[Buttons2["Face2"] = 1] = "Face2";
  Buttons2[Buttons2["Face3"] = 2] = "Face3";
  Buttons2[Buttons2["Face4"] = 3] = "Face4";
  Buttons2[Buttons2["LeftBumper"] = 4] = "LeftBumper";
  Buttons2[Buttons2["RightBumper"] = 5] = "RightBumper";
  Buttons2[Buttons2["LeftTrigger"] = 6] = "LeftTrigger";
  Buttons2[Buttons2["RightTrigger"] = 7] = "RightTrigger";
  Buttons2[Buttons2["Select"] = 8] = "Select";
  Buttons2[Buttons2["Start"] = 9] = "Start";
  Buttons2[Buttons2["LeftStick"] = 10] = "LeftStick";
  Buttons2[Buttons2["RightStick"] = 11] = "RightStick";
  Buttons2[Buttons2["DpadUp"] = 12] = "DpadUp";
  Buttons2[Buttons2["DpadDown"] = 13] = "DpadDown";
  Buttons2[Buttons2["DpadLeft"] = 14] = "DpadLeft";
  Buttons2[Buttons2["DpadRight"] = 15] = "DpadRight";
  Buttons2[Buttons2["CenterButton"] = 16] = "CenterButton";
  Buttons2[Buttons2["MiscButton1"] = 17] = "MiscButton1";
  return Buttons2;
})(Buttons || {});
var Axes = /* @__PURE__ */ ((Axes2) => {
  Axes2[Axes2["LeftStickX"] = 0] = "LeftStickX";
  Axes2[Axes2["LeftStickY"] = 1] = "LeftStickY";
  Axes2[Axes2["RightStickX"] = 2] = "RightStickX";
  Axes2[Axes2["RightStickY"] = 3] = "RightStickY";
  return Axes2;
})(Axes || {});
class InputMapper {
  constructor(inputs) {
    this.inputs = inputs;
    this._handlers = /* @__PURE__ */ new Map();
  }
  /**
   * Executes the input map, called internally by Excalibur
   */
  execute() {
    for (const [input, command] of this._handlers.entries()) {
      const results = input(this.inputs);
      if (results) {
        command(results);
      }
    }
  }
  /**
   * This allows you to map multiple inputs to specific commands! This is useful
   *
   * The inputHandler should return a truthy value if you wish the commandHandler to fire.
   *
   * Example:
   * ```typescript
   * const moveRight = (amount: number) => { actor.vel.x = 100 * amount }
   * const moveLeft = (amount: number) => { actor.vel.x = -100 * amount }
   * const moveUp = (amount: number) => { actor.vel.y = -100 * amount }
   * const moveDown = (amount: number) => { actor.vel.y = 100 * amount }
   *
   * engine.inputMapper.on(({keyboard}) => keyboard.isHeld(ex.Keys.ArrowRight) ? 1 : 0, moveRight);
   * engine.inputMapper.on(({gamepads}) => gamepads.at(0).isButtonPressed(ex.Buttons.DpadRight) ? 1 : 0, moveRight);
   * engine.inputMapper.on(({gamepads}) => gamepads.at(0).getAxes(ex.Axes.LeftStickX) > 0 ?
   *  gamepads.at(0).getAxes(ex.Axes.LeftStickX) : 0, moveRight);
   * ```
   * @param inputHandler
   * @param commandHandler
   */
  on(inputHandler, commandHandler) {
    this._handlers.set(inputHandler, commandHandler);
  }
}
function isCrossOriginIframe() {
  try {
    const noop = () => {
      return;
    };
    window.top.addEventListener("blur", noop);
    window.top.removeEventListener("blur", noop);
  } catch (e) {
    return true;
  }
  return false;
}
function isIframe() {
  return window !== window.top;
}
function getDefaultGlobal() {
  let global;
  if (isCrossOriginIframe()) {
    global = window;
    Logger.getInstance().warnOnce("Excalibur might be in a cross-origin iframe, in order to receive keyboard events it must be in focus");
  } else if (isIframe()) {
    global = window;
    Logger.getInstance().warnOnce("Excalibur might be in a iframe, in order to receive keyboard events it must be in focus");
  } else {
    global = window.top;
  }
  return global;
}
var Keys = /* @__PURE__ */ ((Keys2) => {
  Keys2["Backquote"] = "Backquote";
  Keys2["Backslash"] = "Backslash";
  Keys2["BracketLeft"] = "BracketLeft";
  Keys2["BracketRight"] = "BracketRight";
  Keys2["Comma"] = "Comma";
  Keys2["Key0"] = "Digit0";
  Keys2["Key1"] = "Digit1";
  Keys2["Key2"] = "Digit2";
  Keys2["Key3"] = "Digit3";
  Keys2["Key4"] = "Digit4";
  Keys2["Key5"] = "Digit5";
  Keys2["Key6"] = "Digit6";
  Keys2["Key7"] = "Digit7";
  Keys2["Key8"] = "Digit8";
  Keys2["Key9"] = "Digit9";
  Keys2["Digit0"] = "Digit0";
  Keys2["Digit1"] = "Digit1";
  Keys2["Digit2"] = "Digit2";
  Keys2["Digit3"] = "Digit3";
  Keys2["Digit4"] = "Digit4";
  Keys2["Digit5"] = "Digit5";
  Keys2["Digit6"] = "Digit6";
  Keys2["Digit7"] = "Digit7";
  Keys2["Digit8"] = "Digit8";
  Keys2["Digit9"] = "Digit9";
  Keys2["Equal"] = "Equal";
  Keys2["IntlBackslash"] = "IntlBackslash";
  Keys2["IntlRo"] = "IntlRo";
  Keys2["IntlYen"] = "IntlYen";
  Keys2["A"] = "KeyA";
  Keys2["B"] = "KeyB";
  Keys2["C"] = "KeyC";
  Keys2["D"] = "KeyD";
  Keys2["E"] = "KeyE";
  Keys2["F"] = "KeyF";
  Keys2["G"] = "KeyG";
  Keys2["H"] = "KeyH";
  Keys2["I"] = "KeyI";
  Keys2["J"] = "KeyJ";
  Keys2["K"] = "KeyK";
  Keys2["L"] = "KeyL";
  Keys2["M"] = "KeyM";
  Keys2["N"] = "KeyN";
  Keys2["O"] = "KeyO";
  Keys2["P"] = "KeyP";
  Keys2["Q"] = "KeyQ";
  Keys2["R"] = "KeyR";
  Keys2["S"] = "KeyS";
  Keys2["T"] = "KeyT";
  Keys2["U"] = "KeyU";
  Keys2["V"] = "KeyV";
  Keys2["W"] = "KeyW";
  Keys2["X"] = "KeyX";
  Keys2["Y"] = "KeyY";
  Keys2["Z"] = "KeyZ";
  Keys2["KeyA"] = "KeyA";
  Keys2["KeyB"] = "KeyB";
  Keys2["KeyC"] = "KeyC";
  Keys2["KeyD"] = "KeyD";
  Keys2["KeyE"] = "KeyE";
  Keys2["KeyF"] = "KeyF";
  Keys2["KeyG"] = "KeyG";
  Keys2["KeyH"] = "KeyH";
  Keys2["KeyI"] = "KeyI";
  Keys2["KeyJ"] = "KeyJ";
  Keys2["KeyK"] = "KeyK";
  Keys2["KeyL"] = "KeyL";
  Keys2["KeyM"] = "KeyM";
  Keys2["KeyN"] = "KeyN";
  Keys2["KeyO"] = "KeyO";
  Keys2["KeyP"] = "KeyP";
  Keys2["KeyQ"] = "KeyQ";
  Keys2["KeyR"] = "KeyR";
  Keys2["KeyS"] = "KeyS";
  Keys2["KeyT"] = "KeyT";
  Keys2["KeyU"] = "KeyU";
  Keys2["KeyV"] = "KeyV";
  Keys2["KeyW"] = "KeyW";
  Keys2["KeyX"] = "KeyX";
  Keys2["KeyY"] = "KeyY";
  Keys2["KeyZ"] = "KeyZ";
  Keys2["Minus"] = "Minus";
  Keys2["Period"] = "Period";
  Keys2["Quote"] = "Quote";
  Keys2["Semicolon"] = "Semicolon";
  Keys2["Slash"] = "Slash";
  Keys2["AltLeft"] = "AltLeft";
  Keys2["AltRight"] = "AltRight";
  Keys2["Alt"] = "Alt";
  Keys2["AltGraph"] = "AltGraph";
  Keys2["Backspace"] = "Backspace";
  Keys2["CapsLock"] = "CapsLock";
  Keys2["ContextMenu"] = "ContextMenu";
  Keys2["ControlLeft"] = "ControlLeft";
  Keys2["ControlRight"] = "ControlRight";
  Keys2["Enter"] = "Enter";
  Keys2["MetaLeft"] = "MetaLeft";
  Keys2["MetaRight"] = "MetaRight";
  Keys2["ShiftLeft"] = "ShiftLeft";
  Keys2["ShiftRight"] = "ShiftRight";
  Keys2["Space"] = "Space";
  Keys2["Tab"] = "Tab";
  Keys2["Convert"] = "Convert";
  Keys2["KanaMode"] = "KanaMode";
  Keys2["NonConvert"] = "NonConvert";
  Keys2["Delete"] = "Delete";
  Keys2["End"] = "End";
  Keys2["Help"] = "Help";
  Keys2["Home"] = "Home";
  Keys2["Insert"] = "Insert";
  Keys2["PageDown"] = "PageDown";
  Keys2["PageUp"] = "PageUp";
  Keys2["Up"] = "ArrowUp";
  Keys2["Down"] = "ArrowDown";
  Keys2["Left"] = "ArrowLeft";
  Keys2["Right"] = "ArrowRight";
  Keys2["ArrowUp"] = "ArrowUp";
  Keys2["ArrowDown"] = "ArrowDown";
  Keys2["ArrowLeft"] = "ArrowLeft";
  Keys2["ArrowRight"] = "ArrowRight";
  Keys2["NumLock"] = "NumLock";
  Keys2["Numpad0"] = "Numpad0";
  Keys2["Numpad1"] = "Numpad1";
  Keys2["Numpad2"] = "Numpad2";
  Keys2["Numpad3"] = "Numpad3";
  Keys2["Numpad4"] = "Numpad4";
  Keys2["Numpad5"] = "Numpad5";
  Keys2["Numpad6"] = "Numpad6";
  Keys2["Numpad7"] = "Numpad7";
  Keys2["Numpad8"] = "Numpad8";
  Keys2["Numpad9"] = "Numpad9";
  Keys2["Num0"] = "Numpad0";
  Keys2["Num1"] = "Numpad1";
  Keys2["Num2"] = "Numpad2";
  Keys2["Num3"] = "Numpad3";
  Keys2["Num4"] = "Numpad4";
  Keys2["Num5"] = "Numpad5";
  Keys2["Num6"] = "Numpad6";
  Keys2["Num7"] = "Numpad7";
  Keys2["Num8"] = "Numpad8";
  Keys2["Num9"] = "Numpad9";
  Keys2["NumAdd"] = "NumpadAdd";
  Keys2["NumpadAdd"] = "NumpadAdd";
  Keys2["NumDecimal"] = "NumpadDecimal";
  Keys2["NumpadDecimal"] = "NumpadDecimal";
  Keys2["NumDivide"] = "NumpadDivide";
  Keys2["NumpadDivide"] = "NumpadDivide";
  Keys2["NumEnter"] = "NumpadEnter";
  Keys2["NumpadEnter"] = "NumpadEnter";
  Keys2["NumMultiply"] = "NumpadMultiply";
  Keys2["NumpadMultiply"] = "NumpadMultiply";
  Keys2["NumSubtract"] = "NumpadSubtract";
  Keys2["NumpadSubtract"] = "NumpadSubtract";
  Keys2["Esc"] = "Escape";
  Keys2["Escape"] = "Escape";
  Keys2["F1"] = "F1";
  Keys2["F2"] = "F2";
  Keys2["F3"] = "F3";
  Keys2["F4"] = "F4";
  Keys2["F5"] = "F5";
  Keys2["F6"] = "F6";
  Keys2["F7"] = "F7";
  Keys2["F8"] = "F8";
  Keys2["F9"] = "F9";
  Keys2["F10"] = "F10";
  Keys2["F11"] = "F11";
  Keys2["F12"] = "F12";
  Keys2["F13"] = "F13";
  Keys2["F14"] = "F14";
  Keys2["F15"] = "F15";
  Keys2["F16"] = "F16";
  Keys2["F17"] = "F17";
  Keys2["F18"] = "F18";
  Keys2["F19"] = "F19";
  Keys2["F20"] = "F20";
  Keys2["PrintScreen"] = "PrintScreen";
  Keys2["ScrollLock"] = "ScrollLock";
  Keys2["Pause"] = "Pause";
  Keys2["Unidentified"] = "Unidentified";
  return Keys2;
})(Keys || {});
class KeyEvent extends GameEvent {
  /**
   * @param key  The key responsible for throwing the event
   * @param value The key's typed value the browser detected
   * @param originalEvent The original keyboard event that Excalibur handled
   */
  constructor(key, value, originalEvent) {
    super();
    this.key = key;
    this.value = value;
    this.originalEvent = originalEvent;
  }
}
class Keyboard {
  constructor() {
    this.events = new EventEmitter();
    this._enabled = true;
    this._keys = [];
    this._keysUp = [];
    this._keysDown = [];
    this._releaseAllKeys = (ev) => {
      for (const code of this._keys) {
        const keyEvent = new KeyEvent(code, ev.key, ev);
        this.events.emit("up", keyEvent);
        this.events.emit("release", keyEvent);
      }
      this._keysUp = Array.from(new Set(this._keys.concat(this._keysUp)));
      this._keys.length = 0;
    };
    this._handleKeyDown = (ev) => {
      if (!this._enabled) {
        return;
      }
      if (!ev.metaKey && (this._keys.includes(
        "MetaLeft"
        /* MetaLeft */
      ) || this._keys.includes(
        "MetaRight"
        /* MetaRight */
      ))) {
        this._releaseAllKeys(ev);
      }
      const code = ev.code;
      if (this._keys.indexOf(code) === -1) {
        this._keys.push(code);
        this._keysDown.push(code);
        const keyEvent = new KeyEvent(code, ev.key, ev);
        this.events.emit("down", keyEvent);
        this.events.emit("press", keyEvent);
      }
    };
    this._handleKeyUp = (ev) => {
      if (!this._enabled) {
        return;
      }
      const code = ev.code;
      const key = this._keys.indexOf(code);
      this._keys.splice(key, 1);
      this._keysUp.push(code);
      const keyEvent = new KeyEvent(code, ev.key, ev);
      this.events.emit("up", keyEvent);
      this.events.emit("release", keyEvent);
      if (ev.key === "Meta") {
        this._releaseAllKeys(ev);
      }
    };
  }
  emit(eventName, event) {
    this.events.emit(eventName, event);
  }
  on(eventName, handler) {
    return this.events.on(eventName, handler);
  }
  once(eventName, handler) {
    return this.events.once(eventName, handler);
  }
  off(eventName, handler) {
    this.events.off(eventName, handler);
  }
  /**
   * Initialize Keyboard event listeners
   */
  init(keyboardOptions) {
    let { global } = keyboardOptions;
    const { grabWindowFocus } = keyboardOptions;
    if (!global) {
      global = getDefaultGlobal();
    } else if (typeof global === "function") {
      global = global();
    }
    if (grabWindowFocus) {
      global.focus();
    }
    global.addEventListener("blur", () => {
      this._keys.length = 0;
    });
    global.addEventListener("keyup", this._handleKeyUp);
    global.addEventListener("keydown", this._handleKeyDown);
  }
  toggleEnabled(enabled) {
    this._enabled = enabled;
  }
  clear() {
    this._keysDown.length = 0;
    this._keysUp.length = 0;
    this._keys.length = 0;
  }
  update() {
    this._keysDown.length = 0;
    this._keysUp.length = 0;
    for (let i = 0; i < this._keys.length; i++) {
      this.events.emit("hold", new KeyEvent(this._keys[i]));
    }
  }
  /**
   * Gets list of keys being pressed down
   */
  getKeys() {
    return this._keys;
  }
  /**
   * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.
   * @param key Test whether a key was just pressed
   */
  wasPressed(key) {
    if (!this._enabled) {
      return false;
    }
    return this._keysDown.indexOf(key) > -1;
  }
  /**
   * Tests if a certain key is held down. This is persisted between frames.
   * @param key  Test whether a key is held down
   */
  isHeld(key) {
    if (!this._enabled) {
      return false;
    }
    return this._keys.indexOf(key) > -1;
  }
  /**
   * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.
   * @param key  Test whether a key was just released
   */
  wasReleased(key) {
    if (!this._enabled) {
      return false;
    }
    return this._keysUp.indexOf(key) > -1;
  }
  /**
   * Trigger a manual key event
   * @param type
   * @param key
   * @param character
   */
  triggerEvent(type, key, character) {
    if (type === "down") {
      this._handleKeyDown(
        new KeyboardEvent("keydown", {
          code: key,
          key: character != null ? character : null
        })
      );
    }
    if (type === "up") {
      this._handleKeyUp(
        new KeyboardEvent("keyup", {
          code: key,
          key: character != null ? character : null
        })
      );
    }
  }
}
class PointerEvent {
  constructor(type, pointerId, button, pointerType, coordinates, nativeEvent) {
    this.type = type;
    this.pointerId = pointerId;
    this.button = button;
    this.pointerType = pointerType;
    this.coordinates = coordinates;
    this.nativeEvent = nativeEvent;
    this.active = true;
  }
  cancel() {
    this.active = false;
  }
  get pagePos() {
    return this.coordinates.pagePos;
  }
  get screenPos() {
    return this.coordinates.screenPos;
  }
  get worldPos() {
    return this.coordinates.worldPos;
  }
}
class WheelEvent {
  constructor(x, y, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev) {
    this.x = x;
    this.y = y;
    this.pageX = pageX;
    this.pageY = pageY;
    this.screenX = screenX;
    this.screenY = screenY;
    this.index = index;
    this.deltaX = deltaX;
    this.deltaY = deltaY;
    this.deltaZ = deltaZ;
    this.deltaMode = deltaMode;
    this.ev = ev;
    this.active = true;
  }
  cancel() {
    this.active = false;
  }
}
class PointerAbstraction {
  constructor() {
    this.events = new EventEmitter();
    this.lastPagePos = Vector.Zero;
    this.lastScreenPos = Vector.Zero;
    this.lastWorldPos = Vector.Zero;
    this._onPointerMove = (ev) => {
      this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);
      this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);
      this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);
    };
    this._onPointerDown = (ev) => {
      this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);
      this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);
      this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);
    };
    this.on("move", this._onPointerMove);
    this.on("down", this._onPointerDown);
  }
  emit(eventName, event) {
    this.events.emit(eventName, event);
  }
  on(eventName, handler) {
    return this.events.on(eventName, handler);
  }
  once(eventName, handler) {
    return this.events.once(eventName, handler);
  }
  off(eventName, handler) {
    this.events.off(eventName, handler);
  }
  /**
   * Called internally by excalibur to keep pointers up to date
   * @internal
   * @param engine
   */
  _updateWorldPosition(engine) {
    const coord = GlobalCoordinates.fromPagePosition(this.lastPagePos, engine);
    this.lastScreenPos = coord.screenPos;
    this.lastWorldPos = coord.worldPos;
  }
}
var WheelDeltaMode = /* @__PURE__ */ ((WheelDeltaMode2) => {
  WheelDeltaMode2["Pixel"] = "Pixel";
  WheelDeltaMode2["Line"] = "Line";
  WheelDeltaMode2["Page"] = "Page";
  return WheelDeltaMode2;
})(WheelDeltaMode || {});
var NativePointerButton = /* @__PURE__ */ ((NativePointerButton2) => {
  NativePointerButton2[NativePointerButton2["NoButton"] = -1] = "NoButton";
  NativePointerButton2[NativePointerButton2["Left"] = 0] = "Left";
  NativePointerButton2[NativePointerButton2["Middle"] = 1] = "Middle";
  NativePointerButton2[NativePointerButton2["Right"] = 2] = "Right";
  NativePointerButton2[NativePointerButton2["Unknown"] = 3] = "Unknown";
  return NativePointerButton2;
})(NativePointerButton || {});
var PointerButton = /* @__PURE__ */ ((PointerButton2) => {
  PointerButton2["Left"] = "Left";
  PointerButton2["Middle"] = "Middle";
  PointerButton2["Right"] = "Right";
  PointerButton2["Unknown"] = "Unknown";
  PointerButton2["NoButton"] = "NoButton";
  return PointerButton2;
})(PointerButton || {});
var PointerType = /* @__PURE__ */ ((PointerType2) => {
  PointerType2["Touch"] = "Touch";
  PointerType2["Mouse"] = "Mouse";
  PointerType2["Pen"] = "Pen";
  PointerType2["Unknown"] = "Unknown";
  return PointerType2;
})(PointerType || {});
function isTouchEvent(value) {
  return globalThis.TouchEvent && value instanceof globalThis.TouchEvent;
}
function isPointerEvent(value) {
  return globalThis.PointerEvent && value instanceof globalThis.PointerEvent;
}
class PointerEventReceiver {
  constructor(target, engine) {
    this.target = target;
    this.engine = engine;
    this.events = new EventEmitter();
    this.primary = new PointerAbstraction();
    this._activeNativePointerIdsToNormalized = /* @__PURE__ */ new Map();
    this.lastFramePointerCoords = /* @__PURE__ */ new Map();
    this.currentFramePointerCoords = /* @__PURE__ */ new Map();
    this.currentFramePointerDown = /* @__PURE__ */ new Map();
    this.lastFramePointerDown = /* @__PURE__ */ new Map();
    this.currentFrameDown = [];
    this.currentFrameUp = [];
    this.currentFrameMove = [];
    this.currentFrameCancel = [];
    this.currentFrameWheel = [];
    this._enabled = true;
    this._pointers = [this.primary];
    this._boundHandle = this._handle.bind(this);
    this._boundWheel = this._handleWheel.bind(this);
  }
  toggleEnabled(enabled) {
    this._enabled = enabled;
  }
  /**
   * Creates a new PointerEventReceiver with a new target and engine while preserving existing pointer event
   * handlers.
   * @param target
   * @param engine
   */
  recreate(target, engine) {
    const eventReceiver = new PointerEventReceiver(target, engine);
    eventReceiver.primary = this.primary;
    eventReceiver._pointers = this._pointers;
    return eventReceiver;
  }
  /**
   * Locates a specific pointer by id, creates it if it doesn't exist
   * @param index
   */
  at(index) {
    if (index >= this._pointers.length) {
      for (let i = this._pointers.length - 1, max = index; i < max; i++) {
        this._pointers.push(new PointerAbstraction());
      }
    }
    return this._pointers[index];
  }
  /**
   * The number of pointers currently being tracked by excalibur
   */
  count() {
    return this._pointers.length;
  }
  /**
   * Is the specified pointer id down this frame
   * @param pointerId
   */
  isDown(pointerId) {
    var _a;
    if (!this._enabled) {
      return false;
    }
    return (_a = this.currentFramePointerDown.get(pointerId)) != null ? _a : false;
  }
  /**
   * Was the specified pointer id down last frame
   * @param pointerId
   */
  wasDown(pointerId) {
    var _a;
    if (!this._enabled) {
      return false;
    }
    return (_a = this.lastFramePointerDown.get(pointerId)) != null ? _a : false;
  }
  /**
   * Whether the Pointer is currently dragging.
   */
  isDragging(pointerId) {
    if (!this._enabled) {
      return false;
    }
    return this.isDown(pointerId);
  }
  /**
   * Whether the Pointer just started dragging.
   */
  isDragStart(pointerId) {
    if (!this._enabled) {
      return false;
    }
    return this.isDown(pointerId) && !this.wasDown(pointerId);
  }
  /**
   * Whether the Pointer just ended dragging.
   */
  isDragEnd(pointerId) {
    if (!this._enabled) {
      return false;
    }
    return !this.isDown(pointerId) && this.wasDown(pointerId);
  }
  emit(eventName, event) {
    this.events.emit(eventName, event);
  }
  on(eventName, handler) {
    return this.events.on(eventName, handler);
  }
  once(eventName, handler) {
    return this.events.once(eventName, handler);
  }
  off(eventName, handler) {
    this.events.off(eventName, handler);
  }
  /**
   * Called internally by excalibur
   *
   * Updates the current frame pointer info and emits raw pointer events
   *
   * This does not emit events to entities, see PointerSystem
   * @internal
   */
  update() {
    this.lastFramePointerDown = new Map(this.currentFramePointerDown);
    this.lastFramePointerCoords = new Map(this.currentFramePointerCoords);
    for (const event of this.currentFrameDown) {
      if (!event.active) {
        continue;
      }
      this.emit("down", event);
      const pointer = this.at(event.pointerId);
      pointer.emit("down", event);
      this.primary.emit("pointerdown", event);
    }
    for (const event of this.currentFrameUp) {
      if (!event.active) {
        continue;
      }
      this.emit("up", event);
      const pointer = this.at(event.pointerId);
      pointer.emit("up", event);
    }
    for (const event of this.currentFrameMove) {
      if (!event.active) {
        continue;
      }
      this.emit("move", event);
      const pointer = this.at(event.pointerId);
      pointer.emit("move", event);
    }
    for (const event of this.currentFrameCancel) {
      if (!event.active) {
        continue;
      }
      this.emit("cancel", event);
      const pointer = this.at(event.pointerId);
      pointer.emit("cancel", event);
    }
    for (const event of this.currentFrameWheel) {
      if (!event.active) {
        continue;
      }
      this.emit("pointerwheel", event);
      this.emit("wheel", event);
      this.primary.emit("pointerwheel", event);
      this.primary.emit("wheel", event);
    }
    if (this.engine.currentScene.camera.hasChanged()) {
      for (const pointer of this._pointers) {
        pointer._updateWorldPosition(this.engine);
      }
    }
  }
  /**
   * Clears the current frame event and pointer data
   */
  clear() {
    for (const event of this.currentFrameUp) {
      this.currentFramePointerCoords.delete(event.pointerId);
      const ids = this._activeNativePointerIdsToNormalized.entries();
      for (const [native, normalized] of ids) {
        if (normalized === event.pointerId) {
          this._activeNativePointerIdsToNormalized.delete(native);
        }
      }
    }
    this.currentFrameDown.length = 0;
    this.currentFrameUp.length = 0;
    this.currentFrameMove.length = 0;
    this.currentFrameCancel.length = 0;
    this.currentFrameWheel.length = 0;
  }
  /**
   * Initializes the pointer event receiver so that it can start listening to native
   * browser events.
   */
  init(options) {
    var _a;
    if (this.engine.isDisposed()) {
      return;
    }
    if (this.target === this.engine.canvas) {
      this.engine.canvas.style.touchAction = "none";
    } else {
      document.body.style.touchAction = "none";
    }
    if (window.PointerEvent) {
      this.target.addEventListener("pointerdown", this._boundHandle);
      this.target.addEventListener("pointerup", this._boundHandle);
      this.target.addEventListener("pointermove", this._boundHandle);
      this.target.addEventListener("pointercancel", this._boundHandle);
    } else {
      this.target.addEventListener("touchstart", this._boundHandle);
      this.target.addEventListener("touchend", this._boundHandle);
      this.target.addEventListener("touchmove", this._boundHandle);
      this.target.addEventListener("touchcancel", this._boundHandle);
      this.target.addEventListener("mousedown", this._boundHandle);
      this.target.addEventListener("mouseup", this._boundHandle);
      this.target.addEventListener("mousemove", this._boundHandle);
    }
    const wheelOptions = {
      passive: !(this.engine.pageScrollPreventionMode === ScrollPreventionMode.All || this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas)
    };
    if ("onwheel" in document.createElement("div")) {
      this.target.addEventListener("wheel", this._boundWheel, wheelOptions);
    } else if (document.onmousewheel !== void 0) {
      this.target.addEventListener("mousewheel", this._boundWheel, wheelOptions);
    } else {
      this.target.addEventListener("MozMousePixelScroll", this._boundWheel, wheelOptions);
    }
    const grabWindowFocus = (_a = options == null ? void 0 : options.grabWindowFocus) != null ? _a : true;
    if (grabWindowFocus && (isCrossOriginIframe() || isIframe())) {
      const grabFocus = () => {
        window.focus();
      };
      if (window.PointerEvent) {
        this.target.addEventListener("pointerdown", grabFocus);
      } else {
        this.target.addEventListener("touchstart", grabFocus);
        this.target.addEventListener("mousedown", grabFocus);
      }
    }
  }
  detach() {
    if (window.PointerEvent) {
      this.target.removeEventListener("pointerdown", this._boundHandle);
      this.target.removeEventListener("pointerup", this._boundHandle);
      this.target.removeEventListener("pointermove", this._boundHandle);
      this.target.removeEventListener("pointercancel", this._boundHandle);
    } else {
      this.target.removeEventListener("touchstart", this._boundHandle);
      this.target.removeEventListener("touchend", this._boundHandle);
      this.target.removeEventListener("touchmove", this._boundHandle);
      this.target.removeEventListener("touchcancel", this._boundHandle);
      this.target.removeEventListener("mousedown", this._boundHandle);
      this.target.removeEventListener("mouseup", this._boundHandle);
      this.target.removeEventListener("mousemove", this._boundHandle);
    }
    if ("onwheel" in document.createElement("div")) {
      this.target.removeEventListener("wheel", this._boundWheel);
    } else if (document.onmousewheel !== void 0) {
      this.target.addEventListener("mousewheel", this._boundWheel);
    } else {
      this.target.addEventListener("MozMousePixelScroll", this._boundWheel);
    }
  }
  /**
   * Take native pointer id and map it to index in active pointers
   * @param nativePointerId
   */
  _normalizePointerId(nativePointerId) {
    this._activeNativePointerIdsToNormalized.set(nativePointerId, -1);
    const currentPointerIds = Array.from(this._activeNativePointerIdsToNormalized.keys()).sort((a, b) => a - b);
    const id = currentPointerIds.findIndex((p) => p === nativePointerId);
    this._activeNativePointerIdsToNormalized.set(nativePointerId, id);
    return id;
  }
  /**
   * Responsible for handling and parsing pointer events
   */
  _handle(ev) {
    if (!this._enabled) {
      return;
    }
    ev.preventDefault();
    const eventCoords = /* @__PURE__ */ new Map();
    let button;
    let pointerType;
    if (isTouchEvent(ev)) {
      button = PointerButton.Unknown;
      pointerType = PointerType.Touch;
      for (let i = 0; i < ev.changedTouches.length; i++) {
        const touch = ev.changedTouches[i];
        const coordinates = GlobalCoordinates.fromPagePosition(touch.pageX, touch.pageY, this.engine);
        const nativePointerId = i + 1;
        const pointerId = this._normalizePointerId(nativePointerId);
        this.currentFramePointerCoords.set(pointerId, coordinates);
        eventCoords.set(pointerId, coordinates);
      }
    } else {
      button = this._nativeButtonToPointerButton(ev.button);
      pointerType = PointerType.Mouse;
      const coordinates = GlobalCoordinates.fromPagePosition(ev.pageX, ev.pageY, this.engine);
      let nativePointerId = 1;
      if (isPointerEvent(ev)) {
        nativePointerId = ev.pointerId;
        pointerType = this._stringToPointerType(ev.pointerType);
      }
      const pointerId = this._normalizePointerId(nativePointerId);
      this.currentFramePointerCoords.set(pointerId, coordinates);
      eventCoords.set(pointerId, coordinates);
    }
    for (const [pointerId, coord] of eventCoords.entries()) {
      switch (ev.type) {
        case "mousedown":
        case "pointerdown":
        case "touchstart":
          this.currentFrameDown.push(new PointerEvent("down", pointerId, button, pointerType, coord, ev));
          this.currentFramePointerDown.set(pointerId, true);
          break;
        case "mouseup":
        case "pointerup":
        case "touchend":
          this.currentFrameUp.push(new PointerEvent("up", pointerId, button, pointerType, coord, ev));
          this.currentFramePointerDown.set(pointerId, false);
          break;
        case "mousemove":
        case "pointermove":
        case "touchmove":
          this.currentFrameMove.push(new PointerEvent("move", pointerId, button, pointerType, coord, ev));
          break;
        case "touchcancel":
        case "pointercancel":
          this.currentFrameCancel.push(new PointerEvent("cancel", pointerId, button, pointerType, coord, ev));
          break;
      }
    }
  }
  _handleWheel(ev) {
    if (!this._enabled) {
      return;
    }
    if (this.engine.pageScrollPreventionMode === ScrollPreventionMode.All || this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas && ev.target === this.engine.canvas) {
      ev.preventDefault();
    }
    const screen = this.engine.screen.pageToScreenCoordinates(vec(ev.pageX, ev.pageY));
    const world = this.engine.screen.screenToWorldCoordinates(screen);
    const ScrollWheelNormalizationFactor = -1 / 40;
    const deltaX = ev.deltaX || ev.wheelDeltaX * ScrollWheelNormalizationFactor || 0;
    const deltaY = ev.deltaY || ev.wheelDeltaY * ScrollWheelNormalizationFactor || ev.wheelDelta * ScrollWheelNormalizationFactor || ev.detail || 0;
    const deltaZ = ev.deltaZ || 0;
    let deltaMode = WheelDeltaMode.Pixel;
    if (ev.deltaMode) {
      if (ev.deltaMode === 1) {
        deltaMode = WheelDeltaMode.Line;
      } else if (ev.deltaMode === 2) {
        deltaMode = WheelDeltaMode.Page;
      }
    }
    const we = new WheelEvent(world.x, world.y, ev.pageX, ev.pageY, screen.x, screen.y, 0, deltaX, deltaY, deltaZ, deltaMode, ev);
    this.currentFrameWheel.push(we);
  }
  /**
   * Triggers an excalibur pointer event in a world space pos
   *
   * Useful for testing pointers in excalibur
   * @param type
   * @param pos
   */
  triggerEvent(type, pos) {
    const page = this.engine.screen.worldToPageCoordinates(pos);
    if (window.PointerEvent) {
      this._handle(
        new window.PointerEvent("pointer" + type, {
          pointerId: 0,
          clientX: page.x,
          clientY: page.y
        })
      );
    } else {
      this._handle(
        new window.MouseEvent("mouse" + type, {
          clientX: page.x,
          clientY: page.y
        })
      );
    }
    const pointerSystem = this.engine.currentScene.world.get(PointerSystem);
    pointerSystem.preupdate(this.engine.currentScene, 1);
    pointerSystem.update(1);
  }
  _nativeButtonToPointerButton(s) {
    switch (s) {
      case NativePointerButton.NoButton:
        return PointerButton.NoButton;
      case NativePointerButton.Left:
        return PointerButton.Left;
      case NativePointerButton.Middle:
        return PointerButton.Middle;
      case NativePointerButton.Right:
        return PointerButton.Right;
      case NativePointerButton.Unknown:
        return PointerButton.Unknown;
      default:
        return fail(s);
    }
  }
  _stringToPointerType(s) {
    switch (s) {
      case "touch":
        return PointerType.Touch;
      case "mouse":
        return PointerType.Mouse;
      case "pen":
        return PointerType.Pen;
      default:
        return PointerType.Unknown;
    }
  }
}
class InputHost {
  constructor(options) {
    this._enabled = true;
    const { pointerTarget, grabWindowFocus, engine, global } = options;
    this.keyboard = new Keyboard();
    this.pointers = new PointerEventReceiver(pointerTarget, engine);
    this.gamepads = new Gamepads();
    this.keyboard.init({ global, grabWindowFocus });
    this.pointers.init({ grabWindowFocus });
    this.gamepads.init();
    this.inputMapper = new InputMapper({
      keyboard: this.keyboard,
      pointers: this.pointers,
      gamepads: this.gamepads
    });
  }
  get enabled() {
    return this._enabled;
  }
  toggleEnabled(enabled) {
    this._enabled = enabled;
    this.keyboard.toggleEnabled(this._enabled);
    this.pointers.toggleEnabled(this._enabled);
    this.gamepads.toggleEnabled(this._enabled);
  }
  update() {
    if (this._enabled) {
      this.inputMapper.execute();
      this.keyboard.update();
      this.gamepads.update();
    }
  }
  clear() {
    this.keyboard.clear();
    this.pointers.clear();
  }
}
class PreLoadEvent {
}
const SceneEvents = {
  Initialize: "initialize",
  Activate: "activate",
  Deactivate: "deactivate",
  PreUpdate: "preupdate",
  PostUpdate: "postupdate",
  PreDraw: "predraw",
  PostDraw: "postdraw",
  PreDebugDraw: "predebugdraw",
  PostDebugDraw: "postdebugdraw",
  PreLoad: "preload",
  TransitionStart: "transitionstart",
  TransitionEnd: "transitionend"
};
function isSceneConstructor(x) {
  var _a, _b;
  return !!(x == null ? void 0 : x.prototype) && !!((_b = (_a = x == null ? void 0 : x.prototype) == null ? void 0 : _a.constructor) == null ? void 0 : _b.name);
}
class Scene {
  constructor() {
    this._logger = Logger.getInstance();
    this.events = new EventEmitter();
    this.camera = new Camera();
    this.world = new World(this);
    this.physics = new PhysicsWorld(getDefaultPhysicsConfig());
    this._isInitialized = false;
    this._timers = [];
    this._cancelQueue = [];
    this.world.add(ActionsSystem);
    this.world.add(new MotionSystem(this.world, this.physics));
    this.world.add(new CollisionSystem(this.world, this.physics));
    this.world.add(PointerSystem);
    this.world.add(IsometricEntitySystem);
    this.world.add(OffscreenSystem);
    this.world.add(GraphicsSystem);
    this.world.add(DebugSystem);
  }
  /**
   * The actors in the current scene
   */
  get actors() {
    return this.world.entityManager.entities.filter((e) => {
      return e instanceof Actor;
    });
  }
  /**
   * The entities in the current scene
   */
  get entities() {
    return this.world.entityManager.entities;
  }
  /**
   * The triggers in the current scene
   */
  get triggers() {
    return this.world.entityManager.entities.filter((e) => {
      return e instanceof Trigger;
    });
  }
  /**
   * The {@apilink TileMap}s in the scene, if any
   */
  get tileMaps() {
    return this.world.entityManager.entities.filter((e) => {
      return e instanceof TileMap;
    });
  }
  get timers() {
    return this._timers;
  }
  emit(eventName, event) {
    this.events.emit(eventName, event);
  }
  on(eventName, handler) {
    return this.events.on(eventName, handler);
  }
  once(eventName, handler) {
    return this.events.once(eventName, handler);
  }
  off(eventName, handler) {
    this.events.off(eventName, handler);
  }
  /**
   * Event hook to provide Scenes a way of loading scene specific resources.
   *
   * This is called before the Scene.onInitialize during scene transition. It will only ever fire once for a scene.
   * @param loader
   */
  onPreLoad(loader) {
  }
  /**
   * Event hook fired directly before transition, either "in" or "out" of the scene
   *
   * This overrides the Engine scene definition. However transitions specified in goToScene take highest precedence
   *
   * ```typescript
   * // Overrides all
   * Engine.goToScene('scene', { destinationIn: ..., sourceOut: ... });
   * ```
   *
   * This can be used to configure custom transitions for a scene dynamically
   */
  onTransition(direction) {
    return void 0;
  }
  /**
   * This is called before the first update of the {@apilink Scene}. Initializes scene members like the camera. This method is meant to be
   * overridden. This is where initialization of child actors should take place.
   */
  onInitialize(engine) {
  }
  /**
   * This is called when the scene is made active and started. It is meant to be overridden,
   * this is where you should setup any DOM UI or event handlers needed for the scene.
   */
  onActivate(context) {
  }
  /**
   * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,
   * this is where you should cleanup any DOM UI or event handlers needed for the scene.
   * @returns Either data to pass to the next scene activation context as `previousSceneData` or nothing
   */
  onDeactivate(context) {
  }
  /**
   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPreUpdate` is called directly before a scene is updated.
   * @param engine reference to the engine
   * @param elapsed  Number of milliseconds elapsed since the last draw.
   */
  onPreUpdate(engine, elapsed) {
  }
  /**
   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPostUpdate` is called directly after a scene is updated.
   * @param engine reference to the engine
   * @param elapsed  Number of milliseconds elapsed since the last draw.
   */
  onPostUpdate(engine, elapsed) {
  }
  /**
   * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPreDraw` is called directly before a scene is drawn.
   *
   */
  onPreDraw(ctx, elapsed) {
  }
  /**
   * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
   *
   * `onPostDraw` is called directly after a scene is drawn.
   *
   */
  onPostDraw(ctx, elapsed) {
  }
  /**
   * Initializes actors in the scene
   */
  _initializeChildren() {
    for (const child of this.entities) {
      child._initialize(this.engine);
    }
  }
  /**
   * Gets whether or not the {@apilink Scene} has been initialized
   */
  get isInitialized() {
    return this._isInitialized;
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Initializes the scene before the first update, meant to be called by engine not by users of
   * Excalibur
   * @internal
   */
  async _initialize(engine) {
    var _a;
    if (!this.isInitialized) {
      try {
        this.engine = engine;
        this.physics.config = this.engine.physics;
        this.input = new InputHost({
          global: engine.global,
          pointerTarget: engine.pointerScope === PointerScope.Canvas ? engine.canvas : document,
          grabWindowFocus: engine.grabWindowFocus,
          engine
        });
        this.camera._initialize(engine);
        this.world.systemManager.initialize();
        await this.onInitialize(engine);
        this._initializeChildren();
        this._logger.debug("Scene.onInitialize", this, engine);
        this.events.emit("initialize", new InitializeEvent(engine, this));
      } catch (e) {
        this._logger.error(`Error during scene initialization for scene ${(_a = engine.director) == null ? void 0 : _a.getSceneName(this)}!`);
        throw e;
      }
      this._isInitialized = true;
    }
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.
   * @internal
   */
  async _activate(context) {
    var _a, _b;
    try {
      this._logger.debug("Scene.onActivate", this);
      this.input.toggleEnabled(true);
      await this.onActivate(context);
    } catch (e) {
      this._logger.error(`Error during scene activation for scene ${(_b = (_a = this.engine) == null ? void 0 : _a.director) == null ? void 0 : _b.getSceneName(this)}!`);
      throw e;
    }
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.
   * @internal
   */
  async _deactivate(context) {
    this._logger.debug("Scene.onDeactivate", this);
    this.input.toggleEnabled(false);
    return await this.onDeactivate(context);
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPreUpdate} lifecycle event
   * @internal
   */
  _preupdate(engine, elapsed) {
    this.emit("preupdate", new PreUpdateEvent(engine, elapsed, this));
    this.onPreUpdate(engine, elapsed);
  }
  /**
   *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _preupdate handler for {@apilink onPostUpdate} lifecycle event
   * @internal
   */
  _postupdate(engine, elapsed) {
    this.emit("postupdate", new PostUpdateEvent(engine, elapsed, this));
    this.onPostUpdate(engine, elapsed);
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _predraw handler for {@apilink onPreDraw} lifecycle event
   * @internal
   */
  _predraw(ctx, elapsed) {
    this.emit("predraw", new PreDrawEvent(ctx, elapsed, this));
    this.onPreDraw(ctx, elapsed);
  }
  /**
   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
   *
   * Internal _postdraw handler for {@apilink onPostDraw} lifecycle event
   * @internal
   */
  _postdraw(ctx, elapsed) {
    this.emit("postdraw", new PostDrawEvent(ctx, elapsed, this));
    this.onPostDraw(ctx, elapsed);
  }
  /**
   * Updates all the actors and timers in the scene. Called by the {@apilink Engine}.
   * @param engine  Reference to the current Engine
   * @param elapsed   The number of milliseconds since the last update
   */
  update(engine, elapsed) {
    var _a;
    if (!this.isInitialized) {
      this._logger.warnOnce(`Scene update called before initialize for scene ${(_a = engine.director) == null ? void 0 : _a.getSceneName(this)}!`);
      return;
    }
    this._preupdate(engine, elapsed);
    let i, len;
    for (i = 0, len = this._cancelQueue.length; i < len; i++) {
      this.removeTimer(this._cancelQueue[i]);
    }
    this._cancelQueue.length = 0;
    for (const timer of this._timers) {
      timer.update(elapsed);
    }
    this.world.update(SystemType.Update, elapsed);
    if (this.camera) {
      this.camera.update(engine, elapsed);
    }
    this._collectActorStats(engine);
    this._postupdate(engine, elapsed);
    this.input.update();
  }
  /**
   * Draws all the actors in the Scene. Called by the {@apilink Engine}.
   * @param ctx    The current rendering context
   * @param elapsed  The number of milliseconds since the last draw
   */
  draw(ctx, elapsed) {
    var _a;
    if (!this.isInitialized) {
      this._logger.warnOnce(`Scene draw called before initialize!`);
      return;
    }
    this._predraw(ctx, elapsed);
    this.world.update(SystemType.Draw, elapsed);
    if ((_a = this.engine) == null ? void 0 : _a.isDebug) {
      this.debugDraw(ctx);
    }
    this._postdraw(ctx, elapsed);
  }
  /**
   * Draws all the actors' debug information in the Scene. Called by the {@apilink Engine}.
   * @param ctx  The current rendering context
   */
  /* istanbul ignore next */
  debugDraw(ctx) {
    this.emit("predebugdraw", new PreDebugDrawEvent(ctx, this));
    this.emit("postdebugdraw", new PostDebugDrawEvent(ctx, this));
  }
  /**
   * Checks whether an actor is contained in this scene or not
   */
  contains(actor) {
    return this.actors.indexOf(actor) > -1;
  }
  add(entity) {
    this.emit("entityadded", { target: entity });
    if (entity instanceof Timer) {
      if (!contains(this._timers, entity)) {
        this.addTimer(entity);
      }
      return;
    }
    this.world.add(entity);
    entity.scene = this;
  }
  /**
   * Removes an {@apilink Entity} (Actor, TileMap, Trigger, etc) or {@apilink Timer} from it's current scene
   * and adds it to this scene.
   *
   * Useful if you want to have an object be present in only 1 scene at a time.
   * @param entity
   */
  transfer(entity) {
    let scene;
    if (entity instanceof Entity && entity.scene && entity.scene !== this) {
      scene = entity.scene;
      entity.scene.world.remove(entity, false);
    }
    if (entity instanceof Timer && entity.scene) {
      scene = entity.scene;
      entity.scene.removeTimer(entity);
    }
    scene == null ? void 0 : scene.emit("entityremoved", { target: entity });
    this.add(entity);
  }
  remove(entity) {
    this.emit("entityremoved", { target: entity });
    if (entity instanceof Entity) {
      if (entity.isActive) {
        entity.kill();
      }
      this.world.remove(entity);
    }
    if (entity instanceof Timer) {
      this.removeTimer(entity);
    }
  }
  /**
   * Removes all entities and timers from the scene, optionally indicate whether deferred should or shouldn't be used.
   *
   * By default entities use deferred removal
   * @param deferred
   */
  clear(deferred = true) {
    for (let i = this.entities.length - 1; i >= 0; i--) {
      this.world.remove(this.entities[i], deferred);
    }
    for (let i = this.timers.length - 1; i >= 0; i--) {
      this.removeTimer(this.timers[i]);
    }
  }
  /**
   * Adds a {@apilink Timer} to the scene
   * @param timer  The timer to add
   */
  addTimer(timer) {
    this._timers.push(timer);
    timer.scene = this;
    return timer;
  }
  /**
   * Removes a {@apilink Timer} from the scene.
   * @warning Can be dangerous, use {@apilink cancelTimer} instead
   * @param timer  The timer to remove
   */
  removeTimer(timer) {
    const i = this._timers.indexOf(timer);
    if (i !== -1) {
      this._timers.splice(i, 1);
    }
    return timer;
  }
  /**
   * Cancels a {@apilink Timer}, removing it from the scene nicely
   * @param timer  The timer to cancel
   */
  cancelTimer(timer) {
    this._cancelQueue.push(timer);
    return timer;
  }
  /**
   * Tests whether a {@apilink Timer} is active in the scene
   */
  isTimerActive(timer) {
    return this._timers.indexOf(timer) > -1 && !timer.complete;
  }
  isCurrentScene() {
    if (this.engine) {
      return this.engine.currentScene === this;
    }
    return false;
  }
  _collectActorStats(engine) {
    const actors = this.actors;
    for (let i = 0; i < actors.length; i++) {
      const actor = actors[i];
      if (actor instanceof ScreenElement) {
        engine.stats.currFrame.actors.ui++;
      }
      engine.stats.currFrame.actors.alive++;
      for (let j = 0; j < actor.children.length; j++) {
        const child = actor.children[j];
        if (isScreenElement(child)) {
          engine.stats.currFrame.actors.ui++;
        } else {
          engine.stats.currFrame.actors.alive++;
        }
      }
    }
  }
}
class ColorBlindFlags {
  constructor(engine) {
    this._engine = engine;
    this._colorBlindPostProcessor = new ColorBlindnessPostProcessor(ColorBlindnessMode.Protanope);
  }
  /**
   * Correct colors for a specified color blindness
   * @param colorBlindness
   */
  correct(colorBlindness) {
    if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {
      this.clear();
      this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;
      this._colorBlindPostProcessor.simulate = false;
      this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);
    }
  }
  /**
   * Simulate colors for a specified color blindness
   * @param colorBlindness
   */
  simulate(colorBlindness) {
    if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {
      this.clear();
      this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;
      this._colorBlindPostProcessor.simulate = true;
      this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);
    }
  }
  /**
   * Remove color blindness post processor
   */
  clear() {
    this._engine.graphicsContext.removePostProcessor(this._colorBlindPostProcessor);
  }
}
class DebugConfig {
  constructor(engine) {
    this.stats = {
      /**
       * Current frame statistics. Engine reuses this instance, use {@apilink FrameStats.clone} to copy frame stats.
       * Best accessed on {@apilink postframe} event. See {@apilink FrameStats}
       */
      currFrame: new FrameStats(),
      /**
       * Previous frame statistics. Engine reuses this instance, use {@apilink FrameStats.clone} to copy frame stats.
       * Best accessed on {@apilink preframe} event. Best inspected on engine event `preframe`. See {@apilink FrameStats}
       */
      prevFrame: new FrameStats()
    };
    this.filter = {
      /**
       * Toggle filter on or off (default off) must be on for DebugDraw to use filters
       */
      useFilter: false,
      /**
       * Query for entities by name, if the entity name contains `nameQuery` it will be included
       */
      nameQuery: "",
      /**
       * Query for Entity ids, if the id matches it will be included
       */
      ids: []
    };
    this.entity = {
      showAll: false,
      showId: false,
      showName: false
    };
    this.transform = {
      showAll: false,
      debugZIndex: 1e7,
      showPosition: false,
      showPositionLabel: false,
      positionColor: Color.Yellow,
      showZIndex: false,
      showScale: false,
      scaleColor: Color.Green,
      showRotation: false,
      rotationColor: Color.Blue
    };
    this.graphics = {
      showAll: false,
      showBounds: false,
      boundsColor: Color.Yellow
    };
    this.collider = {
      showAll: false,
      showBounds: false,
      boundsColor: Color.Blue,
      showOwner: false,
      showGeometry: true,
      geometryColor: Color.Green,
      geometryLineWidth: 1,
      geometryPointSize: 0.5
    };
    this.physics = {
      showAll: false,
      showBroadphaseSpacePartitionDebug: false,
      showCollisionNormals: false,
      collisionNormalColor: Color.Cyan,
      showCollisionContacts: true,
      contactSize: 2,
      collisionContactColor: Color.Red
    };
    this.motion = {
      showAll: false,
      showVelocity: false,
      velocityColor: Color.Yellow,
      showAcceleration: false,
      accelerationColor: Color.Red
    };
    this.body = {
      showAll: false,
      showCollisionGroup: false,
      showCollisionType: false,
      showSleeping: false,
      showMotion: false,
      showMass: false
    };
    this.camera = {
      showAll: false,
      showFocus: false,
      focusColor: Color.Red,
      showZoom: false
    };
    this.tilemap = {
      showAll: false,
      showGrid: false,
      gridColor: Color.Red,
      gridWidth: 0.5,
      showSolidBounds: false,
      solidBoundsColor: Color.fromHex("#8080807F"),
      // grayish
      showColliderGeometry: true
    };
    this.isometric = {
      showAll: false,
      showPosition: false,
      positionColor: Color.Yellow,
      positionSize: 1,
      showGrid: false,
      gridColor: Color.Red,
      gridWidth: 1,
      showColliderGeometry: true
    };
    this._engine = engine;
    this.colorBlindMode = new ColorBlindFlags(this._engine);
  }
  /**
   * Switch the current excalibur clock with the {@apilink TestClock} and return
   * it in the same running state.
   *
   * This is useful when you need to debug frame by frame.
   */
  useTestClock() {
    const clock = this._engine.clock;
    const wasRunning = clock.isRunning();
    clock.stop();
    const testClock = clock.toTestClock();
    if (wasRunning) {
      testClock.start();
    }
    this._engine.clock = testClock;
    return testClock;
  }
  /**
   * Switch the current excalibur clock with the {@apilink StandardClock} and
   * return it in the same running state.
   *
   * This is useful when you need to switch back to normal mode after
   * debugging.
   */
  useStandardClock() {
    const currentClock = this._engine.clock;
    const wasRunning = currentClock.isRunning();
    currentClock.stop();
    const standardClock = currentClock.toStandardClock();
    if (wasRunning) {
      standardClock.start();
    }
    this._engine.clock = standardClock;
    return standardClock;
  }
}
class FrameStats {
  constructor() {
    this._id = 0;
    this._elapsedMs = 0;
    this._fps = 0;
    this._actorStats = {
      alive: 0,
      killed: 0,
      ui: 0,
      get remaining() {
        return this.alive - this.killed;
      },
      get total() {
        return this.remaining + this.ui;
      }
    };
    this._durationStats = {
      update: 0,
      draw: 0,
      get total() {
        return this.update + this.draw;
      }
    };
    this._physicsStats = new PhysicsStats();
    this._graphicsStats = {
      drawCalls: 0,
      drawnImages: 0
    };
  }
  /**
   * Zero out values or clone other IFrameStat stats. Allows instance reuse.
   * @param [otherStats] Optional stats to clone
   */
  reset(otherStats) {
    if (otherStats) {
      this.id = otherStats.id;
      this.elapsedMs = otherStats.elapsedMs;
      this.fps = otherStats.fps;
      this.actors.alive = otherStats.actors.alive;
      this.actors.killed = otherStats.actors.killed;
      this.actors.ui = otherStats.actors.ui;
      this.duration.update = otherStats.duration.update;
      this.duration.draw = otherStats.duration.draw;
      this._physicsStats.reset(otherStats.physics);
      this.graphics.drawCalls = otherStats.graphics.drawCalls;
      this.graphics.drawnImages = otherStats.graphics.drawnImages;
    } else {
      this.id = this.elapsedMs = this.fps = 0;
      this.actors.alive = this.actors.killed = this.actors.ui = 0;
      this.duration.update = this.duration.draw = 0;
      this._physicsStats.reset();
      this.graphics.drawnImages = this.graphics.drawCalls = 0;
    }
  }
  /**
   * Provides a clone of this instance.
   */
  clone() {
    const fs = new FrameStats();
    fs.reset(this);
    return fs;
  }
  /**
   * Gets the frame's id
   */
  get id() {
    return this._id;
  }
  /**
   * Sets the frame's id
   */
  set id(value) {
    this._id = value;
  }
  /**
   * Gets the frame's delta (time since last frame)
   */
  get elapsedMs() {
    return this._elapsedMs;
  }
  /**
   * Sets the frame's delta (time since last frame). Internal use only.
   * @internal
   */
  set elapsedMs(value) {
    this._elapsedMs = value;
  }
  /**
   * Gets the frame's frames-per-second (FPS)
   */
  get fps() {
    return this._fps;
  }
  /**
   * Sets the frame's frames-per-second (FPS). Internal use only.
   * @internal
   */
  set fps(value) {
    this._fps = value;
  }
  /**
   * Gets the frame's actor statistics
   */
  get actors() {
    return this._actorStats;
  }
  /**
   * Gets the frame's duration statistics
   */
  get duration() {
    return this._durationStats;
  }
  /**
   * Gets the frame's physics statistics
   */
  get physics() {
    return this._physicsStats;
  }
  /**
   * Gets the frame's graphics statistics
   */
  get graphics() {
    return this._graphicsStats;
  }
}
class PhysicsStats {
  constructor() {
    this._pairs = 0;
    this._collisions = 0;
    this._contacts = /* @__PURE__ */ new Map();
    this._fastBodies = 0;
    this._fastBodyCollisions = 0;
    this._broadphase = 0;
    this._narrowphase = 0;
  }
  /**
   * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.
   * @param [otherStats] Optional stats to clone
   */
  reset(otherStats) {
    if (otherStats) {
      this.pairs = otherStats.pairs;
      this.collisions = otherStats.collisions;
      this.contacts = otherStats.contacts;
      this.fastBodies = otherStats.fastBodies;
      this.fastBodyCollisions = otherStats.fastBodyCollisions;
      this.broadphase = otherStats.broadphase;
      this.narrowphase = otherStats.narrowphase;
    } else {
      this.pairs = this.collisions = this.fastBodies = 0;
      this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;
      this.contacts.clear();
    }
  }
  /**
   * Provides a clone of this instance.
   */
  clone() {
    const ps = new PhysicsStats();
    ps.reset(this);
    return ps;
  }
  get pairs() {
    return this._pairs;
  }
  set pairs(value) {
    this._pairs = value;
  }
  get collisions() {
    return this._collisions;
  }
  set collisions(value) {
    this._collisions = value;
  }
  get contacts() {
    return this._contacts;
  }
  set contacts(contacts) {
    this._contacts = contacts;
  }
  get fastBodies() {
    return this._fastBodies;
  }
  set fastBodies(value) {
    this._fastBodies = value;
  }
  get fastBodyCollisions() {
    return this._fastBodyCollisions;
  }
  set fastBodyCollisions(value) {
    this._fastBodyCollisions = value;
  }
  get broadphase() {
    return this._broadphase;
  }
  set broadphase(value) {
    this._broadphase = value;
  }
  get narrowphase() {
    return this._narrowphase;
  }
  set narrowphase(value) {
    this._narrowphase = value;
  }
}
class BrowserComponent {
  constructor(nativeComponent) {
    this.nativeComponent = nativeComponent;
    this._paused = false;
    this._nativeHandlers = {};
  }
  on(eventName, handler) {
    if (this._nativeHandlers[eventName]) {
      this.off(eventName, this._nativeHandlers[eventName]);
    }
    this._nativeHandlers[eventName] = this._decorate(handler);
    this.nativeComponent.addEventListener(eventName, this._nativeHandlers[eventName]);
  }
  off(eventName, handler) {
    if (!handler) {
      handler = this._nativeHandlers[eventName];
    }
    this.nativeComponent.removeEventListener(eventName, handler);
    this._nativeHandlers[eventName] = null;
  }
  _decorate(handler) {
    return (evt) => {
      if (!this._paused) {
        handler(evt);
      }
    };
  }
  pause() {
    this._paused = true;
  }
  resume() {
    this._paused = false;
  }
  clear() {
    for (const event in this._nativeHandlers) {
      this.off(event);
    }
  }
}
class BrowserEvents {
  constructor(_windowGlobal, _documentGlobal) {
    this._windowGlobal = _windowGlobal;
    this._documentGlobal = _documentGlobal;
    this._windowComponent = new BrowserComponent(this._windowGlobal);
    this._documentComponent = new BrowserComponent(this._documentGlobal);
  }
  get window() {
    return this._windowComponent;
  }
  get document() {
    return this._documentComponent;
  }
  pause() {
    this.window.pause();
    this.document.pause();
  }
  resume() {
    this.window.resume();
    this.document.resume();
  }
  clear() {
    this.window.clear();
    this.document.clear();
  }
}
class FpsSampler {
  constructor(options) {
    this._samplePeriod = 100;
    this._currentFrameTime = 0;
    this._frames = 0;
    this._previousSampleTime = 0;
    this._beginFrameTime = 0;
    var _a;
    this._fps = options.initialFps;
    this._samplePeriod = (_a = options.samplePeriod) != null ? _a : this._samplePeriod;
    this._currentFrameTime = 1e3 / options.initialFps;
    this._nowFn = options.nowFn;
    this._previousSampleTime = this._nowFn();
  }
  /**
   * Start of code block to sample FPS for
   */
  start() {
    this._beginFrameTime = this._nowFn();
  }
  /**
   * End of code block to sample FPS for
   */
  end() {
    this._frames++;
    const time = this._nowFn();
    this._currentFrameTime = time - this._beginFrameTime;
    if (time >= this._previousSampleTime + this._samplePeriod) {
      this._fps = this._frames * 1e3 / (time - this._previousSampleTime);
      this._previousSampleTime = time;
      this._frames = 0;
    }
  }
  /**
   * Return the currently sampled fps over the last sample period, by default every 100ms
   */
  get fps() {
    return this._fps;
  }
  /**
   * Return the instantaneous fps, this can be less useful because it will fluctuate given the current frames time
   */
  get instant() {
    return 1e3 / this._currentFrameTime;
  }
}
class Clock {
  constructor(options) {
    this._onFatalException = () => {
    };
    this._maxFps = Infinity;
    this._lastTime = 0;
    this._elapsed = 1;
    this._scheduledCbs = [];
    this._totalElapsed = 0;
    this._nextScheduleId = 0;
    var _a, _b, _c;
    this._options = options;
    this.tick = options.tick;
    this._lastTime = (_a = this.now()) != null ? _a : 0;
    this._maxFps = (_b = options.maxFps) != null ? _b : this._maxFps;
    this._onFatalException = (_c = options.onFatalException) != null ? _c : this._onFatalException;
    this.fpsSampler = new FpsSampler({
      initialFps: 60,
      nowFn: () => this.now()
    });
  }
  /**
   * Get the elapsed time for the last completed frame
   */
  elapsed() {
    return this._elapsed;
  }
  /**
   * Get the current time in milliseconds
   */
  now() {
    return performance.now();
  }
  toTestClock() {
    const testClock = new TestClock({
      ...this._options,
      defaultUpdateMs: 16.6
    });
    return testClock;
  }
  toStandardClock() {
    const clock = new StandardClock({
      ...this._options
    });
    return clock;
  }
  setFatalExceptionHandler(handler) {
    this._onFatalException = handler;
  }
  /**
   * Schedule a callback to fire given a timeout in milliseconds using the excalibur {@apilink Clock}
   *
   * This is useful to use over the built in browser `setTimeout` because callbacks will be tied to the
   * excalibur update clock, instead of browser time, this means that callbacks wont fire if the game is
   * stopped or paused.
   * @param cb callback to fire
   * @param timeoutMs Optionally specify a timeout in milliseconds from now, default is 0ms which means the next possible tick
   * @param timing Optionally specify a timeout in milliseconds from now, default is 0ms which means the next possible tick
   * @returns A unique identifier that can be used to clear the scheduled callback with {@apilink clearSchedule}
   */
  schedule(cb, timeoutMs = 0, timing = "preframe") {
    const scheduledTime = this._totalElapsed + timeoutMs;
    const id = this._nextScheduleId++;
    this._scheduledCbs.push([id, cb, scheduledTime, timing]);
    return id;
  }
  /**
   * Clears a scheduled callback using the ID returned from {@apilink schedule}
   * @param id The ID of the scheduled callback to clear
   */
  clearSchedule(id) {
    const index = this._scheduledCbs.findIndex(([scheduleId]) => scheduleId === id);
    if (index !== -1) {
      this._scheduledCbs.splice(index, 1);
    }
  }
  /**
   * Called internally to trigger scheduled callbacks in the clock
   * @param timing
   * @internal
   */
  __runScheduledCbs(timing = "preframe") {
    for (let i = this._scheduledCbs.length - 1; i > -1; i--) {
      const [_, callback, scheduledTime, callbackTiming] = this._scheduledCbs[i];
      if (timing === callbackTiming && scheduledTime <= this._totalElapsed) {
        callback(this._elapsed);
        this._scheduledCbs.splice(i, 1);
      }
    }
  }
  update(overrideUpdateMs) {
    try {
      this.fpsSampler.start();
      const now = this.now();
      let elapsed = now - this._lastTime || 1;
      const fpsInterval = 1e3 / this._maxFps;
      if (elapsed >= fpsInterval) {
        let leftover = 0;
        if (fpsInterval !== 0) {
          leftover = elapsed % fpsInterval;
          elapsed = elapsed - leftover;
        }
        if (elapsed > 200) {
          elapsed = 1;
        }
        this._elapsed = overrideUpdateMs || elapsed;
        this._totalElapsed += this._elapsed;
        this.__runScheduledCbs("preframe");
        this.tick(overrideUpdateMs || elapsed);
        this.__runScheduledCbs("postframe");
        if (fpsInterval !== 0) {
          this._lastTime = now - leftover;
        } else {
          this._lastTime = now;
        }
        this.fpsSampler.end();
      }
    } catch (e) {
      this._onFatalException(e);
      this.stop();
    }
  }
}
class StandardClock extends Clock {
  constructor(options) {
    super(options);
    this._running = false;
  }
  isRunning() {
    return this._running;
  }
  start() {
    if (this._running) {
      return;
    }
    this._running = true;
    const mainloop = () => {
      if (!this._running) {
        return;
      }
      try {
        this._requestId = window.requestAnimationFrame(mainloop);
        this.update();
      } catch (e) {
        window.cancelAnimationFrame(this._requestId);
        throw e;
      }
    };
    mainloop();
  }
  stop() {
    window.cancelAnimationFrame(this._requestId);
    this._running = false;
  }
}
class TestClock extends Clock {
  constructor(options) {
    super({
      ...options
    });
    this._logger = Logger.getInstance();
    this._running = false;
    this._currentTime = 0;
    this._updateMs = options.defaultUpdateMs;
  }
  /**
   * Get the current time in milliseconds
   */
  now() {
    var _a;
    return (_a = this._currentTime) != null ? _a : 0;
  }
  isRunning() {
    return this._running;
  }
  start() {
    this._running = true;
  }
  stop() {
    this._running = false;
  }
  /**
   * Manually step the clock forward 1 tick, optionally specify an elapsed time in milliseconds
   * @param overrideUpdateMs
   */
  step(overrideUpdateMs) {
    const time = overrideUpdateMs != null ? overrideUpdateMs : this._updateMs;
    if (this._running) {
      this.update(time);
      this._currentTime += time;
    } else {
      this._logger.warn("The clock is not running, no step will be performed");
    }
  }
  /**
   * Run a number of steps that tick the clock, optionally specify an elapsed time in milliseconds
   * @param numberOfSteps
   * @param overrideUpdateMs
   */
  run(numberOfSteps, overrideUpdateMs) {
    for (let i = 0; i < numberOfSteps; i++) {
      this.step(overrideUpdateMs != null ? overrideUpdateMs : this._updateMs);
    }
  }
}
const toasterCss = "#ex-toast-container {\n  position: absolute;\n  height: 0;\n  min-width: 50%;\n  left: 50%;\n  top: 0;\n}\n\n.ex-toast-message {\n  left: -50%;\n  position: relative;\n  display: flex;\n  justify-content: space-between;\n\n  padding: 10px;\n  margin-top: 5px;\n  font-size: 18px;\n  font-family: sans-serif;\n  border-radius: 6px;\n  border: 3px solid #b7b779;\n  background-color: rgb(253, 253, 192);\n}\n\n.ex-toast-message button {\n  align-self: flex-start;\n}\n";
class Toaster {
  constructor() {
    this._toasterCss = toasterCss;
    this._isInitialized = false;
  }
  _initialize() {
    if (!this._isInitialized) {
      this._container = document.createElement("div");
      this._container.id = "ex-toast-container";
      document.body.appendChild(this._container);
      this._isInitialized = true;
      this._styleBlock = document.createElement("style");
      this._styleBlock.textContent = this._toasterCss;
      document.head.appendChild(this._styleBlock);
    }
  }
  dispose() {
    this._container.parentElement.removeChild(this._container);
    this._styleBlock.parentElement.removeChild(this._styleBlock);
    this._isInitialized = false;
  }
  _createFragment(message) {
    const toastMessage = document.createElement("span");
    toastMessage.innerText = message;
    return toastMessage;
  }
  /**
   * Display a toast message to a player
   * @param message Text of the message, messages may have a single "[LINK]" to influence placement
   * @param linkTarget Optionally specify a link location
   * @param linkName Optionally specify a name for that link location
   */
  toast(message, linkTarget, linkName) {
    this._initialize();
    const toast = document.createElement("div");
    toast.className = "ex-toast-message";
    const messageFragments = message.split("[LINK]").map((message2) => this._createFragment(message2));
    if (linkTarget) {
      const link = document.createElement("a");
      link.href = linkTarget;
      if (linkName) {
        link.innerText = linkName;
      } else {
        link.innerText = linkTarget;
      }
      messageFragments.splice(1, 0, link);
    }
    const finalMessage = document.createElement("div");
    messageFragments.forEach((message2) => {
      finalMessage.appendChild(message2);
    });
    toast.appendChild(finalMessage);
    const dismissBtn = document.createElement("button");
    dismissBtn.innerText = "x";
    dismissBtn.addEventListener("click", () => {
      this._container.removeChild(toast);
    });
    toast.appendChild(dismissBtn);
    const keydownHandler = (evt) => {
      if (evt.key === "Escape") {
        try {
          this._container.removeChild(toast);
        } catch (e) {
        }
      }
      document.removeEventListener("keydown", keydownHandler);
    };
    document.addEventListener("keydown", keydownHandler);
    const first = this._container.firstChild;
    this._container.insertBefore(toast, first);
  }
}
const DirectorEvents = {
  NavigationStart: "navigationstart",
  Navigation: "navigation",
  NavigationEnd: "navigationend"
};
class Director {
  constructor(_engine, scenes) {
    this._engine = _engine;
    this.events = new EventEmitter();
    this._logger = Logger.getInstance();
    this._initialized = false;
    this.scenes = {};
    this._sceneToInstance = /* @__PURE__ */ new Map();
    this._sceneToLoader = /* @__PURE__ */ new Map();
    this._sceneToTransition = /* @__PURE__ */ new Map();
    this._loadedScenes = /* @__PURE__ */ new Set();
    this._isTransitioning = false;
    this.rootScene = this.currentScene = new Scene();
    this.add("root", this.rootScene);
    this.currentScene = this.rootScene;
    this.currentSceneName = "root";
    for (const sceneKey in scenes) {
      const sceneOrOptions = scenes[sceneKey];
      this.add(sceneKey, sceneOrOptions);
      if (sceneKey === "root") {
        this.rootScene = this.getSceneInstance("root");
        this.currentScene = this.rootScene;
      }
    }
  }
  /**
   * Gets whether the director currently transitioning between scenes
   *
   * Useful if you need to block behavior during transition
   */
  get isTransitioning() {
    return this._isTransitioning;
  }
  /**
   * Initialize the director's internal state
   */
  async onInitialize() {
    if (!this._initialized) {
      this._initialized = true;
      if (this._deferredGoto) {
        const deferredScene = this._deferredGoto;
        this._deferredGoto = void 0;
        const deferredTransition = this._deferredTransition;
        this._deferredTransition = void 0;
        const deferredSceneInstance = this.getSceneInstance(deferredScene);
        if (deferredSceneInstance && deferredTransition) {
          deferredTransition._addToTargetScene(this._engine, deferredSceneInstance);
        }
        const inTransition = this._getInTransition(deferredScene);
        const hideLoader = inTransition == null ? void 0 : inTransition.hideLoader;
        this.maybeLoadScene(deferredScene, hideLoader);
        await this.swapScene(deferredScene);
        if (deferredSceneInstance && deferredTransition) {
          await this.playTransition(deferredTransition, deferredSceneInstance);
        }
      } else {
        await this.swapScene("root");
      }
    }
  }
  get isInitialized() {
    return this._initialized;
  }
  /**
   * Configures the start scene, and optionally the transition & loader for the director
   *
   * Typically this is called at the beginning of the game to the start scene and transition and never again.
   * @param startScene
   * @param options
   */
  configureStart(startScene, options) {
    var _a, _b;
    const maybeLoaderOrCtor = options == null ? void 0 : options.loader;
    if (maybeLoaderOrCtor instanceof DefaultLoader) {
      this.mainLoader = maybeLoaderOrCtor;
    } else if (isLoaderConstructor(maybeLoaderOrCtor)) {
      this.mainLoader = new maybeLoaderOrCtor();
    } else {
      this.mainLoader = new Loader();
    }
    let maybeStartTransition;
    if (options == null ? void 0 : options.inTransition) {
      const { inTransition } = options;
      maybeStartTransition = inTransition;
    }
    this.startScene = startScene;
    const maybeHideLoader = (_b = (_a = options == null ? void 0 : options.inTransition) == null ? void 0 : _a.hideLoader) != null ? _b : false;
    this.maybeLoadScene(startScene, maybeHideLoader);
    if (maybeStartTransition) {
      const startSceneInstance = this.getSceneInstance(startScene);
      if (startSceneInstance) {
        maybeStartTransition._addToTargetScene(this._engine, startSceneInstance);
        this.swapScene(startScene).then(() => {
          startSceneInstance.onTransition("in");
          return this.playTransition(maybeStartTransition, startSceneInstance);
        });
      }
    } else {
      this.swapScene(startScene);
    }
    this.currentSceneName = this.startScene;
  }
  _getLoader(sceneName) {
    return this._sceneToLoader.get(sceneName);
  }
  _getInTransition(sceneName) {
    var _a;
    const sceneOrRoute = this.scenes[sceneName];
    if (sceneOrRoute instanceof Scene || isSceneConstructor(sceneOrRoute)) {
      return void 0;
    }
    return (_a = sceneOrRoute == null ? void 0 : sceneOrRoute.transitions) == null ? void 0 : _a.in;
  }
  _getOutTransition(sceneName) {
    var _a;
    const sceneOrRoute = this.scenes[sceneName];
    if (sceneOrRoute instanceof Scene || isSceneConstructor(sceneOrRoute)) {
      return void 0;
    }
    return (_a = sceneOrRoute == null ? void 0 : sceneOrRoute.transitions) == null ? void 0 : _a.out;
  }
  getDeferredScene() {
    const maybeDeferred = this.getSceneDefinition(this._deferredGoto);
    if (this._deferredGoto && maybeDeferred) {
      return maybeDeferred;
    }
    return null;
  }
  /**
   * Returns a scene by name if it exists, might be the constructor and not the instance of a scene
   * @param name
   */
  getSceneDefinition(name) {
    const maybeScene = this.scenes[name];
    if (maybeScene instanceof Scene || isSceneConstructor(maybeScene)) {
      return maybeScene;
    } else if (maybeScene) {
      return maybeScene.scene;
    }
    return void 0;
  }
  /**
   * Returns the name of the registered scene, null if none can be found
   * @param scene
   */
  getSceneName(scene) {
    for (const [name, maybeScene] of Object.entries(this.scenes)) {
      if (maybeScene instanceof Scene) {
        if (scene === maybeScene) {
          return name;
        }
      } else if (!isSceneConstructor(maybeScene)) {
        if (scene === maybeScene.scene) {
          return name;
        }
      }
    }
    for (const [name, maybeScene] of Object.entries(this.scenes)) {
      if (isSceneConstructor(maybeScene)) {
        if (scene.constructor === maybeScene) {
          return name;
        }
      } else if (!(maybeScene instanceof Scene)) {
        if (scene.constructor === maybeScene.scene) {
          return name;
        }
      }
    }
    return null;
  }
  /**
   * Returns the same Director, but asserts a scene DOES exist to the type system
   * @param name
   */
  assertAdded(name) {
    return this;
  }
  /**
   * Returns the same Director, but asserts a scene DOES NOT exist to the type system
   * @param name
   */
  assertRemoved(name) {
    return this;
  }
  /**
   * Adds additional Scenes to the game!
   * @param name
   * @param sceneOrRoute
   */
  add(name, sceneOrRoute) {
    if (!(sceneOrRoute instanceof Scene) && !isSceneConstructor(sceneOrRoute)) {
      const { loader, transitions } = sceneOrRoute;
      const { in: inTransition, out: outTransition } = transitions != null ? transitions : {};
      this._sceneToTransition.set(name, { in: inTransition, out: outTransition });
      if (isLoaderConstructor(loader)) {
        this._sceneToLoader.set(name, new loader());
      } else if (loader) {
        this._sceneToLoader.set(name, loader);
      }
    }
    if (this.scenes[name]) {
      this._logger.warn("Scene", name, "already exists overwriting");
    }
    this.scenes[name] = sceneOrRoute;
    return this.assertAdded(name);
  }
  remove(nameOrScene) {
    if (nameOrScene instanceof Scene || isSceneConstructor(nameOrScene)) {
      const sceneOrCtor = nameOrScene;
      for (const key in this.scenes) {
        if (this.scenes.hasOwnProperty(key)) {
          const potentialSceneOrOptions = this.scenes[key];
          let scene;
          if (potentialSceneOrOptions instanceof Scene || isSceneConstructor(potentialSceneOrOptions)) {
            scene = potentialSceneOrOptions;
          } else {
            scene = potentialSceneOrOptions.scene;
          }
          if (scene === sceneOrCtor) {
            if (key === this.currentSceneName) {
              throw new Error(`Cannot remove a currently active scene: ${key}`);
            }
            this._sceneToInstance.delete(key);
            this._sceneToTransition.delete(key);
            this._sceneToLoader.delete(key);
            delete this.scenes[key];
          }
        }
      }
    }
    if (typeof nameOrScene === "string") {
      if (nameOrScene === this.currentSceneName) {
        throw new Error(`Cannot remove a currently active scene: ${nameOrScene}`);
      }
      this._sceneToInstance.delete(nameOrScene);
      this._sceneToTransition.delete(nameOrScene);
      this._sceneToLoader.delete(nameOrScene);
      delete this.scenes[nameOrScene];
    }
  }
  /**
   * Go to a specific scene, and optionally override loaders and transitions
   * @param destinationScene
   * @param options
   */
  async goToScene(destinationScene, options) {
    var _a, _b, _c, _d, _e, _f;
    const maybeDest = this.getSceneInstance(destinationScene);
    if (!maybeDest) {
      this._logger.warn(`Scene ${destinationScene} does not exist! Check the name, are you sure you added it?`);
      return;
    }
    const sourceSceneInstance = this.currentScene;
    const sourceScene = this.currentSceneName;
    const engineInputEnabled = (_b = (_a = this._engine.input) == null ? void 0 : _a.enabled) != null ? _b : true;
    this._isTransitioning = true;
    const maybeSourceOut = (_c = this.getSceneInstance(sourceScene)) == null ? void 0 : _c.onTransition("out");
    const maybeDestinationIn = maybeDest == null ? void 0 : maybeDest.onTransition("in");
    options = {
      // Engine configuration then dynamic scene transitions
      ...{ sourceOut: (_d = this._getOutTransition(this.currentSceneName)) != null ? _d : maybeSourceOut },
      ...{ destinationIn: (_e = this._getInTransition(destinationScene)) != null ? _e : maybeDestinationIn },
      // Goto options
      ...options
    };
    const { sourceOut, destinationIn, sceneActivationData } = options;
    const outTransition = sourceOut != null ? sourceOut : this._getOutTransition(this.currentSceneName);
    const inTransition = destinationIn != null ? destinationIn : this._getInTransition(destinationScene);
    const hideLoader = (outTransition == null ? void 0 : outTransition.hideLoader) || (inTransition == null ? void 0 : inTransition.hideLoader);
    if (hideLoader) {
      this.maybeLoadScene(destinationScene, hideLoader);
    }
    this._emitEvent("navigationstart", sourceScene, destinationScene);
    if (outTransition) {
      await this.playTransition(outTransition, sourceSceneInstance);
    }
    await this.maybeLoadScene(destinationScene, hideLoader);
    if (inTransition) {
      await inTransition.onPreviousSceneDeactivate(this.currentScene);
    }
    if (inTransition) {
      inTransition._addToTargetScene(this._engine, maybeDest);
    }
    await this.swapScene(destinationScene, sceneActivationData);
    this._emitEvent("navigation", sourceScene, destinationScene);
    if (inTransition) {
      await this.playTransition(inTransition, maybeDest);
    }
    this._emitEvent("navigationend", sourceScene, destinationScene);
    (_f = this._engine.input) == null ? void 0 : _f.toggleEnabled(engineInputEnabled);
    this._isTransitioning = false;
  }
  /**
   * Retrieves a scene instance by key if it's registered.
   *
   * This will call any constructors that were given as a definition
   * @param scene
   */
  getSceneInstance(scene) {
    const sceneDefinition = this.getSceneDefinition(scene);
    if (!sceneDefinition) {
      return void 0;
    }
    if (this._sceneToInstance.has(scene)) {
      return this._sceneToInstance.get(scene);
    }
    if (sceneDefinition instanceof Scene) {
      this._sceneToInstance.set(scene, sceneDefinition);
      return sceneDefinition;
    }
    const newScene = new sceneDefinition();
    this._sceneToInstance.set(scene, newScene);
    return newScene;
  }
  /**
   * Triggers scene loading if has not already been loaded
   * @param scene
   * @param hideLoader
   */
  async maybeLoadScene(scene, hideLoader = false) {
    var _a;
    const loader = (_a = this._getLoader(scene)) != null ? _a : new DefaultLoader();
    const sceneToLoad = this.getSceneDefinition(scene);
    const sceneToLoadInstance = this.getSceneInstance(scene);
    if (sceneToLoad && sceneToLoadInstance && !this._loadedScenes.has(sceneToLoadInstance)) {
      sceneToLoadInstance.onPreLoad(loader);
      sceneToLoadInstance.events.emit("preload", { loader });
      if (hideLoader) {
        this._engine.load(loader, hideLoader);
      } else {
        await this._engine.load(loader);
      }
      this._loadedScenes.add(sceneToLoadInstance);
    }
  }
  /**
   * Plays a transition in the current scene and does book keeping for input.
   * @param transition
   */
  async playTransition(transition, targetScene) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!this.isInitialized) {
      this._deferredTransition = transition;
      return;
    }
    if (transition) {
      this.currentTransition = transition;
      const sceneInputEnabled = (_b = (_a = targetScene.input) == null ? void 0 : _a.enabled) != null ? _b : true;
      (_c = targetScene.input) == null ? void 0 : _c.toggleEnabled(!transition.blockInput);
      (_d = this._engine.input) == null ? void 0 : _d.toggleEnabled(!transition.blockInput);
      targetScene.events.emit("transitionstart", transition);
      this.currentTransition._addToTargetScene(this._engine, targetScene);
      await this.currentTransition._play();
      targetScene.events.emit("transitionend", transition);
      (_e = targetScene.input) == null ? void 0 : _e.toggleEnabled(sceneInputEnabled);
    }
    (_f = this.currentTransition) == null ? void 0 : _f.kill();
    (_g = this.currentTransition) == null ? void 0 : _g.reset();
    this.currentTransition = void 0;
  }
  /**
   * Swaps the current and destination scene after performing required lifecycle events
   *
   * Note: swap scene will wait for any pending loader on the destination scene
   * @param destinationScene
   * @param data
   */
  async swapScene(destinationScene, data) {
    const engine = this._engine;
    if (!this.isInitialized) {
      this._deferredGoto = destinationScene;
      return;
    }
    const maybeDest = this.getSceneInstance(destinationScene);
    if (maybeDest) {
      const previousScene = this.currentScene;
      const nextScene = maybeDest;
      let previousSceneData = void 0;
      this._logger.debug("Going to scene:", destinationScene);
      if (this.currentScene.isInitialized) {
        const context2 = { engine, previousScene, nextScene };
        previousSceneData = await this.currentScene._deactivate(context2);
        this.currentScene.events.emit("deactivate", new DeactivateEvent(context2, this.currentScene));
        this.currentScene.input.clear();
      }
      const destLoader = this._sceneToLoader.get(destinationScene);
      await (destLoader == null ? void 0 : destLoader.areResourcesLoaded());
      this.currentScene = nextScene;
      this.currentSceneName = destinationScene;
      engine.screen.setCurrentCamera(nextScene.camera);
      await this.currentScene._initialize(engine);
      const context = { engine, previousScene, previousSceneData, nextScene, data };
      await this.currentScene._activate(context);
      this.currentScene.events.emit("activate", new ActivateEvent(context, this.currentScene));
    } else {
      this._logger.error("Scene", destinationScene, "does not exist!");
    }
  }
  _emitEvent(eventName, sourceScene, destinationScene) {
    const source = this.getSceneDefinition(sourceScene);
    const dest = this.getSceneDefinition(destinationScene);
    this.events.emit(eventName, {
      sourceScene: source,
      sourceName: sourceScene,
      destinationScene: dest,
      destinationName: destinationScene
    });
  }
}
function createContext() {
  const ctx = {
    scope: (value, cb) => {
      const old = ctx.value;
      ctx.value = value;
      try {
        return cb();
      } catch (e) {
        throw e;
      } finally {
        ctx.value = old;
      }
    },
    value: void 0
  };
  return ctx;
}
function useContext(context) {
  return context.value;
}
const DefaultGarbageCollectionOptions = {
  textureCollectInterval: 6e4
  // TODO future work to integrate the font and text configuration, refactor existing collection mechanism
  // fontCollectInterval: 60_000,
  // textMeasurementCollectInterval: 60_000,
};
class GarbageCollector {
  constructor(options) {
    this.options = options;
    this._running = false;
    this._collectionMap = /* @__PURE__ */ new Map();
    this._collectors = /* @__PURE__ */ new Map();
    this.collectStaleResources = (deadline) => {
      if (!this._running) {
        return;
      }
      for (const [type, [collector, timeoutInterval]] of this._collectors.entries()) {
        const now = this.options.getTimestamp();
        for (const [resource, [resourceType, time]] of this._collectionMap.entries()) {
          if (type !== resourceType || time + timeoutInterval >= now) {
            continue;
          }
          const collected = collector(resource);
          if (collected) {
            this._collectionMap.delete(resource);
          }
        }
      }
      this._collectHandle = requestIdleCallback(this.collectStaleResources);
    };
  }
  /**
   *
   * @param type Resource type
   * @param timeoutInterval If resource type exceeds interval in milliseconds collect() is called
   * @param collect Collection implementation, returns true if collected
   */
  registerCollector(type, timeoutInterval, collect) {
    this._collectors.set(type, [collect, timeoutInterval]);
  }
  /**
   * Add a resource to be tracked for collection
   * @param type
   * @param resource
   */
  addCollectableResource(type, resource) {
    this._collectionMap.set(resource, [type, this.options.getTimestamp()]);
  }
  /**
   * Update the resource last used timestamp preventing collection
   * @param resource
   */
  touch(resource) {
    const collectionData = this._collectionMap.get(resource);
    if (collectionData) {
      this._collectionMap.set(resource, [collectionData[0], this.options.getTimestamp()]);
    }
  }
  /**
   * Force collect all resources, useful for shutting down a game
   * or if you know that you will not use anything you've allocated before now
   */
  forceCollectAll() {
    for (const [_, [collector]] of this._collectors.entries()) {
      for (const [resource] of this._collectionMap.entries()) {
        const collected = collector(resource);
        if (collected) {
          this._collectionMap.delete(resource);
        }
      }
    }
  }
  running() {
    return this._running;
  }
  /**
   * Starts the garbage collection loop
   */
  start() {
    this._running = true;
    this.collectStaleResources();
  }
  /**
   * Stops the garbage collection loop
   */
  stop() {
    this._running = false;
    cancelIdleCallback(this._collectHandle);
  }
}
polyfill();
const EngineEvents = {
  FallbackGraphicsContext: "fallbackgraphicscontext",
  Initialize: "initialize",
  Visible: "visible",
  Hidden: "hidden",
  Start: "start",
  Stop: "stop",
  PreUpdate: "preupdate",
  PostUpdate: "postupdate",
  PreFrame: "preframe",
  PostFrame: "postframe",
  PreDraw: "predraw",
  PostDraw: "postdraw",
  ...DirectorEvents
};
var ScrollPreventionMode = /* @__PURE__ */ ((ScrollPreventionMode2) => {
  ScrollPreventionMode2[ScrollPreventionMode2["None"] = 0] = "None";
  ScrollPreventionMode2[ScrollPreventionMode2["Canvas"] = 1] = "Canvas";
  ScrollPreventionMode2[ScrollPreventionMode2["All"] = 2] = "All";
  return ScrollPreventionMode2;
})(ScrollPreventionMode || {});
const _Engine = class _Engine2 {
  /**
   * Creates a new game using the given {@apilink EngineOptions}. By default, if no options are provided,
   * the game will be rendered full screen (taking up all available browser window space).
   * You can customize the game rendering through {@apilink EngineOptions}.
   *
   * Example:
   *
   * ```js
   * var game = new ex.Engine({
   *   width: 0, // the width of the canvas
   *   height: 0, // the height of the canvas
   *   enableCanvasTransparency: true, // the transparencySection of the canvas
   *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own
   *   displayMode: ex.DisplayMode.FullScreen, // the display mode
   *   pointerScope: ex.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events
   *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine
   * });
   *
   * // call game.start, which is a Promise
   * game.start().then(function () {
   *   // ready, set, go!
   * });
   * ```
   */
  constructor(options) {
    this.scope = (cb) => _Engine2.Context.scope(this, cb);
    this.version = EX_VERSION;
    this.events = new EventEmitter();
    this.maxFps = Number.POSITIVE_INFINITY;
    this._inputEnabled = true;
    this._suppressPlayButton = false;
    this.pauseAudioWhenHidden = true;
    this._isDebug = false;
    this.enableCanvasTransparency = true;
    this.onFatalException = (e) => {
      Logger.getInstance().fatal(e, e.stack);
    };
    this._toaster = new Toaster();
    this._timescale = 1;
    this._isInitialized = false;
    this._hasCreatedCanvas = false;
    this._originalOptions = {};
    this._handleWebGLContextLost = (e) => {
      var _a2;
      e.preventDefault();
      this.clock.stop();
      this._logger.fatalOnce("WebGL Graphics Lost", e);
      const container = document.createElement("div");
      container.id = "ex-webgl-graphics-context-lost";
      container.style.position = "absolute";
      container.style.zIndex = "99";
      container.style.left = "50%";
      container.style.top = "50%";
      container.style.display = "flex";
      container.style.flexDirection = "column";
      container.style.transform = "translate(-50%, -50%)";
      container.style.backgroundColor = "white";
      container.style.padding = "10px";
      container.style.borderStyle = "solid 1px";
      const div = document.createElement("div");
      div.innerHTML = `
      <h1>There was an issue rendering, please refresh the page.</h1>
      <div>
        <p>WebGL Graphics Context Lost</p>

        <button id="ex-webgl-graphics-reload">Refresh Page</button>

        <p>There are a few reasons this might happen:</p>
        <ul>
          <li>Two or more pages are placing a high demand on the GPU</li>
          <li>Another page or operation has stalled the GPU and the browser has decided to reset the GPU</li>
          <li>The computer has multiple GPUs and the user has switched between them</li>
          <li>Graphics driver has crashed or restarted</li>
          <li>Graphics driver was updated</li>
        </ul>
      </div>
    `;
      container.appendChild(div);
      if ((_a2 = this.canvas) == null ? void 0 : _a2.parentElement) {
        this.canvas.parentElement.appendChild(container);
        const button = div.querySelector("#ex-webgl-graphics-reload");
        button == null ? void 0 : button.addEventListener("click", () => location.reload());
      }
    };
    this._performanceThresholdTriggered = false;
    this._fpsSamples = [];
    this._disposed = false;
    this._isLoading = false;
    this._hideLoader = false;
    this._isReadyFuture = new Future();
    this.currentFrameElapsedMs = 0;
    this.currentFrameLagMs = 0;
    this._lagMs = 0;
    this._screenShotRequests = [];
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    options = { ..._Engine2._DEFAULT_ENGINE_OPTIONS, ...options };
    this._originalOptions = options;
    Flags.freeze();
    this.browser = new BrowserEvents(window, document);
    const detector = new Detector();
    if (!options.suppressMinimumBrowserFeatureDetection && !(this._compatible = detector.test())) {
      const message = document.createElement("div");
      message.innerText = "Sorry, your browser does not support all the features needed for Excalibur";
      document.body.appendChild(message);
      detector.failedTests.forEach(function(test) {
        const testMessage = document.createElement("div");
        testMessage.innerText = "Browser feature missing " + test;
        document.body.appendChild(testMessage);
      });
      if (options.canvasElementId) {
        const canvas = document.getElementById(options.canvasElementId);
        if (canvas) {
          canvas.parentElement.removeChild(canvas);
        }
      }
      return;
    } else {
      this._compatible = true;
    }
    if (console.log && !options.suppressConsoleBootMessage) {
      console.log(
        `%cPowered by Excalibur.js (v${EX_VERSION})`,
        "background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;"
      );
      console.log(
        "\n      /| ________________\nO|===|* >________________>\n      \\|"
      );
      console.log("Visit", "http://excaliburjs.com", "for more information");
    }
    if (options.suppressPlayButton) {
      this._suppressPlayButton = true;
    }
    this._logger = Logger.getInstance();
    if (this._logger.defaultLevel === LogLevel.Debug) {
      detector.logBrowserFeatures();
    }
    this._logger.debug("Building engine...");
    if (options.garbageCollection === true) {
      this.garbageCollectorConfig = {
        ...DefaultGarbageCollectionOptions
      };
    } else if (options.garbageCollection === false) {
      this._logger.warn(
        "WebGL Garbage Collection Disabled!!! If you leak any images over time your game will crash when GPU memory is exhausted"
      );
      this.garbageCollectorConfig = null;
    } else {
      this.garbageCollectorConfig = {
        ...DefaultGarbageCollectionOptions,
        ...options.garbageCollection
      };
    }
    this._garbageCollector = new GarbageCollector({ getTimestamp: Date.now });
    this.canvasElementId = options.canvasElementId;
    if (options.canvasElementId) {
      this._logger.debug("Using Canvas element specified: " + options.canvasElementId);
      if (document.getElementById(options.canvasElementId) === null) {
        throw new Error("Cannot find existing element in the DOM, please ensure element is created prior to engine creation.");
      }
      this.canvas = document.getElementById(options.canvasElementId);
      this._hasCreatedCanvas = false;
    } else if (options.canvasElement) {
      this._logger.debug("Using Canvas element specified:", options.canvasElement);
      this.canvas = options.canvasElement;
      this._hasCreatedCanvas = false;
    } else {
      this._logger.debug("Using generated canvas element");
      this.canvas = document.createElement("canvas");
      this._hasCreatedCanvas = true;
    }
    if (this.canvas && !options.enableCanvasContextMenu) {
      this.canvas.addEventListener("contextmenu", (evt) => {
        evt.preventDefault();
      });
    }
    let displayMode = (_a = options.displayMode) != null ? _a : DisplayMode.Fixed;
    if (options.width && options.height || options.viewport) {
      if (options.displayMode === void 0) {
        displayMode = DisplayMode.Fixed;
      }
      this._logger.debug("Engine viewport is size " + options.width + " x " + options.height);
    } else if (!options.displayMode) {
      this._logger.debug("Engine viewport is fit");
      displayMode = DisplayMode.FitScreen;
    }
    const global = options.global && typeof options.global === "function" ? options.global() : options.global;
    this.global = global != null ? global : getDefaultGlobal();
    this.grabWindowFocus = options.grabWindowFocus;
    this.pointerScope = options.pointerScope;
    this._originalDisplayMode = displayMode;
    let pixelArtSampler;
    let uvPadding;
    let nativeContextAntialiasing;
    let canvasImageRendering;
    let filtering;
    let multiSampleAntialiasing;
    if (typeof options.antialiasing === "object") {
      ({ pixelArtSampler, nativeContextAntialiasing, multiSampleAntialiasing, filtering, canvasImageRendering } = {
        ...options.pixelArt ? DefaultPixelArtOptions : DefaultAntialiasOptions,
        ...options.antialiasing
      });
    } else {
      pixelArtSampler = !!options.pixelArt;
      nativeContextAntialiasing = false;
      multiSampleAntialiasing = options.antialiasing;
      canvasImageRendering = options.antialiasing ? "auto" : "pixelated";
      filtering = options.antialiasing ? ImageFiltering.Blended : ImageFiltering.Pixel;
    }
    if (nativeContextAntialiasing && multiSampleAntialiasing) {
      this._logger.warnOnce(
        `Cannot use antialias setting nativeContextAntialiasing and multiSampleAntialiasing at the same time, they are incompatible settings. If you aren't sure use multiSampleAntialiasing`
      );
    }
    if (options.pixelArt) {
      uvPadding = 0.25;
    }
    if (!options.antialiasing || filtering === ImageFiltering.Pixel) {
      uvPadding = 0;
    }
    uvPadding = (_c = (_b = options.uvPadding) != null ? _b : uvPadding) != null ? _c : 0.01;
    let useCanvasGraphicsContext = Flags.isEnabled("use-canvas-context");
    if (!useCanvasGraphicsContext) {
      try {
        this.graphicsContext = new ExcaliburGraphicsContextWebGL({
          canvasElement: this.canvas,
          enableTransparency: this.enableCanvasTransparency,
          pixelArtSampler,
          antialiasing: nativeContextAntialiasing,
          multiSampleAntialiasing,
          uvPadding,
          powerPreference: options.powerPreference,
          backgroundColor: options.backgroundColor,
          snapToPixel: options.snapToPixel,
          useDrawSorting: options.useDrawSorting,
          garbageCollector: this.garbageCollectorConfig ? {
            garbageCollector: this._garbageCollector,
            collectionInterval: this.garbageCollectorConfig.textureCollectInterval
          } : null,
          handleContextLost: (_d = options.handleContextLost) != null ? _d : this._handleWebGLContextLost,
          handleContextRestored: options.handleContextRestored
        });
      } catch (e) {
        this._logger.warn(
          `Excalibur could not load webgl for some reason (${e.message}) and loaded a Canvas 2D fallback. Some features of Excalibur will not work in this mode. 

Read more about this issue at https://excaliburjs.com/docs/performance`
        );
        useCanvasGraphicsContext = true;
      }
    }
    if (useCanvasGraphicsContext) {
      this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({
        canvasElement: this.canvas,
        enableTransparency: this.enableCanvasTransparency,
        antialiasing: nativeContextAntialiasing,
        backgroundColor: options.backgroundColor,
        snapToPixel: options.snapToPixel,
        useDrawSorting: options.useDrawSorting
      });
    }
    this.screen = new Screen({
      canvas: this.canvas,
      context: this.graphicsContext,
      antialiasing: nativeContextAntialiasing,
      canvasImageRendering,
      browser: this.browser,
      viewport: (_e = options.viewport) != null ? _e : options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA,
      resolution: options.resolution,
      displayMode,
      pixelRatio: options.suppressHiDPIScaling ? 1 : (_f = options.pixelRatio) != null ? _f : null
    });
    TextureLoader.filtering = filtering;
    if (options.backgroundColor) {
      this.backgroundColor = options.backgroundColor.clone();
    }
    this.maxFps = (_g = options.maxFps) != null ? _g : this.maxFps;
    this.fixedUpdateTimestep = (_h = options.fixedUpdateTimestep) != null ? _h : this.fixedUpdateTimestep;
    this.fixedUpdateFps = (_i = options.fixedUpdateFps) != null ? _i : this.fixedUpdateFps;
    this.fixedUpdateTimestep = this.fixedUpdateTimestep || 1e3 / this.fixedUpdateFps;
    this.clock = new StandardClock({
      maxFps: this.maxFps,
      tick: this._mainloop.bind(this),
      onFatalException: (e) => this.onFatalException(e)
    });
    this.enableCanvasTransparency = options.enableCanvasTransparency;
    if (typeof options.physics === "boolean") {
      this.physics = {
        ...getDefaultPhysicsConfig(),
        enabled: options.physics
      };
    } else {
      this.physics = {
        ...getDefaultPhysicsConfig()
      };
      mergeDeep(this.physics, options.physics);
    }
    this.debug = new DebugConfig(this);
    this.director = new Director(this, options.scenes);
    this.director.events.pipe(this.events);
    this._initialize(options);
    window.___EXCALIBUR_DEVTOOL = this;
    _Engine2.InstanceCount++;
  }
  static useEngine() {
    const value = useContext(_Engine2.Context);
    if (!value) {
      throw new Error("Cannot inject engine with `useEngine()`, `useEngine()` was called outside of Engine lifecycle scope.");
    }
    return value;
  }
  /**
   * The width of the game canvas in pixels (physical width component of the
   * resolution of the canvas element)
   */
  get canvasWidth() {
    return this.screen.canvasWidth;
  }
  /**
   * Returns half width of the game canvas in pixels (half physical width component)
   */
  get halfCanvasWidth() {
    return this.screen.halfCanvasWidth;
  }
  /**
   * The height of the game canvas in pixels, (physical height component of
   * the resolution of the canvas element)
   */
  get canvasHeight() {
    return this.screen.canvasHeight;
  }
  /**
   * Returns half height of the game canvas in pixels (half physical height component)
   */
  get halfCanvasHeight() {
    return this.screen.halfCanvasHeight;
  }
  /**
   * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get drawWidth() {
    return this.screen.drawWidth;
  }
  /**
   * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get halfDrawWidth() {
    return this.screen.halfDrawWidth;
  }
  /**
   * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get drawHeight() {
    return this.screen.drawHeight;
  }
  /**
   * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
   */
  get halfDrawHeight() {
    return this.screen.halfDrawHeight;
  }
  /**
   * Returns whether excalibur detects the current screen to be HiDPI
   */
  get isHiDpi() {
    return this.screen.isHiDpi;
  }
  /**
   * Access {@apilink stats} that holds frame statistics.
   */
  get stats() {
    return this.debug.stats;
  }
  /**
   * The current {@apilink Scene} being drawn and updated on screen
   */
  get currentScene() {
    return this.director.currentScene;
  }
  /**
   * The current {@apilink Scene} being drawn and updated on screen
   */
  get currentSceneName() {
    return this.director.currentSceneName;
  }
  /**
   * The default {@apilink Scene} of the game, use {@apilink Engine.goToScene} to transition to different scenes.
   */
  get rootScene() {
    return this.director.rootScene;
  }
  /**
   * Contains all the scenes currently registered with Excalibur
   */
  get scenes() {
    return this.director.scenes;
  }
  /**
   * Indicates whether the engine is set to fullscreen or not
   */
  get isFullscreen() {
    return this.screen.isFullScreen;
  }
  /**
   * Indicates the current {@apilink DisplayMode} of the engine.
   */
  get displayMode() {
    return this.screen.displayMode;
  }
  /**
   * Returns the calculated pixel ration for use in rendering
   */
  get pixelRatio() {
    return this.screen.pixelRatio;
  }
  get isDebug() {
    return this._isDebug;
  }
  /**
   * Hints the graphics context to truncate fractional world space coordinates
   */
  get snapToPixel() {
    return this.graphicsContext.snapToPixel;
  }
  set snapToPixel(shouldSnapToPixel) {
    this.graphicsContext.snapToPixel = shouldSnapToPixel;
  }
  emit(eventName, event) {
    this.events.emit(eventName, event);
  }
  on(eventName, handler) {
    return this.events.on(eventName, handler);
  }
  once(eventName, handler) {
    return this.events.once(eventName, handler);
  }
  off(eventName, handler) {
    this.events.off(eventName, handler);
  }
  _monitorPerformanceThresholdAndTriggerFallback() {
    const { allow } = this._originalOptions.configurePerformanceCanvas2DFallback;
    let { threshold, showPlayerMessage } = this._originalOptions.configurePerformanceCanvas2DFallback;
    if (threshold === void 0) {
      threshold = _Engine2._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.threshold;
    }
    if (showPlayerMessage === void 0) {
      showPlayerMessage = _Engine2._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.showPlayerMessage;
    }
    if (!Flags.isEnabled("use-canvas-context") && allow && this.ready && !this._performanceThresholdTriggered) {
      if (this._fpsSamples.length === threshold.numberOfFrames) {
        this._fpsSamples.splice(0, 1);
      }
      this._fpsSamples.push(this.clock.fpsSampler.fps);
      let total = 0;
      for (let i = 0; i < this._fpsSamples.length; i++) {
        total += this._fpsSamples[i];
      }
      const average = total / this._fpsSamples.length;
      if (this._fpsSamples.length === threshold.numberOfFrames) {
        if (average <= threshold.fps) {
          this._performanceThresholdTriggered = true;
          this._logger.warn(
            `Switching to browser 2D Canvas fallback due to performance. Some features of Excalibur will not work in this mode.
this might mean your browser doesn't have webgl enabled or hardware acceleration is unavailable.

If in Chrome:
  * Visit Settings > Advanced > System, and ensure "Use Hardware Acceleration" is checked.
  * Visit chrome://flags/#ignore-gpu-blocklist and ensure "Override software rendering list" is "enabled"
If in Firefox, visit about:config
  * Ensure webgl.disabled = false
  * Ensure webgl.force-enabled = true
  * Ensure layers.acceleration.force-enabled = true

Read more about this issue at https://excaliburjs.com/docs/performance`
          );
          if (showPlayerMessage) {
            this._toaster.toast(
              "Excalibur is encountering performance issues. It's possible that your browser doesn't have hardware acceleration enabled. Visit [LINK] for more information and potential solutions.",
              "https://excaliburjs.com/docs/performance"
            );
          }
          this.useCanvas2DFallback();
          this.emit("fallbackgraphicscontext", this.graphicsContext);
        }
      }
    }
  }
  /**
   * Switches the engine's graphics context to the 2D Canvas.
   * @warning Some features of Excalibur will not work in this mode.
   */
  useCanvas2DFallback() {
    var _a, _b, _c;
    const newCanvas = this.canvas.cloneNode(false);
    this.canvas.parentNode.replaceChild(newCanvas, this.canvas);
    this.canvas = newCanvas;
    const options = { ...this._originalOptions, antialiasing: this.screen.antialiasing };
    const displayMode = this._originalDisplayMode;
    this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({
      canvasElement: this.canvas,
      enableTransparency: this.enableCanvasTransparency,
      antialiasing: options.antialiasing,
      backgroundColor: options.backgroundColor,
      snapToPixel: options.snapToPixel,
      useDrawSorting: options.useDrawSorting
    });
    if (this.screen) {
      this.screen.dispose();
    }
    this.screen = new Screen({
      canvas: this.canvas,
      context: this.graphicsContext,
      antialiasing: (_a = options.antialiasing) != null ? _a : true,
      browser: this.browser,
      viewport: (_b = options.viewport) != null ? _b : options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA,
      resolution: options.resolution,
      displayMode,
      pixelRatio: options.suppressHiDPIScaling ? 1 : (_c = options.pixelRatio) != null ? _c : null
    });
    this.screen.setCurrentCamera(this.currentScene.camera);
    this.input.pointers.detach();
    const pointerTarget = options && options.pointerScope === PointerScope.Document ? document : this.canvas;
    this.input.pointers = this.input.pointers.recreate(pointerTarget, this);
    this.input.pointers.init();
  }
  /**
   * Attempts to completely clean up excalibur resources, including removing the canvas from the dom.
   *
   * To start again you will need to new up an Engine.
   */
  dispose() {
    if (!this._disposed) {
      this._disposed = true;
      this.stop();
      this._garbageCollector.forceCollectAll();
      this.input.toggleEnabled(false);
      if (this._hasCreatedCanvas) {
        this.canvas.parentNode.removeChild(this.canvas);
      }
      this.canvas = null;
      this.screen.dispose();
      this.graphicsContext.dispose();
      this.graphicsContext = null;
      _Engine2.InstanceCount--;
    }
  }
  isDisposed() {
    return this._disposed;
  }
  /**
   * Returns a BoundingBox of the top left corner of the screen
   * and the bottom right corner of the screen.
   */
  getWorldBounds() {
    return this.screen.getWorldBounds();
  }
  /**
   * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)
   */
  get timescale() {
    return this._timescale;
  }
  /**
   * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects
   * when using time-based movement.
   */
  set timescale(value) {
    if (value < 0) {
      Logger.getInstance().warnOnce("engine.timescale to a value less than 0 are ignored");
      return;
    }
    this._timescale = value;
  }
  /**
   * Adds a {@apilink Timer} to the {@apilink currentScene}.
   * @param timer  The timer to add to the {@apilink currentScene}.
   */
  addTimer(timer) {
    return this.currentScene.addTimer(timer);
  }
  /**
   * Removes a {@apilink Timer} from the {@apilink currentScene}.
   * @param timer  The timer to remove to the {@apilink currentScene}.
   */
  removeTimer(timer) {
    return this.currentScene.removeTimer(timer);
  }
  /**
   * Adds a {@apilink Scene} to the engine, think of scenes in Excalibur as you
   * would levels or menus.
   * @param key  The name of the scene, must be unique
   * @param scene The scene to add to the engine
   */
  addScene(key, scene) {
    this.director.add(key, scene);
    return this;
  }
  /**
   * @internal
   */
  removeScene(entity) {
    this.director.remove(entity);
  }
  add(entity) {
    if (arguments.length === 2) {
      this.director.add(arguments[0], arguments[1]);
      return;
    }
    const maybeDeferred = this.director.getDeferredScene();
    if (maybeDeferred instanceof Scene) {
      maybeDeferred.add(entity);
    } else {
      this.currentScene.add(entity);
    }
  }
  remove(entity) {
    if (entity instanceof Entity) {
      this.currentScene.remove(entity);
    }
    if (entity instanceof Scene || isSceneConstructor(entity)) {
      this.removeScene(entity);
    }
    if (typeof entity === "string") {
      this.removeScene(entity);
    }
  }
  /**
   * Changes the current scene with optionally supplied:
   * * Activation data
   * * Transitions
   * * Loaders
   *
   * Example:
   * ```typescript
   * game.goToScene('myScene', {
   *   sceneActivationData: {any: 'thing at all'},
   *   destinationIn: new FadeInOut({duration: 1000, direction: 'in'}),
   *   sourceOut: new FadeInOut({duration: 1000, direction: 'out'}),
   *   loader: MyLoader
   * });
   * ```
   *
   * Scenes are defined in the Engine constructor
   * ```typescript
   * const engine = new ex.Engine({
      scenes: {...}
    });
   * ```
   * Or by adding dynamically
   *
   * ```typescript
   * engine.addScene('myScene', new ex.Scene());
   * ```
   * @param destinationScene
   * @param options
   */
  async goToScene(destinationScene, options) {
    await this.scope(async () => {
      await this.director.goToScene(destinationScene, options);
    });
  }
  /**
   * Transforms the current x, y from screen coordinates to world coordinates
   * @param point  Screen coordinate to convert
   */
  screenToWorldCoordinates(point2) {
    return this.screen.screenToWorldCoordinates(point2);
  }
  /**
   * Transforms a world coordinate, to a screen coordinate
   * @param point  World coordinate to convert
   */
  worldToScreenCoordinates(point2) {
    return this.screen.worldToScreenCoordinates(point2);
  }
  /**
   * Initializes the internal canvas, rendering context, display mode, and native event listeners
   */
  _initialize(options) {
    var _a, _b;
    this.pageScrollPreventionMode = options.scrollPreventionMode;
    const pointerTarget = options && options.pointerScope === PointerScope.Document ? document : this.canvas;
    const grabWindowFocus = (_b = (_a = this._originalOptions) == null ? void 0 : _a.grabWindowFocus) != null ? _b : true;
    this.input = new InputHost({
      global: this.global,
      pointerTarget,
      grabWindowFocus,
      engine: this
    });
    this.inputMapper = this.input.inputMapper;
    this.browser.document.on("visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        this.events.emit("hidden", new HiddenEvent(this));
        this._logger.debug("Window hidden");
      } else if (document.visibilityState === "visible") {
        this.events.emit("visible", new VisibleEvent(this));
        this._logger.debug("Window visible");
      }
    });
    if (!this.canvasElementId && !options.canvasElement) {
      document.body.appendChild(this.canvas);
    }
  }
  toggleInputEnabled(enabled) {
    this._inputEnabled = enabled;
    this.input.toggleEnabled(this._inputEnabled);
  }
  onInitialize(engine) {
  }
  /**
   * Gets whether the actor is Initialized
   */
  get isInitialized() {
    return this._isInitialized;
  }
  async _overrideInitialize(engine) {
    if (!this.isInitialized) {
      await this.director.onInitialize();
      await this.onInitialize(engine);
      this.events.emit("initialize", new InitializeEvent(engine, this));
      this._isInitialized = true;
    }
  }
  /**
   * Updates the entire state of the game
   * @param elapsed  Number of milliseconds elapsed since the last update.
   */
  _update(elapsed) {
    var _a;
    if (this._isLoading) {
      (_a = this._loader) == null ? void 0 : _a.onUpdate(this, elapsed);
      this.input.update();
      return;
    }
    this.clock.__runScheduledCbs("preupdate");
    this._preupdate(elapsed);
    this.currentScene.update(this, elapsed);
    this.graphicsContext.updatePostProcessors(elapsed);
    this.clock.__runScheduledCbs("postupdate");
    this._postupdate(elapsed);
    this.input.update();
  }
  /**
   * @internal
   */
  _preupdate(elapsed) {
    this.emit("preupdate", new PreUpdateEvent(this, elapsed, this));
    this.onPreUpdate(this, elapsed);
  }
  /**
   * Safe to override method
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   */
  onPreUpdate(engine, elapsed) {
  }
  /**
   * @internal
   */
  _postupdate(elapsed) {
    this.emit("postupdate", new PostUpdateEvent(this, elapsed, this));
    this.onPostUpdate(this, elapsed);
  }
  /**
   * Safe to override method
   * @param engine The reference to the current game engine
   * @param elapsed  The time elapsed since the last update in milliseconds
   */
  onPostUpdate(engine, elapsed) {
  }
  /**
   * Draws the entire game
   * @param elapsed  Number of milliseconds elapsed since the last draw.
   */
  _draw(elapsed) {
    var _a, _b;
    this.graphicsContext.backgroundColor = (_a = this.currentScene.backgroundColor) != null ? _a : this.backgroundColor;
    this.graphicsContext.beginDrawLifecycle();
    this.graphicsContext.clear();
    this.clock.__runScheduledCbs("predraw");
    this._predraw(this.graphicsContext, elapsed);
    if (this._isLoading) {
      if (!this._hideLoader) {
        (_b = this._loader) == null ? void 0 : _b.canvas.draw(this.graphicsContext, 0, 0);
        this.clock.__runScheduledCbs("postdraw");
        this.graphicsContext.flush();
        this.graphicsContext.endDrawLifecycle();
      }
      return;
    }
    this.currentScene.draw(this.graphicsContext, elapsed);
    this.clock.__runScheduledCbs("postdraw");
    this._postdraw(this.graphicsContext, elapsed);
    this.graphicsContext.flush();
    this.graphicsContext.endDrawLifecycle();
    this._checkForScreenShots();
  }
  /**
   * @internal
   */
  _predraw(ctx, elapsed) {
    this.emit("predraw", new PreDrawEvent(ctx, elapsed, this));
    this.onPreDraw(ctx, elapsed);
  }
  /**
   * Safe to override method to hook into pre draw
   * @param ctx {@link ExcaliburGraphicsContext} for drawing
   * @param elapsed  Number of milliseconds elapsed since the last draw.
   */
  onPreDraw(ctx, elapsed) {
  }
  /**
   * @internal
   */
  _postdraw(ctx, elapsed) {
    this.emit("postdraw", new PostDrawEvent(ctx, elapsed, this));
    this.onPostDraw(ctx, elapsed);
  }
  /**
   * Safe to override method to hook into pre draw
   * @param ctx {@link ExcaliburGraphicsContext} for drawing
   * @param elapsed  Number of milliseconds elapsed since the last draw.
   */
  onPostDraw(ctx, elapsed) {
  }
  /**
   * Enable or disable Excalibur debugging functionality.
   * @param toggle a value that debug drawing will be changed to
   */
  showDebug(toggle) {
    this._isDebug = toggle;
  }
  /**
   * Toggle Excalibur debugging functionality.
   */
  toggleDebug() {
    this._isDebug = !this._isDebug;
    return this._isDebug;
  }
  /**
   * Returns true when loading is totally complete and the player has clicked start
   */
  get loadingComplete() {
    return !this._isLoading;
  }
  get ready() {
    return this._isReadyFuture.isCompleted;
  }
  isReady() {
    return this._isReadyFuture.promise;
  }
  async start(sceneNameOrLoader, options) {
    await this.scope(async () => {
      if (!this._compatible) {
        throw new Error("Excalibur is incompatible with your browser");
      }
      this._isLoading = true;
      let loader;
      if (sceneNameOrLoader instanceof DefaultLoader) {
        loader = sceneNameOrLoader;
      } else if (typeof sceneNameOrLoader === "string") {
        this.director.configureStart(sceneNameOrLoader, options);
        loader = this.director.mainLoader;
      }
      this._logger.debug("Starting game clock...");
      this.browser.resume();
      this.clock.start();
      if (this.garbageCollectorConfig) {
        this._garbageCollector.start();
      }
      this._logger.debug("Game clock started");
      await this.load(loader != null ? loader : new Loader());
      await this._overrideInitialize(this);
      this._isReadyFuture.resolve();
      this.emit("start", new GameStartEvent(this));
      return this._isReadyFuture.promise;
    });
  }
  _mainloop(elapsed) {
    this.scope(() => {
      this.emit("preframe", new PreFrameEvent(this, this.stats.prevFrame));
      const elapsedMs = elapsed * this.timescale;
      this.currentFrameElapsedMs = elapsedMs;
      const frameId = this.stats.prevFrame.id + 1;
      this.stats.currFrame.reset();
      this.stats.currFrame.id = frameId;
      this.stats.currFrame.elapsedMs = elapsedMs;
      this.stats.currFrame.fps = this.clock.fpsSampler.fps;
      GraphicsDiagnostics.clear();
      const beforeUpdate = this.clock.now();
      const fixedTimestepMs = this.fixedUpdateTimestep;
      if (this.fixedUpdateTimestep) {
        this._lagMs += elapsedMs;
        while (this._lagMs >= fixedTimestepMs) {
          this._update(fixedTimestepMs);
          this._lagMs -= fixedTimestepMs;
        }
      } else {
        this._update(elapsedMs);
      }
      const afterUpdate = this.clock.now();
      this.currentFrameLagMs = this._lagMs;
      this._draw(elapsedMs);
      const afterDraw = this.clock.now();
      this.stats.currFrame.duration.update = afterUpdate - beforeUpdate;
      this.stats.currFrame.duration.draw = afterDraw - afterUpdate;
      this.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;
      this.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;
      this.emit("postframe", new PostFrameEvent(this, this.stats.currFrame));
      this.stats.prevFrame.reset(this.stats.currFrame);
      this._monitorPerformanceThresholdAndTriggerFallback();
    });
  }
  /**
   * Stops Excalibur's main loop, useful for pausing the game.
   */
  stop() {
    if (this.clock.isRunning()) {
      this.emit("stop", new GameStopEvent(this));
      this.browser.pause();
      this.clock.stop();
      this._garbageCollector.stop();
      this._logger.debug("Game stopped");
    }
  }
  /**
   * Returns the Engine's running status, Useful for checking whether engine is running or paused.
   */
  isRunning() {
    return this.clock.isRunning();
  }
  /**
   * Takes a screen shot of the current viewport and returns it as an
   * HTML Image Element.
   * @param preserveHiDPIResolution in the case of HiDPI return the full scaled backing image, by default false
   */
  screenshot(preserveHiDPIResolution = false) {
    const screenShotPromise = new Promise((resolve) => {
      this._screenShotRequests.push({ preserveHiDPIResolution, resolve });
    });
    return screenShotPromise;
  }
  _checkForScreenShots() {
    for (const request of this._screenShotRequests) {
      const finalWidth = request.preserveHiDPIResolution ? this.canvas.width : this.screen.resolution.width;
      const finalHeight = request.preserveHiDPIResolution ? this.canvas.height : this.screen.resolution.height;
      const screenshot = document.createElement("canvas");
      screenshot.width = finalWidth;
      screenshot.height = finalHeight;
      const ctx = screenshot.getContext("2d");
      ctx.imageSmoothingEnabled = this.screen.antialiasing;
      ctx.drawImage(this.canvas, 0, 0, finalWidth, finalHeight);
      const result = new Image();
      const raw = screenshot.toDataURL("image/png");
      result.onload = () => {
        request.resolve(result);
      };
      result.src = raw;
    }
    this._screenShotRequests.length = 0;
  }
  /**
   * Another option available to you to load resources into the game.
   * Immediately after calling this the game will pause and the loading screen
   * will appear.
   * @param loader  Some {@apilink Loadable} such as a {@apilink Loader} collection, {@apilink Sound}, or {@apilink Texture}.
   */
  async load(loader, hideLoader = false) {
    await this.scope(async () => {
      try {
        if (loader.isLoaded()) {
          return;
        }
        this._loader = loader;
        this._isLoading = true;
        this._hideLoader = hideLoader;
        if (loader instanceof Loader) {
          loader.suppressPlayButton = loader.suppressPlayButton || this._suppressPlayButton;
        }
        this._loader.onInitialize(this);
        await loader.load();
      } catch (e) {
        this._logger.error("Error loading resources, things may not behave properly", e);
        await Promise.resolve();
      } finally {
        this._isLoading = false;
        this._hideLoader = false;
        this._loader = null;
      }
    });
  }
};
_Engine.Context = createContext();
_Engine.InstanceCount = 0;
_Engine._DEFAULT_ENGINE_OPTIONS = {
  width: 0,
  height: 0,
  enableCanvasTransparency: true,
  useDrawSorting: true,
  configurePerformanceCanvas2DFallback: {
    allow: false,
    showPlayerMessage: false,
    threshold: { fps: 20, numberOfFrames: 100 }
  },
  canvasElementId: "",
  canvasElement: void 0,
  enableCanvasContextMenu: false,
  snapToPixel: false,
  antialiasing: true,
  pixelArt: false,
  garbageCollection: true,
  powerPreference: "high-performance",
  pointerScope: PointerScope.Canvas,
  suppressConsoleBootMessage: null,
  suppressMinimumBrowserFeatureDetection: null,
  suppressHiDPIScaling: null,
  suppressPlayButton: null,
  grabWindowFocus: true,
  scrollPreventionMode: 1,
  backgroundColor: Color.fromHex("#2185d0")
  // Excalibur blue
};
let Engine = _Engine;
class Label extends Actor {
  /**
   * Build a new label
   * @param options
   */
  constructor(options) {
    super(options);
    this._font = new Font();
    this._text = new Text({ text: "", font: this._font });
    const { text, pos, x, y, spriteFont, font, color, maxWidth } = { text: "", ...options };
    this.pos = pos != null ? pos : x && y ? vec(x, y) : this.pos;
    this.text = text != null ? text : this.text;
    this.font = font != null ? font : this.font;
    this.maxWidth = maxWidth != null ? maxWidth : this.maxWidth;
    this.spriteFont = spriteFont != null ? spriteFont : this.spriteFont;
    this._text.color = color != null ? color : this.color;
    const gfx = this.get(GraphicsComponent);
    gfx.anchor = Vector.Zero;
    gfx.use(this._text);
  }
  set maxWidth(width) {
    this._text.maxWidth = width;
  }
  get maxWidth() {
    return this._text.maxWidth;
  }
  get font() {
    return this._font;
  }
  set font(newFont) {
    this._font = newFont;
    this._text.font = newFont;
  }
  /**
   * The text to draw.
   */
  get text() {
    return this._text.text;
  }
  set text(text) {
    this._text.text = text;
  }
  get color() {
    return this._text.color;
  }
  set color(color) {
    if (this._text) {
      this._text.color = color;
    }
  }
  get opacity() {
    return this.graphics.opacity;
  }
  set opacity(opacity) {
    this.graphics.opacity = opacity;
  }
  /**
   * The {@apilink SpriteFont} to use, if any. Overrides {@apilink Font | `font`} if present.
   */
  get spriteFont() {
    return this._spriteFont;
  }
  set spriteFont(sf) {
    if (sf) {
      this._spriteFont = sf;
      this._text.font = this._spriteFont;
    }
  }
  _initialize(engine) {
    super._initialize(engine);
  }
  /**
   * Returns the width of the text in the label (in pixels);
   */
  getTextWidth() {
    return this._text.width;
  }
}
var EmitterType = /* @__PURE__ */ ((EmitterType2) => {
  EmitterType2["Circle"] = "circle";
  EmitterType2["Rectangle"] = "rectangle";
  return EmitterType2;
})(EmitterType || {});
class ParticleEmitter extends Actor {
  /**
   * @param config particle emitter options bag
   */
  constructor(config) {
    var _a, _b;
    super({ width: (_a = config.width) != null ? _a : 0, height: (_b = config.height) != null ? _b : 0 });
    this._particlesToEmit = 0;
    this._particlePool = new RentalPool(
      () => new Particle({}),
      (p) => p,
      500
    );
    this.numParticles = 0;
    this.isEmitting = true;
    this.deadParticles = [];
    this.emitRate = 1;
    this.emitterType = EmitterType.Rectangle;
    this.radius = 0;
    this.particle = {
      /**
       * Gets or sets the life of each particle in milliseconds
       */
      life: 2e3,
      transform: ParticleTransform.Global,
      graphic: void 0,
      opacity: 1,
      angularVelocity: 0,
      focus: void 0,
      focusAccel: void 0,
      randomRotation: false
    };
    this._activeParticles = [];
    const { particle, x, y, z, pos, isEmitting, emitRate, emitterType, radius, random } = { ...config };
    this.particle = { ...this.particle, ...particle };
    this.pos = pos != null ? pos : vec(x != null ? x : 0, y != null ? y : 0);
    this.z = z != null ? z : 0;
    this.isEmitting = isEmitting != null ? isEmitting : this.isEmitting;
    this.emitRate = emitRate != null ? emitRate : this.emitRate;
    this.emitterType = emitterType != null ? emitterType : this.emitterType;
    this.radius = radius != null ? radius : this.radius;
    this.body.collisionType = CollisionType.PreventCollision;
    this.random = random != null ? random : new Random();
  }
  removeParticle(particle) {
    this.deadParticles.push(particle);
  }
  /**
   * Causes the emitter to emit particles
   * @param particleCount  Number of particles to emit right now
   */
  emitParticles(particleCount) {
    var _a;
    if (particleCount <= 0) {
      return;
    }
    particleCount = particleCount | 0;
    for (let i = 0; i < particleCount; i++) {
      const p = this._createParticle();
      if ((_a = this == null ? void 0 : this.scene) == null ? void 0 : _a.world) {
        if (this.particle.transform === ParticleTransform.Global) {
          this.scene.world.add(p);
        } else {
          this.addChild(p);
        }
      }
      this._activeParticles.push(p);
    }
  }
  clearParticles() {
    for (let i = 0; i < this._activeParticles.length; i++) {
      this.removeParticle(this._activeParticles[i]);
    }
  }
  // Creates a new particle given the constraints of the emitter
  _createParticle() {
    let ranX = 0;
    let ranY = 0;
    const angle = randomInRange(this.particle.minAngle || 0, this.particle.maxAngle || Math.PI * 2, this.random);
    const vel = randomInRange(this.particle.minSpeed || 0, this.particle.maxSpeed || 0, this.random);
    const size = this.particle.startSize || randomInRange(this.particle.minSize || 5, this.particle.maxSize || 5, this.random);
    const dx = vel * Math.cos(angle);
    const dy = vel * Math.sin(angle);
    if (this.emitterType === EmitterType.Rectangle) {
      ranX = randomInRange(0, this.width, this.random);
      ranY = randomInRange(0, this.height, this.random);
    } else if (this.emitterType === EmitterType.Circle) {
      const radius = randomInRange(0, this.radius, this.random);
      ranX = radius * Math.cos(angle);
      ranY = radius * Math.sin(angle);
    }
    const p = this._particlePool.rent();
    p.unparent();
    p.configure({
      transform: this.particle.transform,
      life: this.particle.life,
      opacity: this.particle.opacity,
      beginColor: this.particle.beginColor,
      endColor: this.particle.endColor,
      pos: vec(ranX, ranY),
      z: this.particle.transform === ParticleTransform.Global ? this.z : void 0,
      vel: vec(dx, dy),
      acc: this.particle.acc,
      angularVelocity: this.particle.angularVelocity,
      startSize: this.particle.startSize,
      endSize: this.particle.endSize,
      size,
      graphic: this.particle.graphic,
      fade: this.particle.fade
    });
    p.registerEmitter(this);
    if (this.particle.randomRotation) {
      p.transform.rotation = randomInRange(0, Math.PI * 2, this.random);
    }
    if (this.particle.focus) {
      p.focus = this.particle.focus.add(vec(this.pos.x, this.pos.y));
      p.focusAccel = this.particle.focusAccel;
    }
    return p;
  }
  update(engine, elapsed) {
    var _a;
    super.update(engine, elapsed);
    if (this.isEmitting) {
      this._particlesToEmit += this.emitRate * (elapsed / 1e3);
      if (this._particlesToEmit > 1) {
        this.emitParticles(Math.floor(this._particlesToEmit));
        this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
      }
    }
    for (let i = 0; i < this.deadParticles.length; i++) {
      if ((_a = this == null ? void 0 : this.scene) == null ? void 0 : _a.world) {
        this.scene.world.remove(this.deadParticles[i], false);
        this._particlePool.return(this.deadParticles[i]);
      }
      const index = this._activeParticles.indexOf(this.deadParticles[i]);
      if (index > -1) {
        this._activeParticles.splice(index, 1);
      }
    }
    this.deadParticles.length = 0;
  }
}
function assert(message, expression) {
  {
    if (!expression()) {
      throw new Error(message);
    }
  }
}
class GpuParticleRenderer {
  constructor(emitter, random, options) {
    this.emitRate = 1;
    this._initialized = false;
    this._vaos = [];
    this._buffers = [];
    this._drawIndex = 0;
    this._numInputFloats = 2 + 2 + 1 + 1 + 1;
    this._particleIndex = 0;
    this._uploadIndex = 0;
    this._wrappedLife = 0;
    this._wrappedParticles = 0;
    this._particleLife = 0;
    this._clearRequested = false;
    this._emitted = [];
    var _a;
    this.emitter = emitter;
    this.particle = options;
    this._particleData = new Float32Array(this.emitter.maxParticles * this._numInputFloats);
    this._random = random;
    this._particleLife = (_a = this.particle.life) != null ? _a : 2e3;
  }
  get isInitialized() {
    return this._initialized;
  }
  get maxParticles() {
    return this.emitter.maxParticles;
  }
  initialize(gl, context) {
    if (this._initialized) {
      return;
    }
    const numParticles = this.emitter.maxParticles;
    const numInputFloats = this._numInputFloats;
    const particleData = this._particleData;
    const bytesPerFloat = 4;
    const particleDataBuffer1 = gl.createBuffer();
    const vao1 = gl.createVertexArray();
    gl.bindVertexArray(vao1);
    gl.bindBuffer(gl.ARRAY_BUFFER, particleDataBuffer1);
    gl.bufferData(gl.ARRAY_BUFFER, numParticles * numInputFloats * bytesPerFloat, gl.DYNAMIC_DRAW);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, particleData);
    let offset = 0;
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, numInputFloats * bytesPerFloat, 0);
    offset += bytesPerFloat * 2;
    gl.vertexAttribPointer(1, 2, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
    offset += bytesPerFloat * 2;
    gl.vertexAttribPointer(2, 1, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
    offset += bytesPerFloat * 1;
    gl.vertexAttribPointer(3, 1, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
    offset += bytesPerFloat * 1;
    gl.vertexAttribPointer(4, 1, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
    offset += bytesPerFloat * 1;
    gl.enableVertexAttribArray(0);
    gl.enableVertexAttribArray(1);
    gl.enableVertexAttribArray(2);
    gl.enableVertexAttribArray(3);
    gl.enableVertexAttribArray(4);
    this._vaos.push(vao1);
    this._buffers.push(particleDataBuffer1);
    gl.bindVertexArray(null);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    const particleDataBuffer2 = gl.createBuffer();
    const vao2 = gl.createVertexArray();
    gl.bindVertexArray(vao2);
    gl.bindBuffer(gl.ARRAY_BUFFER, particleDataBuffer2);
    gl.bufferData(gl.ARRAY_BUFFER, numParticles * numInputFloats * bytesPerFloat, gl.DYNAMIC_DRAW);
    offset = 0;
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, numInputFloats * bytesPerFloat, 0);
    offset += bytesPerFloat * 2;
    gl.vertexAttribPointer(1, 2, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
    offset += bytesPerFloat * 2;
    gl.vertexAttribPointer(2, 1, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
    offset += bytesPerFloat * 1;
    gl.vertexAttribPointer(3, 1, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
    offset += bytesPerFloat * 1;
    gl.vertexAttribPointer(4, 1, gl.FLOAT, false, numInputFloats * bytesPerFloat, offset);
    offset += bytesPerFloat * 1;
    gl.enableVertexAttribArray(0);
    gl.enableVertexAttribArray(1);
    gl.enableVertexAttribArray(2);
    gl.enableVertexAttribArray(3);
    gl.enableVertexAttribArray(4);
    this._vaos.push(vao2);
    this._buffers.push(particleDataBuffer2);
    gl.bindVertexArray(null);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    this._currentVao = this._vaos[this._drawIndex % 2];
    this._currentBuffer = this._buffers[(this._drawIndex + 1) % 2];
    this._initialized = true;
  }
  clearParticles() {
    this._particleData.fill(0);
    this._clearRequested = true;
  }
  emitParticles(particleCount) {
    const startIndex = this._particleIndex;
    const maxSize = this.maxParticles * this._numInputFloats;
    const endIndex = particleCount * this._numInputFloats + startIndex;
    for (let i = startIndex; i < endIndex; i += this._numInputFloats) {
      let angle = this._random.floating(this.particle.minAngle || 0, this.particle.maxAngle || TwoPI);
      angle += this.particle.transform === ParticleTransform.Local ? this.emitter.transform.rotation : this.emitter.transform.globalRotation;
      const speedX = this._random.floating(this.particle.minSpeed || 0, this.particle.maxSpeed || 0);
      const speedY = this._random.floating(this.particle.minSpeed || 0, this.particle.maxSpeed || 0);
      const dx = speedX * Math.cos(angle);
      const dy = speedY * Math.sin(angle);
      let ranX = 0;
      let ranY = 0;
      if (this.emitter.emitterType === EmitterType.Rectangle) {
        ranX = this._random.floating(-0.5, 0.5) * this.emitter.width;
        ranY = this._random.floating(-0.5, 0.5) * this.emitter.height;
      } else {
        const radius = this._random.floating(0, this.emitter.radius);
        ranX = radius * Math.cos(angle);
        ranY = radius * Math.sin(angle);
      }
      const tx = this.emitter.transform.apply(vec(ranX, ranY));
      const data = [
        this.particle.transform === ParticleTransform.Local ? ranX : tx.x,
        this.particle.transform === ParticleTransform.Local ? ranY : tx.y,
        // pos in world space
        dx,
        dy,
        // velocity
        this.particle.randomRotation ? randomInRange(0, TwoPI, this._random) : this.particle.rotation || 0,
        // rotation
        this.particle.angularVelocity || 0,
        // angular velocity
        this._particleLife
        // life
      ];
      this._particleData.set(data, i % this._particleData.length);
    }
    if (endIndex >= maxSize) {
      this._wrappedParticles += (endIndex - maxSize) / this._numInputFloats;
      this._wrappedLife = this._particleLife;
    } else if (this._wrappedLife > 0) {
      this._wrappedParticles += particleCount;
    }
    this._particleIndex = endIndex % maxSize;
    this._emitted.push([this._particleLife, startIndex]);
  }
  _uploadEmitted(gl) {
    if (this._particleIndex !== this._uploadIndex) {
      gl.bindBuffer(gl.ARRAY_BUFFER, this._buffers[(this._drawIndex + 1) % 2]);
      if (this._particleIndex >= this._uploadIndex) {
        gl.bufferSubData(
          gl.ARRAY_BUFFER,
          this._uploadIndex * 4,
          // dst byte offset 4 bytes per float
          this._particleData,
          this._uploadIndex,
          this._particleIndex - this._uploadIndex
        );
      } else {
        gl.bufferSubData(
          gl.ARRAY_BUFFER,
          this._uploadIndex * 4,
          this._particleData,
          this._uploadIndex,
          this._particleData.length - this._uploadIndex
        );
        if (this._wrappedParticles) {
          gl.bufferSubData(
            gl.ARRAY_BUFFER,
            0,
            this._particleData,
            0,
            this._wrappedParticles * this._numInputFloats
          );
        }
        this._wrappedLife = this._particleLife;
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    this._uploadIndex = this._particleIndex % (this.maxParticles * this._numInputFloats);
  }
  update(elapsed) {
    var _a;
    this._particleLife = (_a = this.particle.life) != null ? _a : this._particleLife;
    if (this._wrappedLife > 0) {
      this._wrappedLife -= elapsed;
    } else {
      this._wrappedLife = 0;
      this._wrappedParticles = 0;
    }
    if (!this._emitted.length) {
      return;
    }
    for (let i = this._emitted.length - 1; i >= 0; i--) {
      const particle = this._emitted[i];
      particle[0] -= elapsed;
      const life = particle[0];
      if (life <= 0) {
        this._emitted.splice(i, 1);
      }
    }
    this._emitted.sort((a, b) => a[0] - b[0]);
  }
  draw(gl) {
    if (this._initialized) {
      if (this._clearRequested) {
        gl.bindBuffer(gl.ARRAY_BUFFER, this._buffers[(this._drawIndex + 1) % 2]);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._particleData);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        this._clearRequested = false;
      } else {
        this._uploadEmitted(gl);
      }
      gl.bindVertexArray(this._currentVao);
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this._currentBuffer);
      if (this._wrappedLife && this._emitted[0] && this._emitted[0][1] > 0) {
        const midpoint = this._emitted[0][1] / this._numInputFloats;
        assert(`midpoint greater than 0, actual: ${midpoint}`, () => midpoint > 0);
        assert(`midpoint is less than max, actual: ${midpoint}`, () => midpoint < this.maxParticles);
        gl.bindBufferRange(
          gl.TRANSFORM_FEEDBACK_BUFFER,
          0,
          this._currentBuffer,
          this._emitted[0][1] * 4,
          (this.maxParticles - midpoint) * this._numInputFloats * 4
        );
        gl.beginTransformFeedback(gl.POINTS);
        gl.drawArrays(gl.POINTS, midpoint, this.maxParticles - midpoint);
        gl.endTransformFeedback();
        gl.bindBufferRange(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this._currentBuffer, 0, this._emitted[0][1] * 4);
        gl.beginTransformFeedback(gl.POINTS);
        gl.drawArrays(gl.POINTS, 0, midpoint);
        gl.endTransformFeedback();
      } else {
        gl.bindBufferRange(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this._currentBuffer, 0, this._particleData.length * 4);
        gl.beginTransformFeedback(gl.POINTS);
        gl.drawArrays(gl.POINTS, 0, this.maxParticles);
        gl.endTransformFeedback();
      }
      gl.bindVertexArray(null);
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
      this._currentVao = this._vaos[this._drawIndex % 2];
      this._currentBuffer = this._buffers[(this._drawIndex + 1) % 2];
      this._drawIndex = (this._drawIndex + 1) % 2;
    }
  }
}
GpuParticleRenderer.GPU_MAX_PARTICLES = 1e5;
class GpuParticleEmitter extends Actor {
  constructor(config) {
    super({ name: `GpuParticleEmitter`, width: config.width, height: config.height });
    this.particle = {
      /**
       * Gets or sets the life of each particle in milliseconds
       */
      life: 2e3,
      transform: ParticleTransform.Global,
      graphic: void 0,
      opacity: 1,
      angularVelocity: 0,
      focus: void 0,
      focusAccel: void 0,
      randomRotation: false
    };
    this.graphics = new GraphicsComponent();
    this.isEmitting = false;
    this.emitRate = 1;
    this.emitterType = EmitterType.Rectangle;
    this.radius = 0;
    this.maxParticles = 2e3;
    this._particlesToEmit = 0;
    this.addComponent(this.graphics, true);
    this.graphics.onPostDraw = this.draw.bind(this);
    const { particle, maxParticles, x, y, z, pos, isEmitting, emitRate, emitterType, radius, random } = { ...config };
    this.maxParticles = clamp(maxParticles != null ? maxParticles : this.maxParticles, 0, GpuParticleRenderer.GPU_MAX_PARTICLES);
    this.pos = pos != null ? pos : vec(x != null ? x : 0, y != null ? y : 0);
    this.z = z != null ? z : 0;
    this.isEmitting = isEmitting != null ? isEmitting : this.isEmitting;
    this.emitRate = emitRate != null ? emitRate : this.emitRate;
    this.emitterType = emitterType != null ? emitterType : this.emitterType;
    this.radius = radius != null ? radius : this.radius;
    this.particle = { ...this.particle, ...particle };
    this.random = random != null ? random : new Random();
    this.renderer = new GpuParticleRenderer(this, this.random, this.particle);
  }
  get pos() {
    return this.transform.pos;
  }
  set pos(pos) {
    this.transform.pos = pos;
  }
  get z() {
    return this.transform.z;
  }
  set z(z) {
    this.transform.z = z;
  }
  _initialize(engine) {
    super._initialize(engine);
    const context = engine.graphicsContext;
    this.renderer.initialize(context.__gl, context);
  }
  update(engine, elapsed) {
    super.update(engine, elapsed);
    if (this.isEmitting) {
      this._particlesToEmit += this.emitRate * (elapsed / 1e3);
      if (this._particlesToEmit > 1) {
        this.emitParticles(Math.floor(this._particlesToEmit));
        this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
      }
    }
    this.renderer.update(elapsed);
  }
  emitParticles(particleCount) {
    if (particleCount <= 0) {
      return;
    }
    this.renderer.emitParticles(particleCount | 0);
  }
  clearParticles() {
    this.renderer.clearParticles();
  }
  draw(ctx, elapsed) {
    ctx.draw("ex.particle", this.renderer, elapsed);
  }
}
class ActionSequence {
  constructor(entity, actionBuilder) {
    this.id = nextActionId();
    this._stopped = false;
    this._sequenceBuilder = actionBuilder;
    this._sequenceContext = new ActionContext(entity);
    this._actionQueue = this._sequenceContext.getQueue();
    this._sequenceBuilder(this._sequenceContext);
  }
  update(elapsed) {
    this._actionQueue.update(elapsed);
  }
  isComplete() {
    return this._stopped || this._actionQueue.isComplete();
  }
  stop() {
    this._stopped = true;
  }
  reset() {
    this._stopped = false;
    this._actionQueue.reset();
  }
  clone(entity) {
    return new ActionSequence(entity, this._sequenceBuilder);
  }
}
class ParallelActions {
  constructor(parallelActions) {
    this.id = nextActionId();
    this._actions = parallelActions;
  }
  update(elapsed) {
    for (let i = 0; i < this._actions.length; i++) {
      this._actions[i].update(elapsed);
    }
  }
  isComplete(entity) {
    return this._actions.every((a) => a.isComplete(entity));
  }
  reset() {
    this._actions.forEach((a) => a.reset());
  }
  stop() {
    this._actions.forEach((a) => a.stop());
  }
}
function has_initialize(a) {
  return !!a._initialize;
}
function has_add(a) {
  return !!a.onAdd;
}
function has_remove(a) {
  return !!a.onRemove;
}
function hasOnInitialize(a) {
  return !!a.onInitialize;
}
function has_preupdate(a) {
  return !!a._preupdate;
}
function hasOnPreUpdate(a) {
  return !!a.onPreUpdate;
}
function has_postupdate(a) {
  return !!a.onPostUpdate;
}
function hasOnPostUpdate(a) {
  return !!a.onPostUpdate;
}
function hasOnAdd(a) {
  return !!a.onAdd;
}
function hasOnRemove(a) {
  return !!a.onRemove;
}
function hasPreDraw(a) {
  return !!a.onPreDraw;
}
function hasPostDraw(a) {
  return !!a.onPostDraw;
}
class ChannelCollection {
  constructor(options, soundManager) {
    this.soundManager = soundManager;
  }
  stop(name) {
    if (!name) {
      return;
    }
    const sounds = this.soundManager.getSoundsForChannel(name);
    for (let i = 0; i < sounds.length; i++) {
      sounds[i].stop();
    }
  }
  setVolume(name, volume) {
    const sounds = this.soundManager.getSoundsForChannel(name);
    for (const sound of sounds) {
      if (this.soundManager._isMuted(sound)) {
        continue;
      }
      this.soundManager.setVolume(name, volume);
    }
  }
  play(name, volume) {
    volume != null ? volume : volume = this.soundManager.defaultVolume;
    const playing = [];
    const playedAudio = /* @__PURE__ */ new Set();
    const sounds = this.soundManager.getSoundsForChannel(name);
    for (const sound of sounds) {
      if (playedAudio.has(sound) || this.soundManager._isMuted(sound)) {
        continue;
      }
      const mixVolume = this.soundManager._getEffectiveVolume(sound);
      playing.push(sound.play(mixVolume * volume));
      playedAudio.add(sound);
    }
    return Promise.all(playing);
  }
  mute(name) {
    const sounds = this.soundManager.getSoundsForChannel(name);
    for (let i = 0; i < sounds.length; i++) {
      this.soundManager._muted.add(sounds[i]);
      sounds[i].pause();
    }
  }
  unmute(name) {
    const sounds = this.soundManager.getSoundsForChannel(name);
    for (let i = 0; i < sounds.length; i++) {
      if (this.soundManager._muted.has(sounds[i])) {
        sounds[i].play();
        this.soundManager._muted.delete(sounds[i]);
      }
    }
  }
  toggle(name) {
    const sounds = this.soundManager.getSoundsForChannel(name);
    for (let i = 0; i < sounds.length; i++) {
      if (this.soundManager._isMuted(sounds[i])) {
        sounds[i].play();
        this.soundManager._muted.delete(sounds[i]);
      } else {
        this.soundManager._muted.add(sounds[i]);
        sounds[i].pause();
      }
    }
  }
}
class SoundManager {
  constructor(options) {
    this._channelToConfig = /* @__PURE__ */ new Map();
    this._nameToConfig = /* @__PURE__ */ new Map();
    this._mix = /* @__PURE__ */ new Map();
    this._muted = /* @__PURE__ */ new Set();
    this._all = /* @__PURE__ */ new Set();
    this._defaultVolume = 1;
    var _a;
    this._defaultVolume = (_a = options.volume) != null ? _a : 1;
    this.channel = new ChannelCollection(options, this);
    if (options.sounds) {
      for (const [name, soundOrConfig] of Object.entries(options.sounds)) {
        this.track(name, soundOrConfig);
      }
    }
  }
  set defaultVolume(volume) {
    this._defaultVolume = clamp(volume, 0, 1);
  }
  get defaultVolume() {
    return this._defaultVolume;
  }
  getSounds() {
    return Array.from(this._all);
  }
  getSoundsForChannel(channel) {
    const config = this._channelToConfig.get(channel);
    if (config) {
      return config.sounds;
    }
    return [];
  }
  _isMuted(sound) {
    return this._muted.has(sound);
  }
  _getEffectiveVolume(sound) {
    var _a;
    if (this._isMuted(sound)) {
      return 0;
    }
    let mix = this._defaultVolume;
    if (this._mix.has(sound)) {
      mix *= (_a = this._mix.get(sound)) != null ? _a : this._defaultVolume;
    }
    return mix;
  }
  play(soundName, volume = this._defaultVolume) {
    const soundSound = this._nameToConfig.get(soundName);
    if (!soundSound) {
      return Promise.resolve();
    }
    const { sound } = soundSound;
    if (this._isMuted(sound)) {
      return Promise.resolve();
    }
    const effectiveVolume = volume * this._getEffectiveVolume(sound);
    return sound.play(effectiveVolume);
  }
  getSound(soundName) {
    const soundSound = this._nameToConfig.get(soundName);
    if (!soundSound) {
      return void 0;
    }
    const { sound } = soundSound;
    return sound;
  }
  setVolume(soundname, volume = this._defaultVolume) {
    const soundSound = this._nameToConfig.get(soundname);
    if (!soundSound) {
      return;
    }
    const { sound } = soundSound;
    this._setMix(sound, volume);
    return;
  }
  /**
   * Gets the volumn for a sound
   */
  getVolume(soundName) {
    var _a;
    const sound = this.getSound(soundName);
    if (!sound) {
      return 0;
    }
    return (_a = this._mix.get(sound)) != null ? _a : 0;
  }
  /**
   * Set the maximum volume a sound, if not set assumed to be 1.0 (100% of the source volume)
   */
  _setMix(sound, volume) {
    this._mix.set(sound, volume);
    sound.volume = volume;
  }
  track(name, soundOrConfig) {
    let sound;
    let volume;
    let channels;
    if (soundOrConfig instanceof Sound) {
      sound = soundOrConfig;
      volume = this._defaultVolume;
      channels = [];
    } else {
      ({ sound, volume, channels } = soundOrConfig);
    }
    this._nameToConfig.set(name, { sound, volume, channels });
    this._mix.set(sound, volume != null ? volume : this._defaultVolume);
    this._all.add(sound);
    if (channels) {
      this.addChannel(name, channels);
    }
  }
  /**
   * Remove the maximum volume for a sound, will be 100% of the source volume
   *
   * Untracks the Sound in the sound manager
   */
  untrack(soundName) {
    this._nameToConfig.delete(soundName);
    const sound = this.getSound(soundName);
    if (!sound) {
      return;
    }
    this._mix.delete(sound);
    this._all.delete(sound);
  }
  stop(name) {
    if (name) {
      const soundSound = this._nameToConfig.get(name);
      if (!soundSound) {
        return;
      }
      const { sound } = soundSound;
      sound.stop();
      return;
    }
    this._all.forEach((s) => s.stop());
  }
  mute(name) {
    if (name) {
      const soundSound = this._nameToConfig.get(name);
      if (!soundSound) {
        return;
      }
      const { sound } = soundSound;
      this._muted.add(sound);
      sound.pause();
      return;
    }
    this._muted = new Set(this._all);
    this._muted.forEach((s) => s.pause());
  }
  unmute(name) {
    if (name) {
      const soundSound = this._nameToConfig.get(name);
      if (!soundSound) {
        return;
      }
      const { sound } = soundSound;
      sound.play();
      this._muted.delete(sound);
      return;
    }
    this._muted.forEach((s) => s.play());
    this._muted.clear();
  }
  toggle(name) {
    if (name) {
      const soundSound = this._nameToConfig.get(name);
      if (!soundSound) {
        return;
      }
      const { sound } = soundSound;
      if (this._isMuted(sound)) {
        this.unmute(name);
      } else {
        this.mute(name);
      }
      return;
    }
    if (this._muted.size > 0) {
      this._muted.forEach((s) => s.play());
      this._muted.clear();
    } else {
      this._muted = new Set(this._all);
      this._muted.forEach((s) => s.pause());
    }
  }
  /**
   * Apply a list of channels to a sound instance
   */
  addChannel(soundName, channels) {
    const sound = this.getSound(soundName);
    if (!sound) {
      return;
    }
    const currentVolume = this._mix.get(sound);
    this._mix.set(sound, currentVolume != null ? currentVolume : this._defaultVolume);
    this._all.add(sound);
    for (const channel of channels) {
      let maybeConfiguration = this._channelToConfig.get(channel);
      if (!maybeConfiguration) {
        maybeConfiguration = {
          sounds: [sound]
        };
      }
      if (maybeConfiguration.sounds.indexOf(sound) === -1) {
        maybeConfiguration.sounds.push(sound);
      }
      this._channelToConfig.set(channel, maybeConfiguration);
    }
  }
  removeChannel(soundName, channels) {
    const sound = this.getSound(soundName);
    if (!sound) {
      return;
    }
    for (const channel of channels) {
      const maybeConfiguration = this._channelToConfig.get(channel);
      if (!maybeConfiguration) {
        return;
      }
      const index = maybeConfiguration.sounds.indexOf(sound);
      if (index >= -1) {
        maybeConfiguration.sounds.splice(index, 1);
      }
      this._channelToConfig.set(channel, maybeConfiguration);
    }
  }
}
class Gif {
  /**
   * @param path       Path to the image resource
   * @param bustCache  Optionally load texture with cache busting
   */
  constructor(path, bustCache = false) {
    this.path = path;
    this.width = 0;
    this.height = 0;
    this._images = [];
    this.data = [];
    this._sprites = [];
    this._resource = new Resource(path, "arraybuffer", bustCache);
  }
  /**
   * Should excalibur add a cache busting querystring? By default false.
   * Must be set before loading
   */
  get bustCache() {
    return this._resource.bustCache;
  }
  set bustCache(val) {
    this._resource.bustCache = val;
  }
  /**
   * Begins loading the texture and returns a promise to be resolved on completion
   */
  async load() {
    const arraybuffer = await this._resource.load();
    this._stream = new Stream(arraybuffer);
    this._gif = new GifParser(this._stream);
    const images = this._gif.images.map((i) => new ImageSource(i.src, false));
    await Promise.all(images.map((t) => t.load()));
    this.data = this._images = images;
    this._sprites = this._images.map((image) => {
      return image.toSprite();
    });
    return this.data;
  }
  isLoaded() {
    return !!this.data;
  }
  /**
   * Return a frame of the gif as a sprite by id
   * @param id
   */
  toSprite(id = 0) {
    var _a;
    return (_a = this._sprites[id]) != null ? _a : null;
  }
  /**
   * Return the gif as a spritesheet
   */
  toSpriteSheet() {
    const sprites = this._sprites;
    if (sprites.length) {
      return new SpriteSheet({ sprites });
    }
    return null;
  }
  /**
   * Transform the GIF into an animation with duration per frame
   * @param durationPerFrame Optionally override duration per frame
   */
  toAnimation(durationPerFrame) {
    var _a;
    const images = (_a = this._gif) == null ? void 0 : _a.images;
    if (images == null ? void 0 : images.length) {
      const frames = images.map((image, index) => {
        var _a2;
        return {
          graphic: this._sprites[index],
          duration: ((_a2 = this._gif) == null ? void 0 : _a2.frames[index].delayMs) || void 0
        };
      });
      this._animation = new Animation({
        frames,
        frameDuration: durationPerFrame
      });
      return this._animation;
    }
    return null;
  }
  get readCheckBytes() {
    var _a, _b;
    return (_b = (_a = this._gif) == null ? void 0 : _a.checkBytes) != null ? _b : [];
  }
}
const bitsToNum = (ba) => {
  return ba.reduce(function(s, n) {
    return s * 2 + n;
  }, 0);
};
const byteToBitArr = (bite) => {
  const a = [];
  for (let i = 7; i >= 0; i--) {
    a.push(!!(bite & 1 << i));
  }
  return a;
};
class Stream {
  constructor(dataArray) {
    this.len = 0;
    this.position = 0;
    this.readByte = () => {
      if (this.position >= this.data.byteLength) {
        throw new Error("Attempted to read past end of stream.");
      }
      return this.data[this.position++];
    };
    this.readBytes = (n) => {
      const bytes = [];
      for (let i = 0; i < n; i++) {
        bytes.push(this.readByte());
      }
      return bytes;
    };
    this.read = (n) => {
      let s = "";
      for (let i = 0; i < n; i++) {
        s += String.fromCharCode(this.readByte());
      }
      return s;
    };
    this.readUnsigned = () => {
      const a = this.readBytes(2);
      return (a[1] << 8) + a[0];
    };
    this.data = new Uint8Array(dataArray);
    this.len = this.data.byteLength;
    if (this.len === 0) {
      throw new Error("No data loaded from file");
    }
  }
}
const lzwDecode = function(minCodeSize, data) {
  let pos = 0;
  const readCode = function(size) {
    let code2 = 0;
    for (let i = 0; i < size; i++) {
      if (data.charCodeAt(pos >> 3) & 1 << (pos & 7)) {
        code2 |= 1 << i;
      }
      pos++;
    }
    return code2;
  };
  const output = [];
  const clearCode = 1 << minCodeSize;
  const eoiCode = clearCode + 1;
  let codeSize = minCodeSize + 1;
  let dict = [];
  const clear = function() {
    dict = [];
    codeSize = minCodeSize + 1;
    for (let i = 0; i < clearCode; i++) {
      dict[i] = [i];
    }
    dict[clearCode] = [];
    dict[eoiCode] = null;
  };
  let code = 0;
  let last = 0;
  while (true) {
    last = code;
    code = readCode(codeSize);
    if (code === clearCode) {
      clear();
      continue;
    }
    if (code === eoiCode) {
      break;
    }
    if (code < dict.length) {
      if (last !== clearCode) {
        dict.push(dict[last].concat(dict[code][0]));
      }
    } else {
      if (code !== dict.length) {
        throw new Error("Invalid LZW code.");
      }
      dict.push(dict[last].concat(dict[last][0]));
    }
    output.push.apply(output, dict[code]);
    if (dict.length === 1 << codeSize && codeSize < 12) {
      codeSize++;
    }
  }
  return output;
};
class GifParser {
  constructor(stream) {
    this._handler = {};
    this.frames = [];
    this.images = [];
    this.globalColorTableBytes = [];
    this.checkBytes = [];
    this.parseColorTableBytes = (entries) => {
      const colorTable = [];
      for (let i = 0; i < entries; i++) {
        const rgb = this._st.readBytes(3);
        colorTable.push(rgb);
      }
      return colorTable;
    };
    this.readSubBlocks = () => {
      let size, data;
      data = "";
      do {
        size = this._st.readByte();
        data += this._st.read(size);
      } while (size !== 0);
      return data;
    };
    this.parseHeader = () => {
      const hdr = {
        sig: "",
        ver: "",
        width: 0,
        height: 0,
        colorResolution: 0,
        globalColorTableSize: 0,
        gctFlag: false,
        sortedFlag: false,
        globalColorTable: [],
        backgroundColorIndex: 0,
        pixelAspectRatio: 0
        // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
      };
      hdr.sig = this._st.read(3);
      hdr.ver = this._st.read(3);
      if (hdr.sig !== "GIF") {
        throw new Error("Not a GIF file.");
      }
      hdr.width = this._st.readUnsigned();
      hdr.height = this._st.readUnsigned();
      this._currentFrameCanvas.width = hdr.width;
      this._currentFrameCanvas.height = hdr.height;
      const bits = byteToBitArr(this._st.readByte());
      hdr.gctFlag = bits.shift();
      hdr.colorResolution = bitsToNum(bits.splice(0, 3));
      hdr.sortedFlag = bits.shift();
      hdr.globalColorTableSize = bitsToNum(bits.splice(0, 3));
      hdr.backgroundColorIndex = this._st.readByte();
      hdr.pixelAspectRatio = this._st.readByte();
      if (hdr.gctFlag) {
        this.globalColorTableBytes = this.parseColorTableBytes(1 << hdr.globalColorTableSize + 1);
      }
      if (this._handler.hdr && this._handler.hdr(hdr)) {
        this.checkBytes.push(this._handler.hdr);
      }
    };
    this.parseExt = (block) => {
      const parseGCExt = (block2) => {
        this.checkBytes.push(this._st.readByte());
        const bits = byteToBitArr(this._st.readByte());
        block2.reserved = bits.splice(0, 3);
        block2.disposalMethod = bitsToNum(bits.splice(0, 3));
        block2.userInputFlag = bits.shift();
        block2.transparentColorFlag = bits.shift();
        block2.delayTime = this._st.readUnsigned();
        block2.transparentColorIndex = this._st.readByte();
        block2.terminator = this._st.readByte();
        if (this._handler.gce && this._handler.gce(block2)) {
          this.checkBytes.push(this._handler.gce);
        }
        return block2;
      };
      const parseComExt = (block2) => {
        block2.comment = this.readSubBlocks();
        if (this._handler.com && this._handler.com(block2)) {
          this.checkBytes.push(this._handler.com);
        }
      };
      const parsePTExt = (block2) => {
        this.checkBytes.push(this._st.readByte());
        block2.ptHeader = this._st.readBytes(12);
        block2.ptData = this.readSubBlocks();
        if (this._handler.pte && this._handler.pte(block2)) {
          this.checkBytes.push(this._handler.pte);
        }
      };
      const parseAppExt = (block2) => {
        const parseNetscapeExt = (block3) => {
          this.checkBytes.push(this._st.readByte());
          block3.unknown = this._st.readByte();
          block3.iterations = this._st.readUnsigned();
          block3.terminator = this._st.readByte();
          if (this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(block3)) {
            this.checkBytes.push(this._handler.app);
          }
        };
        const parseUnknownAppExt = (block3) => {
          block3.appData = this.readSubBlocks();
          if (this._handler.app && this._handler.app[block3.identifier] && this._handler.app[block3.identifier](block3)) {
            this.checkBytes.push(this._handler.app[block3.identifier]);
          }
        };
        this.checkBytes.push(this._st.readByte());
        block2.identifier = this._st.read(8);
        block2.authCode = this._st.read(3);
        switch (block2.identifier) {
          case "NETSCAPE":
            parseNetscapeExt(block2);
            break;
          default:
            parseUnknownAppExt(block2);
            break;
        }
      };
      const parseUnknownExt = (block2) => {
        block2.data = this.readSubBlocks();
        if (this._handler.unknown && this._handler.unknown(block2)) {
          this.checkBytes.push(this._handler.unknown);
        }
      };
      block.label = this._st.readByte();
      switch (block.label) {
        case 249:
          block.extType = "gce";
          this._gce = parseGCExt(block);
          break;
        case 254:
          block.extType = "com";
          parseComExt(block);
          break;
        case 1:
          block.extType = "pte";
          parsePTExt(block);
          break;
        case 255:
          block.extType = "app";
          parseAppExt(block);
          break;
        default:
          block.extType = "unknown";
          parseUnknownExt(block);
          break;
      }
    };
    this.parseImg = (img) => {
      var _a;
      const deinterlace = (pixels, width) => {
        const newPixels = new Array(pixels.length);
        const rows = pixels.length / width;
        const cpRow = (toRow, fromRow2) => {
          const fromPixels = pixels.slice(fromRow2 * width, (fromRow2 + 1) * width);
          newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
        };
        const offsets = [0, 4, 2, 1];
        const steps = [8, 8, 4, 2];
        let fromRow = 0;
        for (let pass = 0; pass < 4; pass++) {
          for (let toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
            cpRow(toRow, fromRow);
            fromRow++;
          }
        }
        return newPixels;
      };
      img.leftPos = this._st.readUnsigned();
      img.topPos = this._st.readUnsigned();
      img.width = this._st.readUnsigned();
      img.height = this._st.readUnsigned();
      const bits = byteToBitArr(this._st.readByte());
      img.lctFlag = bits.shift();
      img.interlaced = bits.shift();
      img.sorted = bits.shift();
      img.reserved = bits.splice(0, 2);
      img.lctSize = bitsToNum(bits.splice(0, 3));
      if (img.lctFlag) {
        img.lctBytes = this.parseColorTableBytes(1 << img.lctSize + 1);
      }
      img.lzwMinCodeSize = this._st.readByte();
      const lzwData = this.readSubBlocks();
      img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);
      if (img.interlaced) {
        img.pixels = deinterlace(img.pixels, img.width);
      }
      if ((_a = this._gce) == null ? void 0 : _a.delayTime) {
        img.delayMs = this._gce.delayTime * 10;
      }
      this.frames.push(img);
      this.arrayToImage(img, img.lctFlag ? img.lctBytes : this.globalColorTableBytes);
      if (this._handler.img && this._handler.img(img)) {
        this.checkBytes.push(this._handler);
      }
    };
    this.parseBlocks = () => {
      const block = {
        sentinel: this._st.readByte(),
        type: ""
      };
      const blockChar = String.fromCharCode(block.sentinel);
      switch (blockChar) {
        case "!":
          block.type = "ext";
          this.parseExt(block);
          break;
        case ",":
          block.type = "img";
          this.parseImg(block);
          break;
        case ";":
          block.type = "eof";
          if (this._handler.eof && this._handler.eof(block)) {
            this.checkBytes.push(this._handler.eof);
          }
          break;
        default:
          throw new Error("Unknown block: 0x" + block.sentinel.toString(16));
      }
      if (block.type !== "eof") {
        this.parseBlocks();
      }
    };
    this.arrayToImage = (frame, colorTable) => {
      var _a, _b, _c, _d;
      const canvas = document.createElement("canvas");
      canvas.width = frame.width;
      canvas.height = frame.height;
      const context = canvas.getContext("2d");
      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
      let transparentColorIndex = -1;
      if ((_a = this._gce) == null ? void 0 : _a.transparentColorFlag) {
        transparentColorIndex = this._gce.transparentColorIndex;
      }
      for (let pixel = 0; pixel < frame.pixels.length; pixel++) {
        const colorIndex = frame.pixels[pixel];
        const color = colorTable[colorIndex];
        if (colorIndex === transparentColorIndex) {
          imageData.data.set([0, 0, 0, 0], pixel * 4);
        } else {
          imageData.data.set([...color, 255], pixel * 4);
        }
      }
      context.putImageData(imageData, 0, 0);
      if (((_b = this._gce) == null ? void 0 : _b.disposalMethod) === 1 && this.images.length) {
        this._currentFrameContext.drawImage(this.images[this.images.length - 1], 0, 0);
      } else if (((_c = this._gce) == null ? void 0 : _c.disposalMethod) === 2 && ((_d = this._hdr) == null ? void 0 : _d.gctFlag)) {
        const bg = colorTable[this._hdr.backgroundColorIndex];
        this._currentFrameContext.fillStyle = `rgb(${bg[0]}, ${bg[1]}, ${bg[2]})`;
        this._currentFrameContext.fillRect(0, 0, this._hdr.width, this._hdr.height);
      } else {
        this._currentFrameContext.clearRect(0, 0, this._currentFrameCanvas.width, this._currentFrameCanvas.height);
      }
      this._currentFrameContext.drawImage(canvas, frame.leftPos, frame.topPos, frame.width, frame.height);
      const img = new Image();
      img.src = this._currentFrameCanvas.toDataURL();
      this.images.push(img);
    };
    this._st = stream;
    this._handler = {};
    this._currentFrameCanvas = document.createElement("canvas");
    this._currentFrameContext = this._currentFrameCanvas.getContext("2d");
    this.parseHeader();
    this.parseBlocks();
  }
}
class FontSource {
  constructor(path, family, { bustCache, ...options } = {}) {
    this.path = path;
    this.family = family;
    this._isLoaded = false;
    this._resource = new Resource(path, "blob", bustCache);
    this._options = options;
  }
  async load() {
    if (this.isLoaded()) {
      return this.data;
    }
    try {
      const blob = await this._resource.load();
      const url = URL.createObjectURL(blob);
      if (!this.data) {
        this.data = new FontFace(this.family, `url(${url})`);
        document.fonts.add(this.data);
      }
      await this.data.load();
      this._isLoaded = true;
    } catch (error) {
      throw `Error loading FontSource from path '${this.path}' with error [${error.message}]`;
    }
    return this.data;
  }
  isLoaded() {
    return this._isLoaded;
  }
  /**
   * Build a font from this FontSource.
   * @param options {FontOptions} Override the font options
   */
  toFont(options) {
    return new Font({ family: this.family, ...this._options, ...options });
  }
}
const InsideCoroutineContext = createContext();
const generatorFunctionDeclaration = /^\s*(?:function)?\*/;
function isCoroutineGenerator(x) {
  if (typeof x !== "function") {
    return false;
  }
  if (generatorFunctionDeclaration.test(Function.prototype.toString.call(x))) {
    return true;
  }
  if (!Object.getPrototypeOf) {
    return false;
  }
  return Object.getPrototypeOf(x) === Object.getPrototypeOf(new Function("return function * () {}")());
}
function coroutine(...args) {
  var _a;
  const logger = Logger.getInstance();
  let coroutineGenerator;
  let thisArg;
  let options;
  let passedEngine;
  if (isCoroutineGenerator(args[0])) {
    thisArg = globalThis;
    coroutineGenerator = args[0];
    options = args[1];
  }
  if (isCoroutineGenerator(args[1])) {
    thisArg = args[0];
    coroutineGenerator = args[1];
    options = args[2];
  }
  if (args[1] instanceof Engine) {
    thisArg = args[0];
    passedEngine = args[1];
    coroutineGenerator = args[2];
    options = args[3];
  }
  if (args[0] instanceof Engine) {
    thisArg = globalThis;
    passedEngine = args[0];
    coroutineGenerator = args[1];
    options = args[2];
  }
  const inside = useContext(InsideCoroutineContext);
  const schedule = options == null ? void 0 : options.timing;
  const autostart = inside ? false : (_a = options == null ? void 0 : options.autostart) != null ? _a : true;
  let engine;
  try {
    engine = passedEngine != null ? passedEngine : Engine.useEngine();
  } catch (_) {
    throw Error(
      "Cannot run coroutine without engine parameter outside of an excalibur lifecycle method.\nPass an engine parameter to ex.coroutine(engine, function * {...})"
    );
  }
  let started = false;
  let completed = false;
  let cancelled = false;
  const generatorFcn = coroutineGenerator.bind(thisArg);
  const generator = generatorFcn();
  let loop;
  const complete = new Promise((resolve, reject) => {
    loop = (elapsed) => {
      try {
        if (cancelled) {
          completed = true;
          resolve();
          return;
        }
        const { done, value } = InsideCoroutineContext.scope(true, () => generator.next(elapsed));
        if (done || cancelled) {
          completed = true;
          resolve();
          return;
        }
        if (value instanceof Promise) {
          value.then(() => {
            engine.clock.schedule(loop, 0, schedule);
          });
        } else if (value === void 0 || value === void 0) {
          engine.clock.schedule(loop, 0, schedule);
        } else {
          engine.clock.schedule(loop, value || 0, schedule);
        }
      } catch (e) {
        reject(e);
        return;
      }
    };
    if (autostart) {
      started = true;
      loop(engine.clock.elapsed());
    }
  });
  const co = {
    isRunning: () => {
      return started && !cancelled && !completed;
    },
    isComplete: () => {
      return completed;
    },
    cancel: () => {
      cancelled = true;
    },
    start: () => {
      if (!started) {
        started = true;
        loop(engine.clock.elapsed());
      } else {
        logger.warn(
          ".start() was called on a coroutine that was already started, this is probably a bug:\n",
          Function.prototype.toString.call(generatorFcn)
        );
      }
      return co;
    },
    generator,
    done: complete,
    then: complete.then.bind(complete),
    [Symbol.iterator]: () => {
      return generator;
    }
  };
  return co;
}
class Transition extends Entity {
  constructor(options) {
    var _a, _b, _c, _d;
    super();
    this._logger = Logger.getInstance();
    this.transform = new TransformComponent();
    this.graphics = new GraphicsComponent();
    this._completeFuture = new Future();
    this.started = false;
    this._currentDistance = 0;
    this._currentProgress = 0;
    this.done = this._completeFuture.promise;
    this.name = `Transition#${this.id}`;
    this.duration = options.duration;
    this.easing = (_a = options.easing) != null ? _a : EasingFunctions.Linear;
    this.direction = (_b = options.direction) != null ? _b : "out";
    this.hideLoader = (_c = options.hideLoader) != null ? _c : false;
    this.blockInput = (_d = options.blockInput) != null ? _d : false;
    this.transform.coordPlane = CoordPlane.Screen;
    this.transform.pos = Vector.Zero;
    this.transform.z = Infinity;
    this.graphics.anchor = Vector.Zero;
    this.addComponent(this.transform);
    this.addComponent(this.graphics);
    if (this.direction === "out") {
      this._currentProgress = 0;
    } else {
      this._currentProgress = 1;
    }
  }
  /**
   * Returns a number between [0, 1] indicating what state the transition is in.
   *
   * * For 'out' direction transitions start at 0 and end at 1
   * * For 'in' direction transitions start at 1 and end at 0
   */
  get progress() {
    return this._currentProgress;
  }
  get complete() {
    if (this.direction === "out") {
      return this.progress >= 1;
    } else {
      return this.progress <= 0;
    }
  }
  /**
   * Overridable lifecycle method, called before each update.
   *
   * **WARNING BE SURE** to call `super.updateTransition()` if overriding in your own custom implementation
   * @param engine
   * @param elapsed
   */
  updateTransition(engine, elapsed) {
    if (this.complete) {
      return;
    }
    this._currentDistance += clamp(elapsed / this.duration, 0, 1);
    if (this._currentDistance >= 1) {
      this._currentDistance = 1;
    }
    if (this.direction === "out") {
      this._currentProgress = clamp(this.easing(this._currentDistance, 0, 1, 1), 0, 1);
    } else {
      this._currentProgress = clamp(this.easing(this._currentDistance, 1, 0, 1), 0, 1);
    }
  }
  /**
   * Overridable lifecycle method, called right before the previous scene has deactivated.
   *
   * This gives incoming transition a chance to grab info from previous scene if desired
   * @param scene
   */
  async onPreviousSceneDeactivate(scene) {
  }
  /**
   * Overridable lifecycle method, called once at the beginning of the transition
   *
   * `progress` is given between 0 and 1
   * @param progress
   */
  onStart(progress) {
  }
  /**
   * Overridable lifecycle method, called every frame of the transition
   *
   * `progress` is given between 0 and 1
   * @param progress
   */
  onUpdate(progress) {
  }
  /**
   * Overridable lifecycle method, called at the end of the transition,
   *
   * `progress` is given between 0 and 1
   * @param progress
   */
  onEnd(progress) {
  }
  /**
   * Overridable lifecycle method, called when the transition is reset
   *
   * Use this to override and provide your own reset logic for internal state in custom transition implementations
   */
  onReset() {
  }
  /**
   * reset() is called by the engine to reset transitions
   */
  reset() {
    this.started = false;
    this._completeFuture = new Future();
    this.done = this._completeFuture.promise;
    this._currentDistance = 0;
    if (this.direction === "out") {
      this._currentProgress = 0;
    } else {
      this._currentProgress = 1;
    }
    this.onReset();
  }
  /**
   * @internal
   */
  _addToTargetScene(engine, targetScene) {
    const currentScene = targetScene;
    if (this.started) {
      this._logger.warn(`Attempted to add a transition ${this.name} that is already playing.`);
    }
    if (currentScene.world.entityManager.getById(this.id)) {
      return this._co;
    }
    this._engine = engine;
    currentScene.add(this);
    const self = this;
    this._co = coroutine(
      engine,
      function* () {
        while (!self.complete) {
          const elapsed = yield;
          self.updateTransition(self._engine, elapsed);
          self._execute();
        }
      },
      {
        autostart: false
      }
    );
    return this._co;
  }
  /**
   * Called internally by excalibur to swap scenes with transition
   * @internal
   */
  async _play() {
    if (this.started) {
      this.reset();
      this._logger.warn(`Attempted to play a transition ${this.name} that is already playing, reset transition.`);
    }
    if (!this._engine || !this._co) {
      this.reset();
      this._logger.warn(`Attempted to play a transition ${this.name} that hasn't been added`);
    }
    if (this._co) {
      await this._co.start();
    }
  }
  /**
   * execute() is called by the engine every frame to update the Transition lifecycle onStart/onUpdate/onEnd
   * @internal
   */
  _execute() {
    if (!this.isInitialized) {
      return;
    }
    if (!this.started) {
      this.started = true;
      this.onStart(this.progress);
    }
    this.onUpdate(this.progress);
    if (this.complete && !this._completeFuture.isCompleted) {
      this.onEnd(this.progress);
      this._completeFuture.resolve();
    }
  }
}
class FadeInOut extends Transition {
  constructor(options) {
    var _a, _b;
    super({
      ...options,
      duration: (_a = options.duration) != null ? _a : 2e3
    });
    this.name = `FadeInOut#${this.id}`;
    this.color = (_b = options.color) != null ? _b : Color.Black;
  }
  onInitialize(engine) {
    this.transform.pos = engine.screen.unsafeArea.topLeft;
    this.screenCover = new Rectangle({
      width: engine.screen.resolution.width,
      height: engine.screen.resolution.height,
      color: this.color
    });
    this.graphics.add(this.screenCover);
    this.graphics.opacity = this.progress;
  }
  onReset() {
    this.graphics.opacity = this.progress;
  }
  onStart(progress) {
    this.graphics.opacity = progress;
  }
  onEnd(progress) {
    this.graphics.opacity = progress;
  }
  onUpdate(progress) {
    this.graphics.opacity = progress;
  }
}
class CrossFade extends Transition {
  constructor(options) {
    super({ direction: "in", ...options });
    this.name = `CrossFade#${this.id}`;
  }
  async onPreviousSceneDeactivate(scene) {
    this.image = await scene.engine.screenshot(true);
    await this.image.decode();
  }
  onInitialize(engine) {
    this.engine = engine;
    this.transform.pos = engine.screen.unsafeArea.topLeft;
    this.screenCover = ImageSource.fromHtmlImageElement(this.image).toSprite();
    this.graphics.add(this.screenCover);
    this.transform.scale = vec(1 / engine.screen.pixelRatio, 1 / engine.screen.pixelRatio);
    this.graphics.opacity = this.progress;
  }
  onStart(_progress) {
    this.graphics.opacity = this.progress;
  }
  onReset() {
    this.graphics.opacity = this.progress;
  }
  onEnd(progress) {
    this.graphics.opacity = progress;
  }
  onUpdate(progress) {
    this.graphics.opacity = progress;
  }
}
class Slide extends Transition {
  constructor(options) {
    var _a;
    super({ direction: "in", ...options });
    this._easing = EasingFunctions.Linear;
    this.name = `Slide#${this.id}`;
    this.slideDirection = options.slideDirection;
    this.transform.coordPlane = CoordPlane.World;
    this.graphics.forceOnScreen = true;
    this._easing = (_a = options.easingFunction) != null ? _a : this._easing;
    this._vectorEasing = EasingFunctions.CreateVectorEasingFunction(this._easing);
  }
  async onPreviousSceneDeactivate(scene) {
    this._image = await scene.engine.screenshot(true);
    await this._image.decode();
    this._screenCover = ImageSource.fromHtmlImageElement(this._image).toSprite();
  }
  onInitialize(engine) {
    this._engine = engine;
    switch (this.slideDirection) {
      case "up": {
        this._directionOffset = vec(0, -engine.screen.resolution.height);
        break;
      }
      case "down": {
        this._directionOffset = vec(0, engine.screen.resolution.height);
        break;
      }
      case "left": {
        this._directionOffset = vec(-engine.screen.resolution.width, 0);
        break;
      }
      case "right": {
        this._directionOffset = vec(engine.screen.resolution.width, 0);
        break;
      }
    }
    this._camera = this._engine.currentScene.camera;
    this._destinationCameraPosition = this._camera.pos.clone();
    this._camera.pos = this._camera.pos.add(this._directionOffset);
    this.transform.pos = this.transform.pos.add(this._directionOffset);
    this._startCameraPosition = this._camera.pos.clone();
    this.graphics.use(this._screenCover);
    this.transform.scale = vec(1 / engine.screen.pixelRatio, 1 / engine.screen.pixelRatio);
  }
  onUpdate(progress) {
    this._camera.pos = this._vectorEasing(progress, this._destinationCameraPosition, this._startCameraPosition, 1);
  }
}
const Index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ConsoleAppender,
  DrawUtil,
  EasingFunctions,
  LogLevel,
  Logger,
  Observable,
  ScreenAppender,
  addItemToArray,
  contains,
  delay,
  fail,
  getMinIndex,
  getPosition,
  isObject,
  mergeDeep,
  omit,
  removeItemFromArray
}, Symbol.toStringTag, { value: "Module" }));
const maxMessages = 5;
const obsoleteMessage = {};
const resetObsoleteCounter = () => {
  for (const message in obsoleteMessage) {
    obsoleteMessage[message] = 0;
  }
};
const logMessage = (message, options) => {
  const suppressObsoleteMessages = Flags.isEnabled("suppress-obsolete-message");
  if (obsoleteMessage[message] < maxMessages && !suppressObsoleteMessages) {
    Logger.getInstance().warn(message);
    if (console.trace && options.showStackTrace) {
      console.trace();
    }
  }
  obsoleteMessage[message]++;
};
function obsolete(options) {
  options = {
    message: "This feature will be removed in future versions of Excalibur.",
    alternateMethod: null,
    showStackTrace: false,
    ...options
  };
  return function(target, property, descriptor) {
    if (descriptor && !(typeof descriptor.value === "function" || typeof descriptor.get === "function" || typeof descriptor.set === "function")) {
      throw new SyntaxError("Only classes/functions/getters/setters can be marked as obsolete");
    }
    const methodSignature = `${target.name || ""}${target.name && property ? "." : ""}${property ? property : ""}`;
    const message = `${methodSignature} is marked obsolete: ${options.message}` + (options.alternateMethod ? ` Use ${options.alternateMethod} instead` : "");
    if (!obsoleteMessage[message]) {
      obsoleteMessage[message] = 0;
    }
    const method = descriptor ? { ...descriptor } : target;
    if (!descriptor) {
      class DecoratedClass extends method {
        constructor(...args) {
          logMessage(message, options);
          super(...args);
        }
      }
      return DecoratedClass;
    }
    if (descriptor && descriptor.value) {
      method.value = function() {
        logMessage(message, options);
        return descriptor.value.apply(this, arguments);
      };
      return method;
    }
    if (descriptor && descriptor.get) {
      method.get = function() {
        logMessage(message, options);
        return descriptor.get.apply(this, arguments);
      };
    }
    if (descriptor && descriptor.set) {
      method.set = function() {
        logMessage(message, options);
        return descriptor.set.apply(this, arguments);
      };
    }
    return method;
  };
}
class AsyncWaitQueue {
  constructor() {
    this._queue = [];
  }
  get length() {
    return this._queue.length;
  }
  enqueue() {
    const future = new Future();
    this._queue.push(future);
    return future.promise;
  }
  dequeue(value) {
    const future = this._queue.shift();
    future.resolve(value);
  }
}
class Semaphore {
  constructor(_count) {
    this._count = _count;
    this._waitQueue = new AsyncWaitQueue();
  }
  get count() {
    return this._count;
  }
  get waiting() {
    return this._waitQueue.length;
  }
  // eslint-disable-next-line require-await
  async enter() {
    if (this._count !== 0) {
      this._count--;
      return Promise.resolve();
    }
    return this._waitQueue.enqueue();
  }
  exit(count = 1) {
    if (count === 0) {
      return;
    }
    while (count !== 0 && this._waitQueue.length !== 0) {
      this._waitQueue.dequeue(null);
      count--;
    }
    this._count += count;
  }
}
const EX_VERSION = "0.31.0";
polyfill();
export {
  ActionCompleteEvent,
  ActionContext,
  ActionQueue,
  ActionSequence,
  ActionStartEvent,
  ActionsComponent,
  ActionsSystem,
  ActivateEvent,
  Actor,
  ActorEvents,
  AddEvent,
  AddedComponent,
  AffineMatrix,
  Animation,
  AnimationDirection,
  AnimationEvents,
  AnimationStrategy,
  ArcadeSolver,
  AudioContextFactory,
  Axes,
  Axis,
  BaseAlign,
  BezierCurve,
  Blink,
  BodyComponent,
  BoundingBox,
  BrowserComponent,
  BrowserEvents,
  Buttons,
  Camera,
  CameraEvents,
  Canvas,
  ChannelCollection,
  Circle,
  CircleCollider,
  Clock,
  ClosestLineJumpTable,
  Collider,
  ColliderComponent,
  CollisionContact,
  CollisionEndEvent,
  CollisionGroup,
  CollisionGroupManager,
  CollisionJumpTable,
  CollisionPostSolveEvent,
  CollisionPreSolveEvent,
  CollisionStartEvent,
  CollisionSystem,
  CollisionType,
  Color,
  ColorBlindFlags,
  ColorBlindnessMode,
  ColorBlindnessPostProcessor,
  Component,
  CompositeCollider,
  ConsoleAppender,
  ContactConstraintPoint,
  ContactEndEvent,
  ContactSolveBias,
  ContactStartEvent,
  CoordPlane,
  CrossFade,
  CurveBy,
  CurveTo,
  DeactivateEvent,
  Debug,
  DebugConfig,
  DebugGraphicsComponent,
  DebugSystem,
  DebugText,
  DefaultAntialiasOptions,
  DefaultGarbageCollectionOptions,
  DefaultLoader,
  DefaultPixelArtOptions,
  DegreeOfFreedom,
  Delay,
  Detector,
  Die,
  Direction,
  Director,
  DirectorEvents,
  DisplayMode,
  DynamicTree,
  DynamicTreeCollisionProcessor,
  EX_VERSION,
  EaseBy,
  EaseTo,
  EasingFunctions,
  Edge,
  EdgeCollider,
  ElasticToActorStrategy,
  EmitterType,
  Engine,
  EngineEvents,
  EnterTriggerEvent,
  EnterViewPortEvent,
  Entity,
  EntityEvents,
  EntityManager,
  EventEmitter,
  EventTypes,
  Events,
  ExResponse,
  ExcaliburGraphicsContext2DCanvas,
  ExcaliburGraphicsContextWebGL,
  ExitTriggerEvent,
  ExitViewPortEvent,
  Fade,
  FadeInOut,
  Flags,
  Flash,
  Follow,
  Font,
  FontCache,
  FontSource,
  FontStyle,
  FontUnit,
  FpsSampler,
  FrameStats,
  Future,
  GameEvent,
  GameStartEvent,
  GameStopEvent,
  Gamepad,
  GamepadAxisEvent,
  GamepadButtonEvent,
  GamepadConnectEvent,
  GamepadDisconnectEvent,
  Gamepads,
  GarbageCollector,
  Gif,
  GifParser,
  GlobalCoordinates,
  GpuParticleEmitter,
  GpuParticleRenderer,
  Graph,
  Graphic,
  GraphicsComponent,
  GraphicsGroup,
  GraphicsSystem,
  HashColliderProxy,
  HashGridCell,
  HashGridProxy,
  HiddenEvent,
  HorizontalFirst,
  ImageFiltering,
  ImageSource,
  ImageSourceAttributeConstants,
  ImageWrapping,
  InitializeEvent,
  InputHost,
  InputMapper,
  IsometricEntityComponent,
  IsometricEntitySystem,
  IsometricMap,
  IsometricTile,
  KeyEvent,
  Keyboard,
  Keys,
  KillEvent,
  Label,
  LimitCameraBoundsStrategy,
  Line,
  LineSegment,
  Loader,
  LoaderEvents,
  LockCameraToActorAxisStrategy,
  LockCameraToActorStrategy,
  LogLevel,
  Logger,
  Material,
  Matrix,
  MatrixLocations,
  MediaEvent,
  Meet,
  MotionComponent,
  MotionSystem,
  MoveBy,
  MoveByWithOptions,
  MoveTo,
  MoveToWithOptions,
  NativePointerButton,
  NativeSoundEvent,
  NativeSoundProcessedEvent,
  NineSlice,
  NineSliceStretch,
  Node,
  None,
  Observable,
  OffscreenSystem,
  Pair,
  ParallaxComponent,
  ParallelActions,
  Particle,
  ParticleEmitter,
  ParticleRenderer,
  ParticleTransform,
  PhysicsStats,
  PhysicsWorld,
  PointerAbstraction,
  PointerButton,
  PointerComponent,
  PointerEvent,
  PointerEventReceiver,
  PointerScope,
  PointerSystem,
  PointerType,
  Polygon,
  PolygonCollider,
  Pool,
  PositionNode,
  PostCollisionEvent,
  PostDebugDrawEvent,
  PostDrawEvent,
  PostFrameEvent,
  PostKillEvent,
  PostTransformDrawEvent,
  PostUpdateEvent,
  PreCollisionEvent,
  PreDebugDrawEvent,
  PreDrawEvent,
  PreFrameEvent,
  PreKillEvent,
  PreLoadEvent,
  PreTransformDrawEvent,
  PreUpdateEvent,
  Projection,
  QuadIndexBuffer,
  QuadTree,
  Query,
  QueryManager,
  RadiusAroundActorStrategy,
  Random,
  Raster,
  Ray,
  RealisticSolver,
  Rectangle,
  RemoveEvent,
  RemovedComponent,
  RentalPool,
  Repeat,
  RepeatForever,
  Resolution,
  Resource,
  ResourceEvents,
  RotateBy,
  RotateByWithOptions,
  RotateTo,
  RotateToWithOptions,
  RotationType,
  ScaleBy,
  ScaleByWithOptions,
  ScaleTo,
  ScaleToWithOptions,
  Scene,
  SceneEvents,
  Screen,
  ScreenAppender,
  ScreenElement,
  ScreenEvents,
  ScreenShader,
  ScrollPreventionMode,
  Semaphore,
  SeparatingAxis,
  SeparationInfo,
  Shader,
  Shape,
  Side,
  Slide,
  SolverStrategy,
  Sound,
  SoundEvents,
  SoundManager,
  SparseHashGrid,
  SparseHashGridCollisionProcessor,
  SpatialPartitionStrategy,
  Sprite,
  SpriteFont,
  SpriteSheet,
  StandardClock,
  StateMachine,
  StrategyContainer,
  Stream,
  System,
  SystemManager,
  SystemPriority,
  SystemType,
  TagQuery,
  TestClock,
  Text,
  TextAlign,
  TextureLoader,
  Tile,
  TileMap,
  TileMapEvents,
  TiledAnimation,
  TiledSprite,
  Timer,
  Toaster,
  Transform,
  TransformComponent,
  Transition,
  TreeNode,
  Trigger,
  TriggerEvents,
  TwoPI,
  UniformBuffer,
  Index as Util,
  Vector,
  VectorView,
  VertexBuffer,
  VertexLayout,
  VerticalFirst,
  VisibleEvent,
  WebAudio,
  WebAudioInstance,
  WheelDeltaMode,
  WheelEvent,
  World,
  approximatelyEqual,
  assert,
  canonicalizeAngle,
  clamp,
  coroutine,
  createId,
  frac,
  getDefaultPhysicsConfig,
  glTypeToUniformTypeName,
  hasGraphicsTick,
  hasOnAdd,
  hasOnInitialize,
  hasOnPostUpdate,
  hasOnPreUpdate,
  hasOnRemove,
  hasPostDraw,
  hasPreDraw,
  has_add,
  has_initialize,
  has_postupdate,
  has_preupdate,
  has_remove,
  inverseLerp,
  inverseLerpVector,
  isActor,
  isAddedComponent,
  isComponentCtor,
  isLoaderConstructor,
  isMoveByOptions,
  isMoveToOptions,
  isRemovedComponent,
  isRotateByOptions,
  isRotateToOptions,
  isScaleByOptions,
  isScaleToOptions,
  isSceneConstructor,
  isScreenElement,
  isSystemConstructor,
  lerp,
  lerpAngle,
  lerpVector,
  maxMessages,
  nextActionId,
  obsolete,
  parseImageFiltering,
  parseImageWrapping,
  pixelSnapEpsilon,
  randomInRange,
  randomIntInRange,
  range,
  remap,
  remapVector,
  resetObsoleteCounter,
  sign,
  toDegrees,
  toRadians,
  vec,
  webglUtil as webgl
};

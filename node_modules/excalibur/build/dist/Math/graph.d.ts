import type { Vector } from './vector';
/**
 * A unique identifier for a graph node or edge.
 */
export type G_UUID = string & {
    readonly __brand: unique symbol;
};
interface EdgeOptionsWithWeight {
    weight: number;
    useEuclidean?: false;
    /**
     * Whether the edge is directed.
     * @default false
     */
    directed?: boolean;
}
interface EdgeOptionsWeightless {
    weight?: undefined;
    useEuclidean?: false | undefined;
    /**
     * Whether the edge is directed.
     * @default false
     */
    directed?: boolean;
}
interface EdgeOptionsWithEuclidean {
    weight?: undefined;
    useEuclidean: true;
    /**
     * Whether the edge is directed.
     * @default false
     */
    directed?: boolean;
}
/**
 * Options for creating a new edge in the graph.
 */
type EdgeOptions = EdgeOptionsWithWeight | EdgeOptionsWithEuclidean | EdgeOptionsWeightless;
/**
 * A weighted graph data structure.
 * @template T The type of data stored in each node.
 */
export declare class Graph<T> {
    private _nodes;
    private _edges;
    adjacencyList: Map<G_UUID, Set<G_UUID>>;
    id: G_UUID;
    /**
     * Constructs a new graph data structure.
     *
     * This constructor initializes an empty graph with no nodes or edges.
     */
    constructor();
    /**
     * Adds a new node to the graph with the given data.
     * @returns The newly created node.
     */
    addNode(data: T, position?: Vector): Node<T> | PositionNode<T>;
    /**
     * Adds multiple new nodes to the graph with the given data.
     * @returns A map of all nodes in the graph, including the newly created ones.
     */
    addNodes(nodes: T[]): Map<G_UUID, Node<T>>;
    /**
     * Deletes a node from the graph along with all its associated edges.
     * This method removes the specified node and any edges connected to it
     * from the graph. It updates the internal structures to reflect these
     * changes.
     * @param node - The node to be deleted from the graph.
     * @returns A map of all remaining nodes in the graph.
     */
    deleteNode(node: Node<T>): Map<G_UUID, Node<T>>;
    /**
     * Adds a new edge between two nodes in the graph. If the edge already exists, it does not add a duplicate.
     * The function allows specifying edge options such as weight and directionality. For undirected edges,
     * it creates a duplicate edge in the reverse direction and links both edges as partners.
     * @param from - The source node of the edge.
     * @param to - The target node of the edge.
     * @param options - Optional settings for the edge, including weight and directionality.
     * @returns An array containing the created edge(s). If the edge is directed, the array contains one edge;
     *          if undirected, it contains both the original and the duplicate edge.
     */
    addEdge(from: Node<T>, to: Node<T>, options?: EdgeOptions): Edge<T>[];
    /**
     * Deletes an edge from the graph.
     *
     * This method removes the specified edge and its partner edge (if any) from the graph.
     * It updates the internal edge set and edge list accordingly. The source and target
     * nodes of the edge are also updated to reflect the removal of the edge.
     * @param edge - The edge to be deleted from the graph.
     */
    deleteEdge(edge: Edge<T>): void;
    /**
     * The set of nodes in the graph, keyed by their UUID.
     *
     * The map returned by this property is a shallow copy of the internal map.
     * The nodes in this map are not frozen, and may be modified by the caller.
     * @returns A shallow copy of the graph's internal node map.
     */
    get nodes(): Map<G_UUID, Node<T>>;
    /**
     * Gets a node by its UUID.
     * @param id - The UUID of the node to be retrieved.
     * @returns The node with the specified UUID, or undefined if no such node exists.
     */
    getNode(id: G_UUID): Node<T>;
    /**
     * Retrieves the set of edges in the graph.
     *
     * The returned set is a shallow copy of the internal edge set.
     * Modifications to this set do not affect the graph's internal state.
     * @returns A set containing all edges in the graph.
     */
    get edges(): Set<Edge<T>>;
    /**
     * Gets the neighbors of the given node.
     *
     * The returned array contains all of the nodes that are directly connected to the given node.
     * @param node - The node whose neighbors should be retrieved.
     * @returns An array of nodes that are directly connected to the given node.
     */
    getNeighbors(node: Node<T>): Node<T>[];
    /**
     * Checks if two nodes are connected by an edge.
     * @param node1 - The first node to check.
     * @param node2 - The second node to check.
     * @returns true if the nodes are connected, false if not.
     */
    areNodesConnected(node1: Node<T>, node2: Node<T>): boolean;
    /**
     * Performs a breadth-first search (BFS) on the graph starting from the given node.
     *
     * This method explores the graph layer by layer, starting from the specified node.
     * It visits all nodes that are directly connected to the start node before moving
     * on to the nodes at the next level of the graph.
     * @param startNode - The node to start the BFS from.
     * @returns An array of UUIDs representing the nodes that were visited during the search.
     *          The order of the nodes in the array corresponds to the order in which they
     *          were visited.
     */
    bfs(startNode: Node<T>): G_UUID[];
    /**
     * Performs a depth-first search (DFS) on the graph starting from the given node.
     *
     * This method explores the graph by traversing as far as possible along each
     * branch before backtracking. It visits all nodes that are reachable from the
     * start node.
     * @param startNode - The node to start the DFS from.
     * @param [visited] - A set of node IDs that have already been visited during
     *                    the search. This parameter is optional, and defaults to an
     *                    empty set.
     * @returns An array of UUIDs representing the nodes that were visited during the
     *          search. The order of the nodes in the array corresponds to the order
     *          in which they were visited.
     */
    dfs(startNode: Node<T>, visited?: Set<string>): G_UUID[];
    /**
     * Creates a new graph from an array of nodes, and adds them all to the graph.
     * @param nodes - The array of nodes to add to the graph.
     * @returns The newly created graph.
     */
    static createGraphFromNodes<T>(nodes: T[]): Graph<T>;
    /**
     * Finds the shortest path between two nodes in the graph using Dijkstra's algorithm.
     *
     * This method calculates the shortest path from the specified start node to the
     * specified end node in the graph. It returns an object containing the path and
     * the total distance of the path.
     * @param startNode - The node from which the search for the shortest path begins.
     * @param endNode - The node where the search for the shortest path ends.
     * @returns An object containing:
     *   - `path`: An array of nodes representing the shortest path from startNode to endNode.
     *     If no path is found, this will be `null`.
     *   - `distance`: The total distance of the shortest path. If no path is found, this will
     *     be `Infinity`.
     */
    dijkstra(sourcenode: Node<T>): Array<{
        node: Node<T>;
        distance: number;
        previous: Node<T> | null;
    }>;
    /**
     * Finds the shortest path between two nodes in the graph using the Dijkstra method
     *
     * This method calculates the shortest path from the specified start node to the
     * specified end node in the graph. It returns an object containing the path and
     * the total distance of the path.
     * @param startingNode - The node from which the search for the shortest path begins.
     * @param endNode - The node where the search for the shortest path ends.
     * @returns An object containing:
     *   - `path`: An array of nodes representing the shortest path from startNode to endNode.
     *     If no path is found, this will be `null`.
     *   - `distance`: The total distance of the shortest path. If no path is found, this will
     *     be `Infinity`.
     */
    shortestPathDijkstra(startingNode: Node<T>, endNode: Node<T>): {
        path: Node<T>[];
        distance: number;
    };
    /**
     * Finds the shortest path between two nodes in the graph using the A* algorithm.
     *
     * This method calculates the shortest path from the specified start node to the
     * specified end node in the graph. It returns an object containing the path and
     * the total distance of the path.
     * @param startNode - The node from which the search for the shortest path begins.
     * @param endNode - The node where the search for the shortest path ends.
     * @returns An object containing:
     *   - `path`: An array of nodes representing the shortest path from startNode to endNode.
     *     If no path is found, this will be `null`.
     *   - `distance`: The total distance of the shortest path. If no path is found, this will
     *     be `Infinity`.
     *   - `skippedNodes`: A set of all nodes that were skipped during the search (because they
     *     were not `PositionNode`s).
     */
    aStar(startNode: PositionNode<T>, endNode: PositionNode<T>): {
        path: PositionNode<T>[] | null;
        pathSteps: number;
        distance: number;
        skippedNodes: Set<G_UUID>;
    };
    private _euclideanDistance;
}
/**
 * Represents an edge in a graph, connecting two nodes.
 * @template T The type of data stored in the nodes connected by this edge.
 */
export declare class Edge<T> {
    private _id;
    private _source;
    private _target;
    private _weight;
    private _partnerEdge;
    constructor(source: Node<T>, target: Node<T>, config?: EdgeOptions);
    linkWithPartner(partnerEdge: Edge<T>): void;
    get id(): G_UUID;
    get source(): Node<T>;
    get target(): Node<T>;
    get weight(): number;
    get partnerEdge(): Edge<T>;
}
/**
 * Represents a node in a graph, with a unique identifier and optional data.
 * @template T The type of data stored in this node.
 */
export declare class Node<T> {
    private _id;
    private _data;
    private _edges;
    constructor(data: T);
    get id(): G_UUID;
    get data(): T;
    get edges(): Set<Edge<T>>;
    registerNewEdge(newEdge: Edge<T>): void;
    breakEdge(edge: Edge<T>): void;
    getConnectedNodes(): Node<T>[];
}
/**
 * Represents a node in a graph with a unique identifier, optional data, and a position in space.
 * @template T The type of data stored in this node.
 * @augments {Node<T>}
 */
export declare class PositionNode<T> extends Node<T> {
    pos: Vector;
    constructor(data: T, pos: Vector);
}
export {};
